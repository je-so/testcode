/* title: Core-Interrupt

   Gibt Zugriff auf auf Cortex-M4 (STM32F303xC spezifisch) Prozessor Peripherie:

      o Nested Vectored Interrupt Controller (NVIC) – Exceptions und Interrupts
      o Extended interrupts and events controller (EXTI) - Anbindung Peripherie, etwa GPIO, an NVIC

   Definition Pending:
   Pending Bits werden auf 1 gesetzt, wenn eine Exception auftritt are und sie werden
   auf 0 gesetzt, wenn diese aktiv wird. Pending Bits können mit is_[core]interrupt abgefragt werden.
   Sie können auch noch vor der Aktivierung der Exception gelöscht werden mit clear_[core]interrupt.
   Damit wird die Ausführung einer Exception verhindert.

   Definition Active:
   Active Bits werden auf 1 gesetzt, wenn die zugehörige Exception die gerade aktive ist, also die
   implementierende Funktion (IRQ-Handler) ausgeführt wird, oder diese durch eine weitere Exception
   mit höherer Priorität unterbrochen wurde, also verschachtelt (nested) ist.
   Mittels isactive_[core]interrupt kann dieses Bit abgefragt werden.
   Damit Exceptions überhaupt aktiv werden können, müssen diese vorher eingeschaltet worden sein
   mit enable_[core]interrupt.

   Copyright:
   This program is free software. See accompanying LICENSE file.

   Author:
   (C) 2016 Jörg Seebohn

   file: µC/interrupt.h
    Header file <Core-Interrupt>.

   file: TODO: µC/interrupt.c
    Implementation file <Core-Interrupt impl>.
*/
#ifndef STM32F303xC_MC_INTERRUPT_HEADER
#define STM32F303xC_MC_INTERRUPT_HEADER

// == exported Peripherals/HW-Units
#define hNVIC    ((core_nvic_t*) HW_REGISTER_BASEADDR_NVIC)

// == exported types

// TODO: remove after gpio changed
typedef enum interrupt_edge_e {
   interrupt_edge_FALLING = 1,
   interrupt_edge_RISING = 2,
} interrupt_edge_e;

typedef enum interrupt_priority_e {
   interrupt_priority_HIGH = 0,
   interrupt_priority_MID  = HW_BIT(SCB, SHPR, PRI_MAX) / 2,
   interrupt_priority_LOW  = HW_BIT(SCB, SHPR, PRI_MAX),
} interrupt_priority_e;

#define interrupt_priority__NROF (interrupt_priority_LOW+1)

typedef enum coreinterrupt_e {
   coreinterrupt_RESET = 1,      // hard coded Priority: -3; always enabled; Power-On-Reset or Software Reset
   coreinterrupt_NMI   = 2,      // hard coded Priority: -2; always enabled; Non maskable interrupt.
   coreinterrupt_FAULT = 3,      // hard coded Priority: -1; always enabled; All cases of faults, called if other fault handlers disabled
   coreinterrupt_MPUFAULT = 4,   // Settable Priority: 0; default disabled; Memory Protection Error.
   coreinterrupt_BUSFAULT = 5,   // Settable Priority: 0; default disabled; Pre-fetch Fault, illegal address.
   coreinterrupt_USAGEFAULT = 6, // Settable Priority: 0; default disabled; Undefined Instruction or Illegal State.
   coreinterrupt_SVCALL  = 11,   // Settable Priority: 0; always enabled; Generated by Execution of Supervisor Call: SVC{cond} #imm
   coreinterrupt_DEBUGMONITOR = 12, // Settable Priority: 0; default disabled; Cortex-M4 Debug Monitor.
                                    // Setting the pending bit makes it active even if it is disabled.
                                    // Enabling it is a hint to the debug unit to handle debug events with activation of DEBUGMONITOR exception if no external debugger is connected.
   coreinterrupt_PENDSV  = 14,   // Settable Priority: 0; always enabled; Pendable request for system service.
   coreinterrupt_SYSTICK = 15,   // Settable Priority: 0; always enabled; System tick timer.
} coreinterrupt_e;

typedef enum interrupt_e {
   // default state for all interrupt_e: disabled

   interrupt_WWDG = 16,    // Window Watchdog interrupt
   interrupt_PVD  = 17,    // PVD through EXTI line 16 detection interrupt
   interrupt_GPIOPIN0 = 22,   // EXTI Line0 interrupt (Pin 0 of PortA - PortH)
   // TODO: interrupt_GPIOPIN1 = 23,   // EXTI Line1 interrupt (Pin 1 of PortA - PortH)
   interrupt_GPIOPIN2_TSC = 24, // EXTI Line2 and Touch sensing interrupts
   // TODO: interrupt_GPIOPIN3 = 25,
   // TODO: interrupt_GPIOPIN4 = 26,

   interrupt_DMA1_CHANNEL1 = 27,
   interrupt_DMA1_CHANNEL2 = 28,
   interrupt_DMA1_CHANNEL3 = 29,
   interrupt_DMA1_CHANNEL4 = 30,
   interrupt_DMA1_CHANNEL5 = 31,
   interrupt_DMA1_CHANNEL6 = 32,
   interrupt_DMA1_CHANNEL7 = 33,

   interrupt_TIMER6_DAC = 70, // Timer6 and DAC underflow/underrun interrupt
   interrupt_TIMER7     = 71, // Timer7 interrupt

   interrupt_DMA2_CHANNEL1 = 72,
   interrupt_DMA2_CHANNEL2 = 73,
   interrupt_DMA2_CHANNEL3 = 74,
   interrupt_DMA2_CHANNEL4 = 75,
   interrupt_DMA2_CHANNEL5 = 76,
} interrupt_e;

// == exported functions

// == sleep mode/power save mode
static inline void wait_for_interrupt(void);          // enter sleep mode (see WFI)
static inline void wait_for_event_or_interrupt(void); // enter sleep mode (see WFE)
// TODO: add change from sleep to deep sleep states

// == priority management (interrupt masks set execution priority cpu in Thread mode)
static inline void enable_all_interrupt(void);
static inline void disable_all_interrupt(void); // masks interrupts with priority >= 0
static inline uint32_t getmask_interrupt(void); // returns 1: disable_all_interrupt called last. 0: enable_all_interrupt called last.
static inline void enable_fault_interrupt(void);
static inline void disable_fault_interrupt(void);     // masks interrupts including fault interrupt with priority >= -1
static inline uint32_t getfaultmask_interrupt(void);  // returns 1: disable_fault_interrupt called last. 0: enable_fault_interrupt called last.
static inline void setprioritymask_interrupt(uint8_t priority/*0:no priority masking*/); // mask interrupts with priority <= priority
static inline uint32_t getprioritymask_interrupt(void); // returns 0: No masking. M!=0: Interrups with priority <= M are masked.
static inline void clearprioritymask_interrupt(void);

// == interrupt_e
static inline int setpriority_interrupt(interrupt_e intnr, interrupt_priority_e priority);
static inline uint8_t getpriority_interrupt_nvic(interrupt_e intnr);
static inline int isenabled_interrupt_nvic(interrupt_e intnr);
static inline int enable_interrupt(interrupt_e intnr);
static inline int disable_interrupt(interrupt_e intnr);
static inline int generate_interrupt(interrupt_e intnr);
static inline int clear_interrupt(interrupt_e intnr);
static inline int is_interrupt(interrupt_e intnr);
static inline int isactive_interrupt(interrupt_e intnr); // returns 1: interrupt_e intnr is active and cpu is in Handler mode. 0: Not active but others could be.
static inline int is_any_interrupt(void); // returns 1: External interrupt_e is pending (coreinterrupt_e are not considered). 0: No external interrupt is pending.
static inline uint8_t highestpriority_interrupt(void); // returns coreinterrupt_e/interrupt_e with highest priority ready for execution if priority allows it
static inline uint8_t active_interrupt(void);   // returns 0: Thread mode. M!=0: coreinterrupt_e/interrupt_e with number M is active.

// == coreinterrupt_e
static inline int setpriority_coreinterrupt(coreinterrupt_e intnr, interrupt_priority_e priority);
static inline uint8_t getpriority_coreinterrupt(coreinterrupt_e intnr);
static inline int generate_coreinterrupt(coreinterrupt_e intnr);
static inline int clear_coreinterrupt(coreinterrupt_e intnr);
static inline int is_coreinterrupt(coreinterrupt_e intnr);
static inline int isactive_coreinterrupt(coreinterrupt_e intnr);
static inline int enable_coreinterrupt(coreinterrupt_e intnr);
static inline int disable_coreinterrupt(coreinterrupt_e intnr);
static inline int isenabled_coreinterrupt(coreinterrupt_e intnr);

// == functions exclusively callable by exception/interrupt handlers
static inline int isret2threadmode_interrupt(void);   // returns 1: Processor was interrupted in "Thread mode". 0: Another active handler was interrupted/Processor was interrupted in "Handler mode".

// == interrupt vector table
static inline uint32_t sizealign_interruptTable(void);   // ramaddr must be aligned to this byte size (512 bytes)
static inline uint32_t len_interruptTable(void);         // number of entries in vector table (size_in_bytes=sizeof(uint32_t)*len_vectab_interrupt())
static inline int  relocate_interruptTable(/*out*/uint32_t ramaddr[/*len_interruptTable()*/]);  // copies ROM table into RAM and stores new address into NVIC
static inline void reset_interruptTable(void);           // let NVIC use the ROM table

// == interrupt configuration control
static inline void disable_synchronous_busfault_interrupt(void);  // ignores synchronous/precise BUSFAULT in FAULT or NMI interrupt handler (if execution priority <= -1) which would lead to lockup
static inline void enable_synchronous_busfault_interrupt(void);   // (default after reset) synchronous/precise BUSFAULT in FAULT or NMI interrupt handler leads to cpu lockup
static inline int  isignored_synchronous_busfault_interrupt(void);// returns 1: disable_synchronous_busfault_interrupt called last. 0: enable_synchronous_busfault_interrupt called last.


// == definitions

// == Register Offsets

// TODO: remove EXTI
/* Register Offset (EXTI_IMR1) Interrupt mask register; Reset value: 0x1F800000
 * Bits 31:0 MRx: Event mask on external/internal line x; 0 == Masked, 1 == Interrupt Enabled */
#define HW_REGISTER_OFFSET_EXTI_IMR1 0x00
/* Register Offset (EXTI_IMR2) Interrupt mask register; Reset value: 0xFFFFFFFC
 * Bits 3:0 MRx: Interrupt mask on external/internal line x, x = 32..35; 0 == Masked, 1 == Interrupt Enabled */
#define HW_REGISTER_OFFSET_EXTI_IMR2 0x20
/* Register Offset (EXTI_RTSR1) Rising trigger selection register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Rising trigger event configuration bit of line x; 1 == Rising Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_RTSR1 0x08
/* Register Offset (EXTI_RTSR2) Rising trigger selection register; Reset value: 0x00000000
 * Bits 1:0 TRx: Rising trigger event configuration bit of line x, x=32..33; 1 == Rising Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_RTSR2 0x28
/* Register Offset (EXTI_FTSR1) Falling trigger selection register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Falling trigger event configuration bit of line x; 1 == Falling Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_FTSR1 0x0C
/* Register Offset (EXTI_FTSR2) Falling trigger selection register; Reset value: 0x00000000
 * Bits 1:0 TRx: Falling trigger event configuration bit of line x, x=32..33; 1 == Falling Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_FTSR2 0x2C
/* Register Offset (EXTI_SWIER1) Software interrupt event register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Software interrupt on line x; 1 == Sets Pending Bit if IMR Bit also == 1 */
#define HW_REGISTER_OFFSET_EXTI_SWIER1 0x10
/* Register Offset (EXTI_SWIER2) Software interrupt event register; Reset value: 0x00000000
 * Bits 1:0 TRx: Software interrupt on line x, x=32..33; 1 == Sets Pending Bit if IMR Bit also == 1 */
#define HW_REGISTER_OFFSET_EXTI_SWIER2 0x30
/* Register Offset (EXTI_PR1) Pending register ; Reset value: undefined
 * Bits 31:29 + Bits 22:0 TRx: Pending bit on line x; 1 == Selected trigger request occurred
 * The bits are cleared by writing a ‘1’ to the bit (interrupt acknowledge) */
#define HW_REGISTER_OFFSET_EXTI_PR1 0x14
/* Register Offset (EXTI_PR2) Pending register ; Reset value: undefined
 * Bits 1:0 TRx: Pending bit on line x, x=32..33; 1 == Selected trigger request occurred
 * The bits are cleared by writing a ‘1’ to the bit (interrupt acknowledge) */
#define HW_REGISTER_OFFSET_EXTI_PR2 0x34


// section: inline implementation

/* function: wait_for_interrupt
 * Versetzt den Prozessor in den Schlafmodus.
 * Daraust erwacht er mit dem nächsten Interrupt. */
static inline void wait_for_interrupt(void)
{
   __asm( "WFI" );
}

/* function: wait_for_interrupt
 * Versetzt den Prozessor in den Schlafmodus, falls das interne Eventbit nicht gesetzt ist.
 * Daraust erwacht er mit dem nächsten Interrupt oder Event, siehe auch Instruktionen WFE und SEV. */
static inline void wait_for_event_or_interrupt(void)
{
   __asm( "WFE" );
}

/* function: enable_all_interrupt
 * Schaltet alle Interrupts wieder ein, die mit disable_all_interrupt ausgeschaltet wurden.
 *
 * Ergebnis:
 * <getmask_interrupt> liefert 0 zurück (Default nach Reset). */
static inline void enable_all_interrupt(void)
{
   __asm( "cpsie I" );
}

/* function: disable_all_interrupt
 * Maskiert alle Interrupts (Pending Bits bleiben erhalten), bis auf NMI, Reset und Fault.
 *
 * Ergebnis:
 * <getmask_interrupt> liefert 1 zurück. */
static inline void disable_all_interrupt(void)
{
   __asm( "cpsid I" );
}

/* function: getmask_interrupt
 * Liefert 1 zurück, falls die Interrupts (ausser NMI,Reset,Fault) maskiert sind, sonst 0.
 * disable_all_interrupts schaltet die "normalen" Interrupts aus mit maximal Priorität 0. */
static inline uint32_t getmask_interrupt(void)
{
   uint32_t mask;
   __asm( "mrs %[result], PRIMASK" : [result] "=r" (mask) ::);
   return mask;
}

/* function: enable_fault_interrupt
 * Schaltet alle Interrupts wieder ein.
 *
 * Ergebnis:
 * <getfaultmask_interrupt> liefert 0 zurück (Default nach Reset). */
static inline void enable_fault_interrupt(void)
{
   __asm( "cpsie F" );
}

/* function: enable_fault_interrupt
 * Maskiert alle Interrupts (Pending Bits bleiben erhalten), bis auf NMI und Reset.
 * Diese Maske ist zusätzlich und unabhängig von <disable_all_interrupt> zu verstehen.
 *
 * Ergebnis:
 * <getfaultmask_interrupt> liefert 1 zurück. */
static inline void disable_fault_interrupt(void)
{
   __asm( "cpsid F" );
}

static inline uint32_t getfaultmask_interrupt(void)
{
   uint32_t mask;
   __asm( "mrs %[result], FAULTMASK" : [result] "=r" (mask) ::);
   return mask;
}

/* function: setprioritymask_interrupt
 * Erlaubt nur Interrupts mit höherer Priorität als priority.
 * Parameterwert 0 schaltet die Basispriortät aus.
 * Mit <disable_all_interrupt> können alle Interrupts einschliesslich der höchsten Priorität 0
 * temporär maskiert werden. */
static inline void setprioritymask_interrupt(uint8_t priority/*0:no priority masking*/)
{
   priority <<= (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
   __asm( "msr BASEPRI, %[bp]" :: [bp] "r" (priority) :);
}

static inline uint32_t getprioritymask_interrupt(void)
{
   uint32_t priority;
   __asm( "mrs %[result], BASEPRI" : [result] "=r" (priority) ::);
   return priority >> (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
}

static inline void clearprioritymask_interrupt(void)
{
   __asm( "msr BASEPRI, %[bp]" :: [bp] "r" (0) :);
}

#define VALIDATE_ADAPT_INTNR_NVIC(intnr, return_code) \
         intnr -= 16;                                                \
         if ((uint32_t)intnr > (HW_KONFIG_NVIC_INTERRUPT_MAXNR-16)){ \
            return return_code;                                      \
         }

static inline int setpriority_interrupt(interrupt_e intnr, interrupt_priority_e priority)
{
   static_assert(interrupt_priority_HIGH == 0 && interrupt_priority_HIGH < interrupt_priority_LOW);
   if (priority > interrupt_priority_LOW) {
      return EINVAL;
   }

   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->ipr[intnr] = (uint8_t) (priority << (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS));

   return 0;
}

static inline uint8_t getpriority_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 255)

   return hNVIC->ipr[intnr] >> (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
}

static inline int enable_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->iser[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int disable_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->icer[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int isenabled_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   return (hNVIC->iser[intnr/32] >> (intnr & 31)) & 1;
}

static inline int generate_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->ispr[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int clear_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->icpr[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int is_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   return (hNVIC->ispr[intnr/32] >> (intnr & 31)) & 0x1;
}

static inline int isactive_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   return (hNVIC->iabr[intnr/32] >> (intnr & 31)) & 0x1;
}

static inline int is_any_interrupt(void)
{
   return (hSCB->icsr >> HW_BIT(SCB, ICSR, ISRPENDING_POS)) & 1;
}

/* Gibt Nummer des anstehenden(pending) Interrupts/Coreinterrupts mit höchster Priorität zurück.
 * Die Interruptnummern coreinterrupt_RESET, coreinterrupt_NMI und coreinterrupt_FAULT
 * werden niemals zurückgegeben, da diese nicht Pending sein können.
 * Interrupts, die anstehen aber nicht eingeschaltet wurden, werden von dieser
 * Funktion nicht berücksichtigt. Interrupts werden dann nicht sofort ausgeführt,
 * wenn der Prozessor einen Interrupt mit höherer oder gleicher Priorität ausführt
 * oder die Interruptpriorität kleiner oder gleich der mittels setprioritymask_interrupt
 * gesetzten ist. */
static inline uint8_t highestpriority_interrupt(void)
{
   return (uint8_t) (hCORE->scb.icsr >> HW_BIT(SCB, ICSR, VECTPENDING_POS));
}

static inline uint8_t active_interrupt(void)
{
    uint32_t active;
   __asm( "mrs %[result], IPSR" : [result] "=r" (active) ::);
   return (uint8_t) active;
}

#undef VALIDATE_ADAPT_INTNR_NVIC

static inline int setpriority_coreinterrupt(coreinterrupt_e intnr, interrupt_priority_e priority)
{
   static_assert(interrupt_priority_HIGH < interrupt_priority_LOW);
   intnr -= coreinterrupt_MPUFAULT; // intnr < coreinterrupt_MPUFAULT ==> hard coded priority
   if ((uint32_t)intnr > (15-coreinterrupt_MPUFAULT) || priority > interrupt_priority_LOW) {
      return EINVAL;
   }

   hSCB->shpr[intnr] = (uint8_t) (priority << HW_BIT(SCB, SHPR, PRI_POS));

   return 0;
}

static inline uint8_t getpriority_coreinterrupt(coreinterrupt_e intnr)
{
   intnr -= coreinterrupt_MPUFAULT; // intnr < coreinterrupt_MPUFAULT ==> hard coded priority
   if ((uint32_t)intnr > (15-coreinterrupt_MPUFAULT)) {
      return 255;
   }

   return hSCB->shpr[intnr] >> HW_BIT(SCB, SHPR, PRI_POS);
}

static inline int generate_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_NMI:
      hSCB->icsr = HW_BIT(SCB, ICSR, NMIPENDSET);
      break;
   case coreinterrupt_MPUFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, MEMFAULTPENDED));
      break;
   case coreinterrupt_BUSFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, BUSFAULTPENDED));
      break;
   case coreinterrupt_USAGEFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, USGFAULTPENDED));
      break;
   case coreinterrupt_SVCALL:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, SVCALLPENDED));
      break;
   case coreinterrupt_DEBUGMONITOR:
      // TODO: atomic ?
      HW_REGISTER(SCS, DEMCR) |= HW_REGISTER_BIT_SCS_DEMCR_MONPEND;
      break;
   case coreinterrupt_PENDSV:
      hSCB->icsr = HW_BIT(SCB, ICSR, PENDSVSET);
      break;
   case coreinterrupt_SYSTICK:
      hSCB->icsr = HW_BIT(SCB, ICSR, PENDSTSET);
      break;
   }

   return 0;
}

static inline int clear_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, MEMFAULTPENDED));
      break;
   case coreinterrupt_BUSFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, BUSFAULTPENDED));
      break;
   case coreinterrupt_USAGEFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, USGFAULTPENDED));
      break;
   case coreinterrupt_SVCALL:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, SVCALLPENDED));
      break;
   case coreinterrupt_DEBUGMONITOR:
      // TODO: atomic ?
      HW_REGISTER(SCS, DEMCR) &= ~HW_REGISTER_BIT_SCS_DEMCR_MONPEND;
      break;
   case coreinterrupt_PENDSV:
      hSCB->icsr = HW_BIT(SCB, ICSR, PENDSVCLR);
      break;
   case coreinterrupt_SYSTICK:
      hSCB->icsr = HW_BIT(SCB, ICSR, PENDSTCLR);
      break;
   }

   return 0;
}

static inline int is_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      break;
   case coreinterrupt_MPUFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, MEMFAULTPENDED_POS)) & 1;
   case coreinterrupt_BUSFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, BUSFAULTPENDED_POS)) & 1;
   case coreinterrupt_USAGEFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, USGFAULTPENDED_POS)) & 1;
   case coreinterrupt_SVCALL:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, SVCALLPENDED_POS)) & 1;
   case coreinterrupt_DEBUGMONITOR:
      return (HW_REGISTER(SCS, DEMCR) / HW_REGISTER_BIT_SCS_DEMCR_MONPEND) & 1;
   case coreinterrupt_PENDSV:
      return (hSCB->icsr >> HW_BIT(SCB, ICSR, PENDSVSET_POS)) & 1;
   case coreinterrupt_SYSTICK:
      return (hSCB->icsr >> HW_BIT(SCB, ICSR, PENDSTSET_POS)) & 1;
   }

   return 0;
}

static inline int isactive_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      break;
   case coreinterrupt_MPUFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, MEMFAULTACT_POS)) & 1;
   case coreinterrupt_BUSFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, BUSFAULTACT_POS)) & 1;
   case coreinterrupt_USAGEFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, USGFAULTACT_POS)) & 1;
   case coreinterrupt_SVCALL:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, SVCALLACT_POS)) & 1;
   case coreinterrupt_DEBUGMONITOR:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, MONITORACT_POS)) & 1;
   case coreinterrupt_PENDSV:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, PENDSVACT_POS)) & 1;
   case coreinterrupt_SYSTICK:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, SYSTICKACT_POS)) & 1;
   }

   return 0;
}

static inline int enable_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, MEMFAULTENA));
      break;
   case coreinterrupt_BUSFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, BUSFAULTENA));
      break;
   case coreinterrupt_USAGEFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, USGFAULTENA));
      break;
   case coreinterrupt_DEBUGMONITOR:
      // TODO: atomic ?
      HW_REGISTER(SCS, DEMCR) |= HW_REGISTER_BIT_SCS_DEMCR_MONEN;
      break;
   }
   return 0;
}

static inline int disable_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, MEMFAULTENA));
      break;
   case coreinterrupt_BUSFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, BUSFAULTENA));
      break;
   case coreinterrupt_USAGEFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, USGFAULTENA));
      break;
   case coreinterrupt_DEBUGMONITOR:
      // TODO: atomic ?
      HW_REGISTER(SCS, DEMCR) &= ~HW_REGISTER_BIT_SCS_DEMCR_MONEN;
      break;
   }
   return 0;
}

static inline int isenabled_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      break;
   case coreinterrupt_MPUFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTENA) & 1;
   case coreinterrupt_BUSFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTENA) & 1;
   case coreinterrupt_USAGEFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_USGFAULTENA) & 1;
   case coreinterrupt_DEBUGMONITOR:
      return (HW_REGISTER(SCS, DEMCR) / HW_REGISTER_BIT_SCS_DEMCR_MONEN) & 1;
   }
   return 1/*default is enabled*/;
}

static inline int isret2threadmode_interrupt(void)
{
   return (hSCB->icsr >> HW_BIT(SCB, ICSR, RETTOBASE_POS)) & 1;
}

/* Gibt den WErt zurück, durch den die neue Ramdresse (ramaddr) der Vektortabelle teilbar sein muss.
 * Der zurückgegebene Wert beträgt 512, so dass ramaddr auf eine 512 Byte Seitengrenze ausgerichtet sein muss. */
static inline uint32_t sizealign_interruptTable(void)
{
   return 1u << HW_BIT(SCB, VTOR, TBLOFF_POS);
}

/* Gibt die Länge des neuen Interruptvektors an.
 * Die Größe in Bytes ergibt sich aus: len_interruptTable() * sizeof(uint32_t). */
static inline uint32_t len_interruptTable(void)
{
   return HW_KONFIG_NVIC_INTERRUPT_MAXNR+1;
}

/* Initialisiert ramaddr Array und lässt NVIC dieses als neuen Interruptvektor nutzen.
 * Zur Initialsierung werden len_interruptTable() Einträge aus dem ROM-Interruptvektor an die neue ramaddr kopiert.
 * Die Größe des Speicherblockes, auf den ramaddr zeigt, muss mindestens (len_interruptTable() * sizeof(uint32_t))
 * Bytes betragen.
 * Wenn ramaddr nicht korrekt auf sizealign_interruptTable() Bytes ausgerichtet wurde oder nicht innerhalb
 * der ersten 1GB zu liegen kommt, wird der Fehlercode EINVAL zurückgegeben. */
static inline int relocate_interruptTable(/*out*/uint32_t ramaddr[/*len_interruptTable()*/])
{
   if (((uintptr_t)ramaddr & ~HW_BIT(SCB, VTOR, TBLOFF))) {
      return EINVAL;
   }

   uint32_t *ROMTABLE = (uint32_t*) 0;
   for (uint32_t i = 0; i <= HW_KONFIG_NVIC_INTERRUPT_MAXNR; ++i) {
      ramaddr[i] = ROMTABLE[i];
   }

   __asm volatile("dmb");  // ensure all changes to ramaddr are written before ramaddr is written into vtor
   hSCB->vtor = (uintptr_t) ramaddr;

   return 0;
}

/* Der Interruptcontroller wird veranlasst, wieder den Interruptvektor aus dem ROM zu nutzen.
 * Die RAM-Tabelle wird dabei nicht geändert. */
static inline void reset_interruptTable(void)
{
   hSCB->vtor = 0;         // switch back to vector table stored in rom
   __asm volatile("dsb");  // wait until change is written to vtor
}

static inline void disable_synchronous_busfault_interrupt(void)
{
   setbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, BFHFNMIGN));
}

static inline void enable_synchronous_busfault_interrupt(void)
{
   clearbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, BFHFNMIGN));
}

static inline int isignored_synchronous_busfault_interrupt(void)
{
   return (hSCB->ccr >> HW_BIT(SCB, CCR, BFHFNMIGN_POS)) & 1;
}


#endif
