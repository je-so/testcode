<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Test Resize</title>
   <link rel="stylesheet" href="icons/bootstrap-icons.min.css">
   <style>
      .js-window {
         --border-color: #333;
         background-color: black; color: white;
         border-radius: 12px 12px 0 0; border: 1px var(--border-color) solid;
         box-sizing: border-box;
         display: flex; flex-flow: column nowrap; place-items: stretch;
      }
      .js-window .js-head {
         flex: 0 0 auto;
         box-sizing: border-box;
         border-bottom: 1px var(--border-color) solid;
         display: flex; flex-flow: row nowrap;
         overflow: hidden;
      }
      .js-window .js-body {
         flex: 1 1 auto;
         background-color: lightcoral;
         box-sizing: border-box;
         overflow: hidden; contain: layout;
         display: grid; place-items: stretch;
      }
      .js-window .js-head .js-controls {
         flex: 0 0 auto; align-self: center; order: 2;
         padding: 3px 5px 3px 3px;
      }
      .js-window .js-head .js-title {
         flex: 1 1 auto; align-self: center; order: 1;
         border-radius: 12px 0 0 0; padding: 3px 0px 3px 10px;
         box-sizing: border-box; overflow: hidden; white-space: nowrap;
      }
      .js-controls [data-vm='min'], .js-controls [data-vm='max'], .js-controls [data-vm='close'] {
         margin-left: 0.5em; padding: 2px 3px;
         box-sizing: border-box;
         width: 1em;
         cursor: pointer;
      }
      .js-controls [data-vm='min']:hover, .js-controls [data-vm='max']:hover, .js-controls [data-vm='close']:hover {
         padding-left: 4px; padding-right: 2px;
         background-color: lightslategray;
      }
      .js-controls [data-vm='close']:hover {
         background-color: lightcoral;
      }

      .js-window-stack {
         border: 1px darkgrey solid; background-color: lemonchiffon;
         padding: 3px;
         position: fixed; left: 5px; bottom: 5px;
         display: flex; flex-flow: column-reverse nowrap; place-items: stretch; gap: 5px;
      }
      .js-window-stack .js-window .js-body {
         display: none;
      }
      .js-window-stack .js-window .js-title:hover {
         background-color: lightslategray;
         cursor: pointer;
      }

      .js-window-stack button {
         color:white; background-color:cadetblue;
         border:1px darkgoldenrod solid;
         padding:3px;
      }

      .js-window-stack button:hover {
         color:#fafafa;
         outline:1px darkgoldenrod solid;
         padding:4px 2px 2px 4px;
      }
   </style>
</head>
<body>
   <template id="js-window-template">
      <div class="js-window">
         <div class="js-head" data-vm="minimized-height">
            <div class="js-title" data-vm="window-title"></div>
            <div class="js-controls"><i data-vm="min" class="bi-dash-lg"></i><i data-vm="max" class="bi-square"></i><i data-vm="close" class="bi-x-lg"></i></div>
         </div>
         <div class="js-body" data-vm="window-content"></div>
      </div>
   </template>
   <template id="js-minimized-window-template">
      <div class="js-window">
         <div class="js-head">
            <div class="js-title" data-vm="window-title"></div>
            <div class="js-controls"></i><i data-vm="close" class="bi-x-lg"></i></div>
         </div>
      </div>
   </template>
   <h3>Test Move & Resize Divs</h3>
   <dl>
      <dt>Components</dt>
      <dd>
         <ul>
            <li>View (Encapsulates HTMLElement)</li>
            <li>View-Model (Adds operations/logic to View)</li>
            <li>View-Controller (Event-Listeners-Handling (no logic))</li>
            <li>Decorator (Binds HTMLElement to View,-Model,-Controller)</li>
         </ul>
      </dd>
      <dt>Missing Features</dt>
      <dd>
         <ul>
            <li>Window decorations</li>
            <li>All things Model (i.e. type validation)</li>
         </ul>
      </dd>
   </dl>

   <div id=window style="width:150px;height:150px;background-color:darkblue;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;position:static;">
      Resize div<br>(static)
   </div>

   <div id=window2 style="position:absolute;left:440px;top:160px;width:150px;height:150px;background-color:darkviolet;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;z-index:1;">
      Move or resize div<br>(absolute)
   </div>

   <div id=window3 style="position:fixed;left:300px;top:230px;width:200px;height:150px;background-color:teal;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;z-index:1;">
      Move or resize div<br>(fixed)
   </div>

   <div class="js-window-stack">
      <button>Restore closed window</button>
   </div>

   <div style="height:10px;"></div>
   <div id="LOG"></div>
   <div style="height:1000px;"></div>

   <script>
      const div1 = document.getElementById("window")
      const div2 = document.getElementById("window2")
      const div3 = document.getElementById("window3")
      let logLines = 0
      const logError = (msg) => {
         ++ logLines
         let append = document.getElementById("LOG").innerHTML
         if (logLines > 15) {
            append = append.substring(0,append.lastIndexOf("<br>"))
            if (logLines === 1000)
               logLines=100
         }
         document.getElementById("LOG").innerHTML = logLines + " " + msg + "<br>" + append
      }
      window.addEventListener("error", (e) => {
         if (e.error?.stack)
            e.error.stack.toString().split("\n").reverse().forEach(traceLine => traceLine.trim() && logError("&nbsp; "+traceLine))
         logError(`line ${e.lineno}: ${e.message}`)
      })

      /**
       * Function which decorates the provided HTML element with additional functionality
       * and uses the provided {@link ViewModel} to manage its state.
       * @callback Decorator
       * @param {HTMLElement} htmlElem - The HTML element which is decorated.
       * @param {ViewModel} viewModel - The {@link ViewModel} which manages all view state and updates the view if state changes occur.
       * @return {object} State information about what decorator has changed (useful for unding all changes).
       */

      /**
       * Description of applied decorator to an HTML element.
       * @typedef {object} AppliedDecorator
       * @property {Decorator} decorator - The applied decorator function.
       * @property {object} decoratorState - State information returned by the {@link Decorator} function.
       * @property {HTMLElement} htmlElem - The HTML element which serves as root view.
       * @property {ViewModel} viewModel - The {@link ViewModel} which manages whole view state and is bound to root view or its sub views.
       */

      /** Description fo added listener to an HTML element.
       * @typedef {object} AddedListener
       * @property {HTMLElement} htmlElem - The HTML element which for which the event handler is registered.
       * @property {string} eventType - The event type ("click","touchstart",...).
       * @property {(e:Event)=>void} eventHandler - Registered callback which handles event type for an html element.
       * @property {bigint} ID - Unique number which identifies the added event listener.
       * @property {object|undefined} owner - Owner of the listener (used for blocking).
       * @property {object[]} blockedOwners - An array of owners of listeners which have lower priority and are suppressed if this listener is processed.
       * @property {boolean} TARGET_ONLY - If set to true all other event handlers not registered for this target (capture / bubbling phase) are ignored.
       */

      class Listener {
         /////////////
         // Options //
         /////////////
         static TARGET_ONLY = true
      }

      /**
       * Either an HTMLElement or a CSS selector to query for HTMLElement(s).
       * The name of the variable is abbreviated as elemSel
       */
      class ElemSel {
         #htmlElem
         #elemSel
         #cloning
         constructor(elemSel, {CLONING}={}) {
            if (elemSel instanceof ElemSel) {
               this.#htmlElem = elemSel.#htmlElem
               this.#elemSel = elemSel.#elemSel
               this.#cloning = CLONING ?? elemSel.#cloning
            }
            else {
               this.#htmlElem = ElemSel.htmlElem(elemSel)
               this.#elemSel = elemSel
               this.#cloning = Boolean(CLONING)
            }
         }
         get htmlElem() {
            return this.#cloning
                  ? this.#htmlElem.cloneNode(true)
                  : this.#htmlElem
         }
         get isCloning() {
            return this.#cloning
         }
         get elemSel() {
            return this.#elemSel
         }
         static error() {
            throw Error(`ElemSel error: ${msg}`)
         }
         static htmlElem(elemSel) {
            if (typeof elemSel === "string") {
               const htmlElem = document.querySelector(elemSel)
               if (!htmlElem)
                  this.error(`Found no html node matching '${elemSel}'.`)
               if (htmlElem.localName === "template")
                  return htmlElem.content.children[0]
               return htmlElem
            }
            else if (elemSel instanceof ElemSel)
               return elemSel.htmlElem
            else if (elemSel instanceof ViewModel)
               return elemSel.htmlElem
            else
               return elemSel
         }
         static clone(elemSel) {
            return new ElemSel(elemSel,{CLONING:true}).htmlElem
         }
      }

      /**
       * Manages event listeners and allows to prioritize them.
       * One listener could block one or more other listeners.
       * So if two listeners would be executed, and one is blocked by the other
       * only one is executed. Higher priority of a listener is expresses by
       * blocking the one with lower priority.
       */
      const htmlListeners = {
         htmlElements: new WeakMap(),
         uniqueID: 0n,
         bubbleEvent: null,
         captureEvent: null,
         blockedOwners: null,
         capturedTargets: null,
         capturedListeners: null,
         processedListener: null,
         TARGET_ONLY: false,
         onCaptureBind: null,
         onBubbleBind: null,
         DEBUG: true,
         error(msg) {
            throw Error(`htmlListener error: ${msg}`)
         },
         onCapture(e) {
            if (!this.captureEvent) {
               this.captureEvent = e
               this.bubbleEvent = null
               this.blockedOwners = new Set()
               this.capturedTargets = new WeakSet()
               if (this.DEBUG) {
                  this.capturedListeners = new Set()
                  this.processedListeners = new Set()
               }
               this.TARGET_ONLY = false
            }
            else if (e !== this.captureEvent)
               this.error("Internal: Event loop processes two capture events at same time.")
            if (this.capturedTargets.has(e.currentTarget)) {
               console.warn("Internal: onCapture called with same target more than once.")
            }
            else {
               this.capturedTargets.add(e.currentTarget)
               const listeners = this.get(e.currentTarget,e.type)
               for (const listener of listeners) {
                  for (const owner of listener.blockedOwners) {
                     this.blockedOwners.add(owner)
                  }
                  if (listener.TARGET_ONLY && e.target === e.currentTarget)
                     this.TARGET_ONLY = true
                  if (this.DEBUG)
                     this.capturedListeners.add(listener)
               }
            }
         },
         onBubble(e) {
            if (!this.bubbleEvent) {
               this.bubbleEvent = e
               this.captureEvent = null
               if (this.DEBUG && !this.capturedListeners.size)
                  console.warn("Internal: capture phase found no listener(s).")
            }
            else if (e !== this.bubbleEvent)
               this.error("Internal: Event loop processes two bubble events at same time.")
            if (  this.capturedTargets.has(e.currentTarget)
               && (!this.TARGET_ONLY || e.currentTarget === e.target)) {
               const listeners = this.get(e.currentTarget,e.type)
               for (const listener of listeners) {
                  if (!this.blockedOwners.has(listener.owner)) {
                     listener.eventHandler(e)
                     if (this.DEBUG)
                        this.processedListeners.add(listener)
                  }
               }
            }
            this.capturedTargets.delete(e.currentTarget)
            if (this.DEBUG && !this.capturedTargets.size && !this.processedListeners.size)
               console.warn("Internal: bubble phase processed no listener (all blocked).")
         },
         addListener(htmlElem, eventType, eventHandler, {blockedOwners=[], owner, TARGET_ONLY=false}={}) {
            const eventTypes = this.htmlElements.get(htmlElem) || {}
            const map = eventTypes[eventType] || new Map()
            if (!map.has(eventHandler)) {
               blockedOwners = blockedOwners.filter(o => o != null)
               const listener = { htmlElem, eventType, eventHandler, ID: ++this.uniqueID, owner, blockedOwners, TARGET_ONLY }
               if (map.size === 0) {
                  this.onCaptureBind ??= this.onCapture.bind(this)
                  this.onBubbleBind ??= this.onBubble.bind(this)
                  listener.htmlElem.addEventListener(listener.eventType,this.onCaptureBind,{capture:true,passive:false})
                  listener.htmlElem.addEventListener(listener.eventType,this.onBubbleBind,{capture:false,passive:false})
                  if (!this.htmlElements.has(htmlElem))
                     this.htmlElements.set(htmlElem,eventTypes)
                  eventTypes[eventType] = map
               }
               map.set(eventHandler,listener)
               return listener
            }
         },
         removeListener(listener) {
            const eventTypes = this.htmlElements.get(listener.htmlElem)
            const map = eventTypes && eventTypes[listener.eventType]
            if (map && map.size > 0) {
               map.delete(listener.eventHandler)
               if (map.size === 0) {
                  listener.htmlElem.removeEventListener(listener.eventType,this.onCaptureBind,{capture:true,passive:false})
                  listener.htmlElem.removeEventListener(listener.eventType,this.onBubbleBind,{capture:false,passive:false})
               }
            }
         },
         /**
          * Returns iterator of all matching listeners.
          * @param {HTMLElement} htmlElem The HTML element whose listeners are queried.
          * @param {string=} eventType Optional type of the event the listener must match else listeners with any event type are matched.
          * @param {(e:Event)=>void} eventHandler Optional event handler function the listener must match else all listeners with any event handler are matched.
          */
         get(htmlElem, eventType, eventHandler) {
            const eventTypes = this.htmlElements.get(htmlElem)
            if (!eventTypes)
               return [].values()
            if (eventType)
               if (eventHandler)
                  return eventTypes[eventType] && eventTypes[eventType].get(eventHandler)
                     ? [eventTypes[eventType].get(eventHandler)].values()
                     : [].values()
               else
                  return (eventTypes[eventType] || []).values()
            return (function*() {
               for (const key in eventTypes) {
                  const map = eventTypes[key]
                  if (map) {
                     if (!eventHandler)
                        yield* map.values()
                     const listener = map.get(eventHandler)
                     if (listener)
                        yield listener
                  }
               }
            })()
         },
         isListener(htmlElem, eventType, eventHandler) {
            return !this.get(htmlElem,eventType,eventHandler).next().done
         },
         getListenedElements(rootElem, eventType, eventHandler) {
            const result = []
            if (this.isListener(rootElem,eventType,eventHandler))
               result.push(rootElem)
            for (const htmlElem of rootElem.querySelectorAll("*")) {
               if (this.isListener(htmlElem,eventType,eventHandler))
                  result.push(htmlElem)
            }
            return result
         },
      }
      function addListener(htmlElem, eventType, eventHandler, options) {
         return htmlListeners.addListener(htmlElem, eventType, eventHandler, options)
      }
      function removeListeners(listenerArray) {
         listenerArray.forEach( listener => listener && htmlListeners.removeListener(listener))
      }

      /**
       * Maps an HTML element to array of applied decorators.
       */
      const htmlDecorators = {
         htmlElements: new WeakMap(),
         error(msg) {
            throw Error(`htmlDecorators error: ${msg}`)
         },
         /**
          * Applies decorator by calling it and adds it to list of applied docorators for htmlElem.
          * @param {HTMLElement|ViewModel|ElemSel|string} elemSel
          * @param {Decorator} decorator
          * @param {ViewModel} viewModel
          */
         decorate(elemSel, decorator, options) {
            const viewModel = elemSel instanceof ViewModel ? elemSel : undefined
            const htmlElem = ElemSel.htmlElem(elemSel)
            if (!(htmlElem instanceof HTMLElement)) this.error("elemSel references no HTMLElement.")
            if (!(decorator instanceof Function)) this.error("decorator argument expects type Function.")
            if (!this.isDecorated(htmlElem, decorator)) {
               const decoratorState = decorator(htmlElem, viewModel, options)
               const newDecorator = { decorator, decoratorState, htmlElem, viewModel:decoratorState.viewModel }
               this.htmlElements.set(htmlElem,
                  (this.htmlElements.get(htmlElem) || []).concat(newDecorator)
               )
               return newDecorator
            }
         },
         /**
          * Returns information about decorators applied to an HTML element.
          * @param {HTMLElement} htmlElem Element whose decorators are to be returned.
          * @param {Decorator=} decorator Optional decorator to return information about a single decorator. If undefined an array of all decorators applied to the element is returned.
          * @return {AppliedDecorator[]} An array describing all applied decorators. The returned array may be empty.
          */
         get(htmlElem, decorator) {
            const decorators = this.htmlElements.get(htmlElem) || []
            return decorator
               ? decorators.filter( entry => entry.decorator === decorator )
               : decorators
         },
         /**
          * Checks if an element is decorated at all or decorated by a specific decorator.
          * @param {HTMLElement} htmlElem Element which checked for being decorated.
          * @param {Decorator=} decorator Optional decorator to check for. If undefined any dorator is considered.
          * @return {boolean} <tt>true</tt> if the element is decorated with provided decorator or decorated at all in case decorator is undefined.
          */
         isDecorated(htmlElem, decorator) {
            return this.get(htmlElem, decorator).length > 0
         },
         /**
          * Returns view model of a single decorator.
          * @param {HTMLElement} htmlElem Element which checked for being decorated.
          * @param {Decorator} decorator Decorator whose state should be returned. Value is not optional.
          * @return {object|undefined} Returned state of applied decorator or undefined if decorator was not applied to given element.
          */
         getDecoratorState(htmlElem, decorator) {
            return this.get(htmlElem, decorator)[0]?.decoratorState
         },
         /**
          * Returns view model of a single decorator.
          * @param {HTMLElement} htmlElem Element which checked for being decorated.
          * @param {Decorator} decorator Decorator whose view model should be returned. Value is not optional.
          * @return {ViewModel|undefined} ViewModel of applied decorator or undefined if decorator was not applied to given element.
          */
         getDecoratorViewModel(htmlElem, decorator) {
            return this.get(htmlElem, decorator)[0]?.viewModel
         },
         getDecoratedElements(rootElem, decorator) {
            const result = []
            if (this.isDecorated(rootElem, decorator))
               result.push(rootElem)
            for (const htmlElem of rootElem.querySelectorAll("*")) {
               if (this.isDecorated(htmlElem, decorator))
                  result.push(htmlElem)
            }
            return result
         },
      }
      function decorateElement(elemSel, decorator, options) {
         return htmlDecorators.decorate(elemSel, decorator, options)
      }
      const UIupdates = {
         callbacks: [],
         frameID: null,
         oldTimestamp: null,
         milliseconds: 0,
         loop(timestamp) {
            const callbacks = this.callbacks
            const oldTimestamp = this.oldTimestamp || timestamp
            this.callbacks = []
            this.frameID = null
            this.oldTimestamp = timestamp
            this.milliseconds += timestamp-oldTimestamp
            for (const callback of callbacks)
               callback(this.milliseconds)
         },
         add(callback) {
            this.callbacks.push(callback)
            if (this.frameID == null)
               this.frameID = requestAnimationFrame(this.loop.bind(this))
         }
      }
      function asyncUIUpdate(callback) {
         UIupdates.add(callback)
      }

      // implement controller blocking other controller
      class ViewController {
         #isActive=false
         #listeners=[]
         #activeListeners=[]
         #blockedControllers=[]
         #blockingCount = 0
         #othersBlocked = false
         #htmlElem
         #callback
         constructor() {
         }
         get htmlElem() {
            return this.#htmlElem
         }
         get callback() {
            return this.#callback
         }
         get isActive() {
            return this.#isActive
         }
         get isBlocked() {
            return Boolean(this.#blockingCount)
         }
         callAction(e) {
            if (!this.isBlocked && this.#callback)
               this.#callback(e)
         }
         removeListeners(listenersArray) {
            removeListeners(listenersArray)
            listenersArray.length = 0
         }
         blockOthers(switchOn) {
            if (this.#othersBlocked !== Boolean(switchOn)) {
               this.#othersBlocked = Boolean(switchOn)
               if (this.#othersBlocked) {
                  for (const contr of this.#blockedControllers)
                     if ((++contr.#blockingCount) == 1)
                        contr.onBlock()
               }
               else {
                  for (const contr of this.#blockedControllers)
                     if ((--contr.#blockingCount) == 0)
                        contr.onUnblock()
               }
            }
         }
         deactivate() {
            if (this.#isActive) {
               this.#isActive = false
               this.removeListeners(this.#activeListeners)
               this.blockOthers(false)
            }
         }
         activate(onActivateCallback) {
            if (!this.#isActive) {
               this.#isActive = true
               this.blockOthers(true)
               onActivateCallback?.()
            }
         }
         #addListener(htmlElem, eventType, eventHandler, options) {
            return addListener(htmlElem, eventType, eventHandler,
               { ...options, owner: this, blockedOwners: this.#blockedControllers }
            )
         }
         addListener(htmlElem, eventType, eventHandler, options) {
            this.#listeners.push(this.#addListener(htmlElem,eventType,eventHandler,options))
            return this.#listeners.at(-1)
         }
         addActiveListener(htmlElem, eventType, eventHandler, options) {
            this.#activeListeners.push(this.#addListener(htmlElem,eventType,eventHandler,options))
            return this.#activeListeners.at(-1)
         }
         /////////////////////////////
         // overwritten in subclass //
         /////////////////////////////
         add(htmlElem, callback, ...blockedControllers) {
            this.remove()
            this.#htmlElem = htmlElem
            this.#callback = callback
            this.#blockedControllers = blockedControllers.flat(Infinity).filter(cntrl => cntrl instanceof ViewController)
            return this
         }
         remove() {
            this.deactivate()
            this.removeListeners(this.#listeners)
            this.#htmlElem = null
            this.#callback = null
            this.#blockedControllers = []
            return this
         }
         onBlock() {
            // do nothing
         }
         onUnblock() {
            // do nothing
         }
         ////////////
         // Helper //
         ////////////
         getTouchById(touches, id) {
            for (const t of (touches||[]))
               if (t.identifier === id)
                  return t
         }
      }

      class ClickController extends ViewController {
         constructor(htmlElem, clickCallback, ...blockedControllers) {
            super()
            return this.add(htmlElem, clickCallback, ...blockedControllers)
         }

         add(htmlElem, clickCallback, ...blockedControllers) {
            super.add(htmlElem, clickCallback, ...blockedControllers)
            this.addListener(htmlElem,"click",this.onClick.bind(this))
            this.addListener(htmlElem,"touchstart",this.onStart.bind(this))
            return this
         }

         onStart(e) {
            logError(`ClickController activate`)
            this.activate( () => [
               this.addActiveListener(e.target,"touchend",this.onEnd.bind(this)),
               this.addActiveListener(e.target,"touchcancel",this.onEnd.bind(this))
            ])
         }

         onClick(e) {
            logError(`ClickController click active:${this.isActive}`)
            this.callAction({controller:this, target:e.target})
         }

         onEnd(e) {
            if (e?.targetTouches?.length !== 0)
               return
            logError(`ClickController deactivate`)
            this.deactivate()
         }
      }

      class MoveController extends ViewController {
         #pos
         #totalxy
         #truncxy

         debug = false

         constructor(htmlElem, moveCallback, ...blockedControllers) {
            super()
            return this.add(htmlElem, moveCallback, ...blockedControllers)
         }

         add(htmlElem, moveCallback, ...blockedControllers) {
            super.add(htmlElem, moveCallback, ...blockedControllers)
            this.addListener(htmlElem,"mousedown",this.onStart.bind(this))
            this.addListener(htmlElem,"touchstart",this.onStart.bind(this))
            return this
         }

         extractXY(e) {
            return { x:e.pageX, y:e.pageY, id:e.identifier }
         }

         onStart(e) {
            if (this.debug && e.touches)
               logError(`${this.debug}: start ${e.targetTouches.length} active:${this.isActive} block:${this.isBlocked}`)
            if (this.isActive || (e.touches && e.targetTouches.length !== 1)) {
               return
            }
            const touch = (e.targetTouches && e.targetTouches[0])
            this.#pos = this.extractXY(touch || e)
            this.#totalxy = { x:0, y:0 }
            this.#truncxy = { x:0, y:0 }
            e.preventDefault()
            this.activate( () => touch
                  ?  [  this.addActiveListener(e.target,"touchmove",this.onMove.bind(this)),
                        this.addActiveListener(e.target,"touchend",this.onEnd.bind(this)),
                        this.addActiveListener(e.target,"touchcancel",this.onEnd.bind(this)) ]
                  :  [  this.addActiveListener(document,"mousemove",this.onMove.bind(this)),
                        this.addActiveListener(document,"mouseup",this.onEnd.bind(this)) ])
         }

         onMove(e) {
            if (e.touches && e.targetTouches.length !== 1)
               return
            e.preventDefault()
            const touch = e.targetTouches && e.targetTouches[0]
            const pos = this.extractXY(touch || e)
            const totalxy = { x:pos.x-this.#pos.x+this.#totalxy.x, y:pos.y-this.#pos.y+this.#totalxy.y }
            const truncxy = { x:Math.trunc(totalxy.x), y:Math.trunc(totalxy.y) }
            const movexy = { dx:truncxy.x-this.#truncxy.x, dy:truncxy.y-this.#truncxy.y }
            this.#pos = pos
            this.#totalxy = totalxy
            if (movexy.dx || movexy.dy) {
               this.#truncxy = truncxy
               this.callAction(movexy)
            }
         }

         onEnd(e) {
            if (e?.targetTouches?.length > 0) {
               this.#pos = this.extractXY(e.targetTouches[0])
               return
            }
            this.deactivate()
         }
      }

      class TouchResizeController extends ViewController {
         #pos
         #totalxy
         #truncxy

         constructor(htmlElem, moveCallback, ...blockedControllers) {
            super()
            return this.add(htmlElem, moveCallback, ...blockedControllers)
         }

         add(htmlElem, resizeCallback, ...blockedControllers) {
            super.add(htmlElem, resizeCallback, ...blockedControllers)
            this.addListener(htmlElem,"touchstart",this.onStart.bind(this))
            return this
         }

         extractXY(e1,e2) {
            return { x:Math.abs(e1.pageX - e2.pageX), y:Math.abs(e1.pageY - e2.pageY) }
         }

         onStart(e) {
            if (this.isActive || e.targetTouches?.length !== 2) {
               return
            }
            this.#pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
            this.#totalxy = { x:0, y:0 }
            this.#truncxy = { x:0, y:0 }
            e.preventDefault()
            this.activate( () =>
               [  this.addActiveListener(e.target,"touchmove",this.onMove.bind(this)),
                  this.addActiveListener(e.target,"touchend",this.onEnd.bind(this)),
                  this.addActiveListener(e.target,"touchcancel",this.onEnd.bind(this)) ])
         }

         onMove(e) {
            if (e.targetTouches.length !== 2)
               return
            e.preventDefault()
            const pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
            const totalxy = { x:pos.x-this.#pos.x+this.#totalxy.x, y:pos.y-this.#pos.y+this.#totalxy.y }
            const truncxy = { x:Math.trunc(totalxy.x), y:Math.trunc(totalxy.y) }
            const resizexy = { dx:truncxy.x-this.#truncxy.x, dy:truncxy.y-this.#truncxy.y }
            this.#pos = pos
            this.#totalxy = totalxy
            if (resizexy.dx || resizexy.dy) {
               this.#truncxy = truncxy
               this.callAction(resizexy)
            }
         }

         onEnd(e) {
            if (e?.targetTouches?.length >= 2) {
               this.#pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
               return
            }
            this.deactivate()
         }
      }

      function newDiv(styles){
         const newDiv = document.createElement("div")
         View.setStyles(newDiv,styles)
         return newDiv
      }

      function ResizeDecorator(htmlElem, viewModel=new ResizeVM(htmlElem)) {
         const isMoveable = viewModel.isMoveable()
         const display = isMoveable ? "" : "none"
         const outerWidth = 8
         const innerWidth = 4
         const borderSize = (outerWidth+innerWidth)+"px"
         const outerSize = "-"+outerWidth+"px"
         const edgeSize = (outerWidth+3*innerWidth)+"px"
         const borders = [
            newDiv({top:outerSize, left:0, right:0, height:borderSize, cursor:"n-resize", position:"absolute", "z-index":1, display}),
            newDiv({right:outerSize, top:0, bottom:0, width:borderSize, cursor:"e-resize", position:"absolute", "z-index":1}),
            newDiv({bottom:outerSize, left:0, right:0, height:borderSize, cursor:"s-resize", position:"absolute", "z-index":1}),
            newDiv({left:outerSize, top:0, bottom:0, width:borderSize, cursor:"w-resize", position:"absolute", "z-index":1, display}),
            newDiv({top:outerSize, left:outerSize, width:edgeSize, height:edgeSize, cursor:"nw-resize", position:"absolute", "z-index":1, display}),
            newDiv({top:outerSize, right:outerSize, width:edgeSize, height:edgeSize, cursor:"ne-resize", position:"absolute", "z-index":1, display}),
            newDiv({bottom:outerSize, right:outerSize, width:edgeSize, height:edgeSize, cursor:"se-resize", position:"absolute", "z-index":1}),
            newDiv({bottom:outerSize, left:outerSize, width:edgeSize, height:edgeSize, cursor:"sw-resize", position:"absolute", "z-index":1, display}),
         ]
         htmlElem.append(...borders)
         const controllers = {}
         if (isMoveable) {
            const moveWin = (View.setStyles(htmlElem,{cursor: "move"}), new MoveController(htmlElem,viewModel.on.Move))
            moveWin.debug = "movewin"
            const resizeWin = new TouchResizeController(htmlElem,viewModel.on.Resize)
            resizeWin.debug = "resizewin"
            const moveResizeGroup = [moveWin,resizeWin]
            const topResize = new MoveController(borders[0],viewModel.on.ResizeTop,moveResizeGroup)
            const rightResize = new MoveController(borders[1],viewModel.on.ResizeRight,moveResizeGroup)
            const bottomResize = new MoveController(borders[2],viewModel.on.ResizeBottom,moveResizeGroup)
            const leftResize = new MoveController(borders[3],viewModel.on.ResizeLeft,moveResizeGroup)
            const topLeftResize = new MoveController(borders[4],viewModel.on.ResizeTopLeft,moveResizeGroup,topResize,leftResize)
            const topRightResize = new MoveController(borders[5],viewModel.on.ResizeTopRight,moveResizeGroup,topResize,rightResize)
            const bottomRightResize = new MoveController(borders[6],viewModel.on.ResizeBottomRight,moveResizeGroup,bottomResize,rightResize)
            const bottomLeftResize = new MoveController(borders[7],viewModel.on.ResizeBottomLeft,moveResizeGroup,bottomResize,leftResize)
            Object.assign(controllers, { moveWin, resizeWin, topResize, rightResize, bottomResize, leftResize, topLeftResize, topRightResize, bottomRightResize, bottomLeftResize })
         }
         else {
            const resizeWin = new TouchResizeController(htmlElem,viewModel.on.ResizeStatic)
            const rightResize = new MoveController(borders[1],viewModel.on.ResizeRight, resizeWin)
            const bottomResize = new MoveController(borders[2],viewModel.on.ResizeBottom, resizeWin)
            const bottomRightResize = new MoveController(borders[6],viewModel.on.ResizeBottomRight,bottomResize,rightResize)
            Object.assign(controllers, { resizeWin, rightResize, bottomResize, bottomRightResize })
         }
         View.setStyles(htmlElem,{ contain: "layout" })

         return { viewModel, borders, controllers }
      }

      class HTMLView {
         static needsBorderBox(htmlElem) {
            const needValue = "border-box"
            const styleProp = "box-sizing"
            const value = getComputedStyle(htmlElem)[styleProp]
            if (value != needValue) {
               console.warn(`${this.constructor.name} needs style['${styleProp}']=='${needValue}' instead of '${value}' to work properly on html element`, htmlElem)
               htmlElem.style.setProperty(styleProp,needValue)
            }
         }
         static isEmptyTextNode(htmlElem) {
            return htmlElem && htmlElem.nodeType === 3/*Node.TEXT_NODE*/ && htmlElem.textContent.trim() === ""
         }
         static isDocumentFragment(htmlElem) {
            return htmlElem && htmlElem.nodeType === 11/*Node.DOCUMENT_FRAGMENT_NODE*/
         }
         static getComputedStyles(htmlElem, styles) {
            const computedStyle = getComputedStyle(htmlElem)
            const computedValues = {}
            for (const key in styles)
               computedValues[key] = computedStyle[key]
            return computedValues
         }
         static getStyles(htmlElem, styles) {
            const elemStyle = htmlElem.style
            const styleValues = {}
            if (Array.isArray(styles)) {
               for (const key of styles)
                  styleValues[key] = elemStyle.getPropertyValue(key)
            }
            else {
               for (const key in styles)
                  styleValues[key] = elemStyle.getPropertyValue(key)
            }
            return styleValues
         }
         static setStyles(htmlElem, styles) {
            const elemStyle = htmlElem.style
            const oldValues = { }
            for (const key in styles) {
               oldValues[key] = elemStyle.getPropertyValue(key)
               elemStyle.setProperty(key, styles[key])
            }
            return oldValues
         }
         static restoreStyles(htmlElem, oldValues) {
            const elemStyle = htmlElem.style
            for (const key in oldValues)
               elemStyle.setProperty(key, oldValues[key])
         }
         static getSlots(htmlElem) {
            const slots = new Map()
            const nodes = [...htmlElem.querySelectorAll("[data-vm]")]
            nodes.forEach(node => {
               const name = node.dataset.vm
               const views = slots.get(name) ?? []
               views.push(node)
               slots.set(name, views)
            })
            return slots
         }
      }

      class View extends HTMLView {
         #htmlElem
         constructor(htmlElem) {
            super()
            this.#htmlElem = htmlElem
         }
         error(msg) {
            throw Error(`View error: ${msg}`)
         }
         get htmlElem() {
            return this.#htmlElem
         }
         get html() {
            return this.#htmlElem.innerHTML
         }
         set html(htmlString) {
            this.#htmlElem.innerHTML = htmlString
         }
         append(node) {
            this.#htmlElem.append(node)
            return this
         }
         get node() {
            return this.#htmlElem.childNodes[0]
         }
         set node(node) {
            const elem = this.#htmlElem
            while (elem.childNodes.length)
               elem.childNodes[0].remove()
            elem.append(node)
         }
         getComputedStyles(styles) {
            return HTMLView.getComputedStyles(this.htmlElem, styles)
         }
         getStyles(styles) {
            return HTMLView.getStyles(this.htmlElem, styles)
         }
         setStyles(styles) {
            return HTMLView.setStyles(this.htmlElem, styles)
         }
      }

      class ViewSlots {
         #slots
         constructor(htmlElem,...assertedSlotNames) {
            this.#slots = new Map()
            HTMLView.getSlots(htmlElem).forEach( (slotElemArray, slotName) => {
               this.#slots.set( slotName, slotElemArray.map( slotElem => new View(slotElem)))
            })
            this.assertSlotNames(assertedSlotNames, htmlElem)
         }
         error(msg) {
            throw Error(`ViewSlots error: ${msg}`)
         }
         getSlot(name) {
            this.assertSlotName(name)
            return this.#slots.get(name)[0]
         }
         getSlots(name) {
            this.assertSlotName(name)
            return this.#slots.get(name)
         }
         getSlotNames() {
            return [...this.#slots.keys()]
         }
         assertSlotName(name, htmlElem) {
            if (!this.#slots.has(name)) {
               if (htmlElem)
                  console.log("HTML",htmlElem,htmlElem.innerHTML)
               this.error(`Missing data-vm='${name}' in HTML.`)
            }
         }
         assertSlotNames(slotNamesArray, htmlElem) {
            for (const name of slotNamesArray) {
               if (!this.#slots.has(name)) {
                  if (htmlElem)
                     console.log("HTML",htmlElem,htmlElem.innerHTML)
                  this.error(`Missing data-vm='${name}' in HTML.`)
               }
            }
         }
      }

      class ViewCoordinates {

         /**
          * Returns { top, left, width, height } in
          * viewport (window) coordinates of htmlElem (top,left are relative coordinates to viewport).
          * The coordinate denoting top left of the viewport is (0,0).
          * The calculation includes padding and border size of htmlElem.
          * The calculation does not take any transformations into account,
          * use getBoundingClientRect in this case.
          */
         static windowRect(htmlElem) {
            if (! (htmlElem instanceof HTMLElement))
               throw Error(`ViewCoordinates: Unsupported argument type '${htmlElem?.constructor?.name || (htmlElem === null ? 'null' : typeof htmlElem)}'.`)
            let top = 0, left = 0, elem = htmlElem;
            do {
               const offsetParent = elem.offsetParent
               top += elem.offsetTop
               left += elem.offsetLeft
               if (offsetParent === document.body) {
                  if ("fixed" !== getComputedStyle(htmlElem)["position"]) {
                     top -= document.scrollingElement.scrollTop
                     left -= document.scrollingElement.scrollLeft
                  }
               }
               else if (offsetParent) {
                  top -= offsetParent.scrollTop
                  left -= offsetParent.scrollLeft
               }
               elem = offsetParent
            } while (elem)
            return { top, left, width:htmlElem.offsetWidth, height:htmlElem.offsetHeight }
         }

         static documentRect(htmlElem) {
            if (! (htmlElem instanceof HTMLElement))
               throw Error(`ViewCoordinates: Unsupported argument type '${htmlElem?.constructor?.name || (htmlElem === null ? 'null' : typeof htmlElem)}'.`)
            let top = 0, left = 0, elem = htmlElem;
            do {
               const offsetParent = elem.offsetParent
               top += elem.offsetTop
               left += elem.offsetLeft
               if (offsetParent === document.body) {
                  if ("fixed" === getComputedStyle(htmlElem)["position"]) {
                     top += document.scrollingElement.scrollTop
                     left += document.scrollingElement.scrollLeft
                  }
               }
               elem = offsetParent
            } while (elem)
            return { top, left, width:htmlElem.offsetWidth, height:htmlElem.offsetHeight }
         }

      }

      /**
       * Model which is bound to a single view and manages its state.
       */
      class ViewModel {
         static #validObserverNames = new Set(["hidden"])
         #modelName
         #htmlElem
         #on = {}
         #view
         constructor(htmlElem, modelName) {
            this.#htmlElem = htmlElem
            this.#modelName = modelName
            this.#view = new View(htmlElem)
            this.connected = true
         }
         static get validObserverNames() { return ViewModel.#validObserverNames }
         /**
          * Returns valid names of prperties which could be observed for change.
          * Should be overwritten in subclass if new properties should be supported.
          */
         get validObserverNames() { return ViewModel.#validObserverNames }
         error(msg) {
            throw Error(`${this.#modelName}-View-Model error: ${msg}`)
         }
         get name() {
            return this.#modelName
         }
         get htmlElem() {
            return this.#htmlElem
         }
         get view() {
            return this.#view
         }
         isEventHandler(name) {
            return (name in this.#on)
         }
         get on() {
            return this.#on
         }
         getEventHandler(name) {
            return this.on[name]
         }
         bindEventHandler(name, eventHandler, thisValue=null) {
            this.#on[name] = eventHandler.bind(thisValue||this)
         }
         bindEventHandlers(prototype) {
            const overwritten = []
            for (const key of Reflect.ownKeys(prototype))
               if (String(key).startsWith("on")) {
                  const name = key.substring(2)
                  if (this.isEventHandler(name))
                     overwritten.push(key)
                  this.bindEventHandler(name,prototype[key])
               }
            return overwritten
         }
         detach() {
            const htmlElem = this.htmlElem
            this.#htmlElem = null
            this.#on = {}
            this.#view = null
            return htmlElem
         }
         get connectedTo() {
            // !htmlElem.isConnected ==> parent == nextSibling == null
            const htmlElem = this.htmlElem
            return { parent: htmlElem.parentNode, nextSibling: htmlElem.nextSibling }
         }
         set connectedTo(connectTo) {
            const htmlElem = this.htmlElem
            const isConnected = htmlElem.isConnected
            if (!connectTo?.parent)
               htmlElem.remove()
            else if (htmlElem.parentNode !== connectTo.parent || htmlElem.nextSibling !== connectTo.nextSibling)
               connectTo.parent.insertBefore(htmlElem, connectTo.nextSibling ?? null )
            if (isConnected != htmlElem.isConnected)
               this._update_connected?.(this,htmlElem.isConnected)
         }
         get connected() {
            return this.htmlElem.isConnected
         }
         set connected(isConnect) {
            const htmlElem = this.htmlElem
            if (isConnect && !htmlElem.isConnected) {
               document.body.append(htmlElem)
               this._update_connected?.(this,true)
            }
            else if (!isConnect && htmlElem.isConnected) {
               htmlElem.remove()
               this._update_connected?.(this,true)
            }
         }
         get hidden() {
            return getComputedStyle(this.htmlElem).display === "none"
         }
         set hidden(isHidden) {
            const style = this.htmlElem.style
            if (isHidden === false && style.display === "none") {
               style.display = style["--display"] ?? ""
               style["--display"] = undefined
               this._update_hidden?.(this,false)
            }
            else if (isHidden === true && style.display !== "none") {
               style["--display"] = style.display
               style.display = "none"
               this._update_hidden?.(this,true)
            }
         }
         get visibility() {
            return getComputedStyle(this.htmlElem).visibility === "visible"
         }
         set visibility(isVisible) {
            if (isVisible === true)
               this.htmlElem.style.visibility = ""
            else if (isVisible === false)
               this.htmlElem.style.visibility = "hidden"
         }
         assertObserverName(name) {
            if (!this.validObserverNames.has(name))
               this.error(`Observer with name '${name}' does not exist.`)
         }
         getUpdateObserver(name) { this.assertObserverName(name); return this["_update_"+name] }
         setUpdateObserver(name,callback) { this.assertObserverName(name); this["_update_"+name] = callback }
         deleteUpdateObserver(name) { this.assertObserverName(name); delete this["_update_"+name] }
      }

      class ResizeVM extends ViewModel {
         constructor(htmlElem, modelName) {
            super(htmlElem, modelName || "Resize")
            super.bindEventHandlers(ResizeVM.prototype)
            View.needsBorderBox(htmlElem)
         }

         set vHeight(value/*number value in pixels*/) {
            if (value < 0)
               value = 0
            this.htmlElem.style.height = value+"px"
         }
         get vHeight() {
            return this.htmlElem.offsetHeight // in pixel (could be a fraction)
         }
         set vWidth(value/*number value in pixels*/) {
            if (value < 0)
               value = 0
            this.htmlElem.style.width = value+"px"
         }
         get vWidth() {
            return this.htmlElem.offsetWidth // in pixel (could be a fraction)
         }
         set vTop(value/*number value in pixels*/) {
            this.htmlElem.style.top = value+"px"
         }
         get vTop() {
            return this.htmlElem.offsetTop // in pixel (could be a fraction)
         }
         set vLeft(value/*number value in pixels*/) {
            this.htmlElem.style.left = value+"px"
         }
         get vLeft() {
            return this.htmlElem.offsetLeft
         }

         isMoveable(position) { return ["fixed","absolute"].includes(position ?? getComputedStyle(this.htmlElem)["position"]) }

         move(deltax,deltay) { this.vLeft += deltax; this.vTop += deltay; }
         resizeTop(deltay) { this.vTop -= deltay; this.vHeight += deltay; }
         resizeRight(deltax) { this.vWidth += deltax; }
         resizeBottom(deltay) { this.vHeight += deltay; }
         resizeLeft(deltax) { this.vLeft -= deltax; this.vWidth += deltax; }
         resizeTopLeft(deltax,deltay) { this.resizeLeft(deltax); this.resizeTop(deltay); }
         resizeTopRight(deltax,deltay) { this.resizeRight(deltax); this.resizeTop(deltay); }
         resizeBottomRight(deltax,deltay) { this.resizeRight(deltax); this.resizeBottom(deltay); }
         resizeBottomLeft(deltax,deltay) { this.resizeLeft(deltax); this.resizeBottom(deltay); }
         resize(deltax,deltay) { this.resizeRight(deltax); this.resizeBottom(deltay); this.resizeLeft(deltax); this.resizeTop(deltay); }
         resizeStatic(deltax,deltay) { this.resizeRight(2*deltax); this.resizeBottom(2*deltay); }

         // event handlers are prefixed with "on"

         onMove(e) { this.move(e.dx,e.dy) }
         onResizeTop(e) { this.resizeTop(-e.dy) }
         onResizeRight(e) { this.resizeRight(e.dx) }
         onResizeBottom(e) { this.resizeBottom(e.dy) }
         onResizeLeft(e) { this.resizeLeft(-e.dx) }
         onResizeTopLeft(e) { this.resizeLeft(-e.dx); this.resizeTop(-e.dy); }
         onResizeTopRight(e) { this.resizeRight(e.dx); this.resizeTop(-e.dy); }
         onResizeBottomRight(e) { this.resizeRight(e.dx); this.resizeBottom(e.dy); }
         onResizeBottomLeft(e) { this.resizeLeft(-e.dx); this.resizeBottom(e.dy); }
         onResize(e) { this.resize(e.dx,e.dy) }
         onResizeStatic(e) { this.resizeStatic(e.dx,e.dy) }
      }

      class TransitionController extends ViewController {
         constructor(htmlElem, callback, ...blockedControllers) {
            super()
            this.add(htmlElem, callback, ...blockedControllers)
         }

         add(htmlElem, endCallback, ...blockedControllers) {
            super.add(htmlElem, endCallback, ...blockedControllers)
            const onEnd = this.onTransitionEnd.bind(this)
            super.addListener(htmlElem, "transitionend", onEnd)
            super.addListener(htmlElem, "transitioncancel", onEnd)
            return this
         }

         isInTransition() {
            if (this.htmlElem) {
               const animations = this.htmlElem.getAnimations()
               return animations.some( anim => anim instanceof CSSTransition)
            }
            return false
         }

         setTimeout(milliseconds) {
            const htmlElem = this.htmlElem
            if (htmlElem) {
               setTimeout( () =>
                  asyncUIUpdate( () => {
                     if (this.htmlElem === htmlElem) {
                        htmlElem.dispatchEvent(new Event("transitioncancel"))
                     }
                  })
               , milliseconds)
            }
         }

         onTransitionEnd(e) {
            super.callAction()
            this.remove()
         }
      }

      function WindowDecorator(htmlElem, viewModel, {template, title}={}) {
         const cstyle = getComputedStyle(htmlElem)
         const position = cstyle["position"]
         if (viewModel === undefined) {
            const windowHtmlElem = template ?? ElemSel.clone("#js-window-template")
            const height = htmlElem.offsetHeight || 100
            const width = htmlElem.offsetWidth || 100
            const top = ({ static:0, relative:parseFloat(cstyle.top)})[position] ?? htmlElem.offsetTop
            const left = ({ static:0, relative:parseFloat(cstyle.left)})[position] ?? htmlElem.offsetLeft
            htmlElem.parentElement.replaceChild(windowHtmlElem, htmlElem)
            viewModel = new WindowVM(windowHtmlElem)
            viewModel.vTop = top
            viewModel.vLeft = left
            viewModel.vWidth = width
            viewModel.vHeight = height
         }
         viewModel.vTitle = title
         viewModel.vContent = htmlElem
         View.setStyles(htmlElem, { width:"100%", height:"100%", position:"static" })
         View.setStyles(viewModel.htmlElem, { position: position === "static" ? "relative" : position })
         const resizeState = decorateElement(viewModel, ResizeDecorator).decoratorState
         const moveWin = resizeState.controllers.moveWin
         const controllers = {
            close: new ClickController(viewModel.getSlot("close").htmlElem, () => {
               viewModel.vWindowState = WindowVM.CLOSED
            },moveWin),
            min: new ClickController(viewModel.getSlot("min").htmlElem, () => {
               viewModel.vWindowState = WindowVM.MINIMIZED
            },moveWin),
            max: new ClickController(viewModel.getSlot("max").htmlElem, () => {
               viewModel.vWindowState = (viewModel.vWindowState === WindowVM.MAXIMIZED)
                                 ? WindowVM.VISIBLE
                                 : WindowVM.MAXIMIZED
            },moveWin)
         }
         return { viewModel, controllers, resizeState }
      }

      class WindowVM extends ResizeVM {
         static #validObserverNames = new Set([...ResizeVM.validObserverNames,"vWindowState"])
         #windowState
         #visibleState={}
         #slots

         // window state
         static HIDDEN = "hidden"; static VISIBLE = "visible"; static MINIMIZED = "minimized"; static MAXIMIZED = "maximized"; static CLOSED = "closed";
         // transition style for animation
         static TRANSITION_STYLE = { "transition-delay":"0s", "transition-duration":"0.2s", "transition-property":"width,height,left,top", "transition-timing-function":"ease-out" }

         constructor(htmlElem, modelName) {
            super(htmlElem, modelName || "Window")
            super.bindEventHandlers(WindowVM.prototype)
            this.#slots = new ViewSlots(htmlElem, "window-content","window-title","close","min","max")
            this.#windowState = this.hidden ? WindowVM.HIDDEN : WindowVM.VISIBLE
         }

         static get validObserverNames() { return WindowVM.#validObserverNames }
         get validObserverNames() { return WindowVM.#validObserverNames }

         getSlot(name) {
            return this.#slots.getSlot(name)
         }

         minimizedHeight() {
            const titleBarHeight = 2*parseFloat(getComputedStyle(this.htmlElem)["border-top"])
                  +this.getSlot("minimized-height").htmlElem.offsetHeight
            return isNaN(titleBarHeight) ? 20 : titleBarHeight
         }

         get vTitle() {
            return this.getSlot("window-title").html
         }
         set vTitle(html) {
            if (typeof html === "string")
               this.getSlot("window-title").html = html
         }

         get vContent() {
            return this.getSlot("window-content").node
         }
         set vContent(node) {
            if (node instanceof Node)
               this.getSlot("window-content").node = node
         }

         get vWindowState() {
            return this.#windowState
         }
         set vWindowState(state) {
            const oldState = this.#windowState
            if (oldState === state)
               return
            if (oldState === WindowVM.CLOSED) {
               if (!this.closedState?.connectedTo)
                  return
               this.connectedTo = this.closedState?.connectedTo
               delete this.closedState
            }
            if (oldState === WindowVM.VISIBLE)
               this.#visibleState = { style: View.getStyles(this.htmlElem, ["width","height","top","left"]) }
            if (state === WindowVM.VISIBLE) {
               const htmlElem = this.htmlElem
               asyncUIUpdate( () => {
                  this.hidden = false
                  asyncUIUpdate( () => {
                     if (this.#visibleState.style) {
                        const oldTransitionStyle = View.setStyles(htmlElem, WindowVM.TRANSITION_STYLE)
                        asyncUIUpdate( () => View.setStyles(htmlElem, this.#visibleState.style))
                        new TransitionController(htmlElem, () => {
                           View.setStyles(htmlElem, oldTransitionStyle)
                        }).setTimeout(500)
                     }
                  })
               })
            }
            else if (state === WindowVM.HIDDEN) {
               asyncUIUpdate( () => this.hidden = true)
            }
            else if (state === WindowVM.MINIMIZED) {
               const htmlElem = this.htmlElem
               asyncUIUpdate( () => {
                  this.hidden = false
                  asyncUIUpdate( () => {
                     const cstyle = getComputedStyle(htmlElem)
                     const minHeight = this.minimizedHeight()
                     const pos = htmlElem.getBoundingClientRect()
                     const width = (2*minHeight)+"px", height = minHeight+"px"
                     const top = window.innerHeight-2*minHeight, left = 5
                     const newPos = cstyle.position === "relative"
                                    ? { width, height, top:(top-pos.top+parseFloat(cstyle.top))+"px", left:(left-pos.left+parseFloat(cstyle.left))+"px" }
                                    : { width, height, top:(top+htmlElem.offsetTop-Math.ceil(pos.top))+"px", left:(left+htmlElem.offsetLeft-Math.ceil(pos.left))+"px" }
                     const oldTransitionStyle = View.setStyles(htmlElem, WindowVM.TRANSITION_STYLE)
                     View.setStyles(htmlElem, newPos)
                     new TransitionController(htmlElem, () => {
                        View.setStyles(htmlElem, oldTransitionStyle)
                        this.hidden = true
                     }).setTimeout(500)
                  })
               })
            }
            else if (state === WindowVM.MAXIMIZED) {
               const htmlElem = this.htmlElem
               asyncUIUpdate( () => {
                  this.hidden = false
                  asyncUIUpdate( () => {
                     const cstyle = getComputedStyle(htmlElem)
                     const pos = htmlElem.getBoundingClientRect()
                     const newPos = cstyle.position === "relative"
                                 ? { width:"100%", height:"100vh", top:(parseFloat(cstyle.top)-pos.top)+"px", left:(parseFloat(cstyle.left)-pos.left)+"px" }
                                 : { width:"100%", height:"100vh", top:Math.max(0,htmlElem.offsetTop-Math.ceil(pos.top))+"px", left:Math.max(0,htmlElem.offsetLeft-Math.ceil(pos.left))+"px" }
                     const oldTransitionStyle = View.setStyles(htmlElem, WindowVM.TRANSITION_STYLE)
                     View.setStyles(htmlElem, newPos)
                     new TransitionController(htmlElem, () => {
                        View.setStyles(htmlElem, oldTransitionStyle)
                     }).setTimeout(500)
                  })
               })
            }
            else if (state == WindowVM.CLOSED) {
               this.closedState = { connectedTo: this.connectedTo }
               this.connected = false
            }
            else
               this.error(`Unsupported window state: ${state}`)
            this.#windowState = state
            this._update_vWindowState?.(this,state)
         }
      }


      class WindowStackVM extends ViewModel {
         #templateSel="#js-minimized-window-template"
         #windowVMs=new Map()

         constructor(htmlElem, modelName) {
            super(htmlElem, modelName || "WindowStack")
            super.bindEventHandlers(WindowStackVM.prototype)
         }

         setTemplate(elemSel) {
            this.#templateSel = elemSel
         }

         addMinimized(windowVM) {
            const htmlElem = ElemSel.clone(this.#templateSel)
            const slots = new ViewSlots(htmlElem)
            slots.getSlot("window-title").html = windowVM.vTitle
            const controllers = [
               new ClickController(slots.getSlot("close").htmlElem, (e) => {
                  this.setWindowState(windowVM, WindowVM.CLOSED)
               }),
               new ClickController(slots.getSlot("window-title").htmlElem, (e) => {
                  this.setWindowState(windowVM)
               }),
            ]
            this.htmlElem.append(htmlElem)
            return { htmlElem, controllers }
         }

         setWindowState(windowVM, vWindowState) {
            const state = this.#windowVMs.get(windowVM)
            if (state)
               windowVM.vWindowState = vWindowState ?? state.vWindowState
         }
         removeMinimized(windowVM) {
            const state = this.#windowVMs.get(windowVM)
            if (state?.minimized) {
               const minimized = state.minimized
               minimized.htmlElem.remove()
               minimized.controllers.forEach( cntrl => cntrl.remove())
               state.minimized = null
            }
         }

         unregister(windowVM) {
            this.removeMinimized(windowVM)
            this.#windowVMs.delete(windowVM)
         }

         register(windowVM) {
            if (this.#windowVMs.has(windowVM))
               return
            this.#windowVMs.set(windowVM, { windowVM, vWindowState:windowVM.vWindowState, minimized: null })
            const prevObserver = windowVM.getUpdateObserver("vWindowState")
            windowVM.setUpdateObserver("vWindowState", (vm,vWindowState) => {
               prevObserver?.(vm,vWindowState)
               if (!this.#windowVMs.has(vm))
                  this.#windowVMs.set(windowVM, { windowVM, vWindowState:WindowVM.VISIBLE, minimized: null })
               const state = this.#windowVMs.get(vm)
               if (vWindowState === WindowVM.MINIMIZED || vWindowState === WindowVM.HIDDEN) {
                  if (!state.minimized)
                     state.minimized = winstackVM.addMinimized(vm)
               }
               else if (vWindowState === WindowVM.CLOSED)
                  this.unregister(vm)
               else {
                  state.vWindowState = vWindowState
                  this.removeMinimized(vm)
               }
            })
         }

      }

      const win1VM = decorateElement(div1, WindowDecorator, { template: ElemSel.clone("#js-window-template"), title: "Hello 1" }).viewModel
      const win2VM = decorateElement(div2, WindowDecorator, { template: ElemSel.clone("#js-window-template"), title: "Hello 2" }).viewModel
      const win3VM = decorateElement(div3, WindowDecorator, { template: ElemSel.clone("#js-window-template"), title: "Hello 3" }).viewModel
      // decorateElement(div1, ResizeDecorator)
      // decorateElement(div2, ResizeDecorator)
      // decorateElement(div3, ResizeDecorator)

      console.log(htmlListeners.getListenedElements(document))

      const winstackVM = new WindowStackVM(ElemSel.htmlElem("[class='js-window-stack']"))

      winstackVM.count = 0
      ElemSel.htmlElem("[class='js-window-stack'] button").addEventListener("click", (e) => {
         if (win1VM.vWindowState === WindowVM.CLOSED)
            win1VM.vWindowState = WindowVM.VISIBLE
         else if (win2VM.vWindowState === WindowVM.CLOSED)
            win2VM.vWindowState = WindowVM.VISIBLE
         else if (win3VM.vWindowState === WindowVM.CLOSED)
            win3VM.vWindowState = WindowVM.VISIBLE
      })

      winstackVM.register(win1VM)
      winstackVM.register(win2VM)
      winstackVM.register(win3VM)

   </script>


</body>
</html>
