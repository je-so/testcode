<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Test Resize</title>
   <link rel="stylesheet" href="icons/bootstrap-icons.min.css">
   <link href="bootstrap/bootstrap.css" integrity="sha384-qAlWxD5RDF+aEdUc1Z7GR/tE4zYjX1Igo/LrIexlnzM6G63a6F1fXZWpZKSrSW86" rel="stylesheet" crossorigin="anonymous">
   <script src="bootstrap/bootstrap.bundle.js" integrity="sha384-5xO2n1cyGKAe630nacBqFQxWoXjUIkhoc/FxQrWM07EIZ3TuqkAsusDeyPDOIeid" crossorigin="anonymous"></script>
   <style>
      .js-window {
         --border-color: #333;
         background-color: black; color: white;
         border-radius: 12px 12px 0 0; border: 1px var(--border-color) solid;
         box-sizing: border-box; position: fixed;
         display: flex; flex-flow: column nowrap; place-items: stretch;
      }
      .js-window.js-d-none {
         display: none;
      }
      .js-window .js-head {
         flex: 0 0 auto;
         box-sizing: border-box;
         border-bottom: 1px var(--border-color) solid;
         display: flex; flex-flow: row nowrap;
         overflow: hidden;
      }
      .js-window .js-body {
         flex: 1 1 auto;
         background-color: lightcoral;
         box-sizing: border-box;
         overflow: hidden; contain: layout;
         display: grid; place-items: stretch;
      }
      .js-window .js-head .js-controls {
         flex: 0 0 auto; align-self: center; order: 2;
         padding: 3px 5px 3px 3px;
      }
      .js-window .js-head .js-title {
         flex: 1 1 auto; align-self: stretch; order: 1;
         border-radius: 12px 0 0 0; padding: 3px 0px 3px 10px;
         box-sizing: border-box; overflow: hidden; white-space: nowrap;
      }
      .js-controls [data-slot='min'], .js-controls [data-slot='max'], .js-controls [data-slot='close'] {
         margin-left: 0.5em; padding: 2px 3px;
         box-sizing: border-box;
         width: 1em;
         cursor: pointer;
      }
      .js-controls [data-slot='min']:hover, .js-controls [data-slot='max']:hover, .js-controls [data-slot='close']:hover {
         padding-left: 4px; padding-right: 2px;
         background-color: lightslategray;
      }
      .js-controls .maximized[data-slot='max']::before {
         text-decoration: underline dotted;
      }
      .js-controls [data-slot='close']:hover {
         background-color: lightcoral;
      }

      .js-window-stack {
         border: 1px darkgrey solid; background-color: lemonchiffon;
         padding: 3px;
         position: fixed; left: 5px; bottom: 5px;
         display: flex; flex-flow: column-reverse nowrap; place-items: stretch; gap: 5px;
      }
      .js-window-stack > * {
         position: static;
      }
      .js-window-stack .js-window .js-title:hover {
         background-color: lightslategray;
         cursor: pointer;
      }
      .js-window-stack button {
         color:white; background-color:cadetblue;
         border:1px darkgoldenrod solid;
         padding:3px;
      }
      .js-window-stack button:hover {
         color:#fafafa;
         outline:1px darkgoldenrod solid;
         padding:4px 2px 2px 4px;
      }
      .dropzone {
         border:2px white dashed;
      }
      .dropzone.dropallowed {
         box-shadow: inset 0 0 3px 2px #33773A;
      }
      .dropzone.dropforbidden {
         box-shadow: inset 0 0 3px 2px red;
      }
   </style>
</head>
<body>
   <template id="js-window-template">
      <!-- use  » data-config="hiddenClassName: class-name, ..." « to config other class name for hidden=true ==> (display=none) -->
      <div class="js-window">
         <div class="js-head" data-slot="minimized-height">
            <div class="js-title" data-slot="window-title"></div>
            <div class="js-controls"><i data-slot="min" class="bi-dash-lg"></i><i data-slot="max" class="bi-square"></i><i data-slot="close" class="bi-x-lg"></i></div>
         </div>
         <div class="js-body" data-slot="window-content"></div>
      </div>
   </template>
   <template id="js-window-template2">
      <div class="js-window">
         <div class="js-head" data-slot="minimized-height">
            <div class="js-title" data-slot="window-title"></div>
            <div class="js-controls"><i data-slot="min" class="bi-dash-lg"></i><i data-slot="close" class="bi-x-lg"></i></div>
         </div>
         <div class="js-body" data-slot="window-content"></div>
      </div>
   </template>
   <template id="js-minimized-window-template">
      <div class="js-window">
         <div class="js-head">
            <div class="js-title" data-slot="window-title"></div>
            <div class="js-controls"><i data-slot="close" class="bi-x-lg"></i></div>
         </div>
      </div>
   </template>
   <h3>Test Move & Resize Divs</h3>
   <dl>
      <dt>Components</dt>
      <dd>
         <ul>
            <li>View (Encapsulates HTMLElement)</li>
            <li>View-Model (Adds operations/logic to View)</li>
            <li>View-Controller (Event-Listeners-Handling (no logic))</li>
            <li>Decorator (Binds HTMLElement to View,-Model,-Controller)</li>
         </ul>
      </dd>
      <dt>Missing Features</dt>
      <dd>
         <ul>
            <li>All things Model</li>
         </ul>
      </dd>
   </dl>

   <div id=window class="dropzone" style="width:30%;height:150px;background-color:darkblue;color:white;font-size:18px;padding:18px;text-align:center;overflow:auto;box-sizing:border-box;position:relative;left:30px;">
      <div>Drop Image (for upload)</div>
   </div>

   <div id=window2 style="position:absolute;left:440px;top:160px;width:200px;height:150px;background-color:darkviolet;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;">
      (absolute)<br>undecorate with test3()
   </div>

   <div id=window3 style="position:fixed;left:300px;top:230px;width:200px;height:150px;background-color:teal;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;">
      (fixed)<br>call test() or test2()
   </div>

   <div class="js-window-stack">
      <button>Restore closed window</button>
   </div>

   <code><pre style="margin-block:8px">
      # start upload server (localhost:9090)
      > bun server.js</pre></code>
   <div>== LOG ==</div>
   <div id="LOG"></div>
   <div style="height:1000px;"></div>

   <script>
      /////////
      // LOG //
      /////////
      let logLines = 0
      const logError = (msg) => {
         ++ logLines
         let append = document.getElementById("LOG").innerHTML
         if (logLines > 15) {
            append = append.substring(0,append.lastIndexOf("<br>"))
         }
         document.getElementById("LOG").innerHTML = (logLines%100) + " " + msg + "<br>" + append
      }
      window.addEventListener("error", (e) => {
         if (e.error?.stack)
            e.error.stack.toString().split("\n").reverse().forEach(traceLine => traceLine.trim() && logError("&nbsp; "+traceLine))
         logError(`line ${e.lineno}: ${e.message}`)
      })
   </script>

   <script>
      /**
       * Stores state of event listener added to HTML view.
       */
      class ViewListener {
         /////////////
         // Options //
         /////////////
         static TARGET_ONLY = true

         /** Constructs stored listener state. Serves as documentation for the various data fields.
          * @param {HTMLElement} htmlElem - The HTML element which for which the event handler is registered.
          * @param {string} eventType - The event type ("click","touchstart",...).
          * @param {(e:Event)=>void} eventHandler - Registered callback which handles event of certain type of an html element.
          * @param {object|null} owner - Owner of the listener (used as reference in other listeners to block this one.
          * @property {object[]} blockedOwners - An array of owners which have lower priority and are suppressed if this listener is processed.
          * @property {boolean} TARGET_ONLY - If set to true all other event handlers not registered for this specific target are ignored (listeners registered for child or parent nodes).
          *                                   Events bubble therefore html elements which are nested within each other all receive the event (if any listener is registered).
          */
         constructor(htmlElem, eventType, eventHandler, owner=null, blockedOwners=[], TARGET_ONLY=false) {
            this.htmlElem = htmlElem
            this.eventType = eventType
            this.eventHandler = eventHandler
            this.owner = owner
            this.blockedOwners = blockedOwners.filter(o => o != null)
            this.referenceCount = 1
            this.TARGET_ONLY = TARGET_ONLY
         }
         addReference() {
            return ++ this.referenceCount
         }
         removeReference() {
            return -- this.referenceCount
         }
      }

      /**
       * Manages event listeners and allows to prioritize them.
       * One listener could block one or more other listeners.
       * So if two listeners would be executed, and one is blocked by the other
       * only one is executed. Higher priority of a listener is expresses by
       * blocking the one with lower priority.
       */
      class ViewListeners {
         /** All listeners are managed by this single instance. */
         static singleton = new ViewListeners()
         htmlElements = new WeakMap()
         bubbleEvent = null
         captureEvent = null
         blockedOwners = null
         capturedTargets = null
         capturedListeners = null
         processedListener = null
         TARGET_ONLY = false
         onCaptureBind = null
         onBubbleBind =  null
         DEBUG = true
         constructor() {
            this.onCaptureBind = this.onCapture.bind(this)
            this.onBubbleBind = this.onBubble.bind(this)
         }
         error(msg) {
            throw Error(`ViewListeners error: ${msg}`)
         }
         onCapture(e) {
            if (!this.captureEvent) {
               this.captureEvent = e
               this.bubbleEvent = null
               this.blockedOwners = new Set()
               this.capturedTargets = new WeakSet()
               this.capturedListeners = this.DEBUG && new Set() || null
               this.processedListeners = this.DEBUG && new Set() || null
               this.TARGET_ONLY = false
            }
            else if (e !== this.captureEvent)
               this.error("Internal: Event loop processes two capture events at same time.")
            if (this.capturedTargets.has(e.currentTarget)) {
               console.warn("Internal: onCapture called with same target more than once.")
            }
            else {
               this.capturedTargets.add(e.currentTarget)
               const listeners = this.get(e.currentTarget,e.type)
               for (const listener of listeners) {
                  for (const owner of listener.blockedOwners) {
                     this.blockedOwners.add(owner)
                  }
                  if (listener.TARGET_ONLY && e.target === e.currentTarget)
                     this.TARGET_ONLY = true
                  this.DEBUG && this.capturedListeners.add(listener)
               }
            }
         }
         onBubble(e) {
            if (!this.bubbleEvent) {
               this.bubbleEvent = e
               this.captureEvent = null
               if (this.DEBUG && !this.capturedListeners.size)
                  console.warn("Internal: capture phase found no listener(s).")
            }
            else if (e !== this.bubbleEvent)
               this.error("Internal: Event loop processes two bubble events at same time.")
            if (  this.capturedTargets.has(e.currentTarget)
               && (!this.TARGET_ONLY || e.currentTarget === e.target)) {
               const listeners = this.get(e.currentTarget,e.type)
               for (const listener of listeners) {
                  if (!this.blockedOwners.has(listener.owner)
                     && (!listener.TARGET_ONLY || e.currentTarget === e.target)) {
                     listener.eventHandler(e)
                     this.DEBUG && this.processedListeners.add(listener)
                  }
               }
            }
            this.capturedTargets.delete(e.currentTarget)
            if (this.DEBUG && !this.capturedTargets.size && !this.processedListeners.size)
               console.warn("Internal: bubble phase processed no listener (all blocked).")
         }
         addListener(htmlElem, eventType, eventHandler, {blockedOwners, owner, TARGET_ONLY}={}) {
            const eventTypes = this.htmlElements.get(htmlElem) || {}
            const map = eventTypes[eventType] || new Map()
            if (!map.has(eventHandler)) {
               const listener = new ViewListener(htmlElem, eventType, eventHandler, owner, blockedOwners, TARGET_ONLY)
               if (map.size === 0) {
                  eventTypes[eventType] = map
                  this.htmlElements.set(htmlElem,eventTypes)
                  listener.htmlElem.addEventListener(listener.eventType,this.onCaptureBind,{capture:true,passive:false})
                  listener.htmlElem.addEventListener(listener.eventType,this.onBubbleBind,{capture:false,passive:false})
               }
               map.set(eventHandler,listener)
               return listener
            }
            else {
               const listener = map.get(eventHandler)
               listener.addReference()
               return listener
            }
         }
         removeListener(listener) {
            const eventTypes = this.htmlElements.get(listener?.htmlElem)
            const map = eventTypes && eventTypes[listener.eventType]
            const isListener = map && map.get(listener.eventHandler)
            if (isListener && listener.removeReference() <= 0) {
               map.delete(listener.eventHandler)
               if (map.size === 0) {
                  listener.htmlElem.removeEventListener(listener.eventType,this.onCaptureBind,{capture:true,passive:false})
                  listener.htmlElem.removeEventListener(listener.eventType,this.onBubbleBind,{capture:false,passive:false})
               }
            }
         }
         /**
          * Returns iterator for iterating over all matching listeners.
          * @param {HTMLElement} htmlElem The HTML element whose listeners are queried.
          * @param {string=} eventType Optional type of the event the listener must match else listeners with any event type are matched.
          * @param {(e:Event)=>void} eventHandler Optional event handler function the listener must match else all listeners with any event handler are matched.
          */
         get(htmlElem, eventType, eventHandler) {
            const eventTypes = this.htmlElements.get(htmlElem)
            if (!eventTypes)
               return [].values()
            if (eventType)
               if (eventHandler)
                  return eventTypes[eventType] && eventTypes[eventType].get(eventHandler)
                     ? [eventTypes[eventType].get(eventHandler)].values()
                     : [].values()
               else
                  return (eventTypes[eventType] || []).values()
            return (function*() {
               for (const key in eventTypes) {
                  const map = eventTypes[key]
                  if (map) {
                     if (!eventHandler)
                        yield* map.values()
                     const listener = map.get(eventHandler)
                     if (listener)
                        yield listener
                  }
               }
            })()
         }
         isListener(htmlElem, eventType, eventHandler) {
            return !this.get(htmlElem,eventType,eventHandler).next().done
         }
         getListenedElements(rootElem, eventType, eventHandler) {
            const result = []
            if (this.isListener(rootElem,eventType,eventHandler))
               result.push(rootElem)
            for (const htmlElem of rootElem.querySelectorAll("*")) {
               if (this.isListener(htmlElem,eventType,eventHandler))
                  result.push(htmlElem)
            }
            return result
         }
         static getListenedElements(rootElem, eventType, eventHandler) {
            return this.singleton.getListenedElements(rootElem,eventType,eventHandler)
         }
      }

      /**
       * Supports event listeners and blocking of other controllers.
       */
      class ViewController {
         static preventDefault = (e) => e.preventDefault()
         #isActive = false
         #listeners = []
         #activeListeners = []
         #blockedControllers = []
         #blockingCount = 0
         #othersBlocked = false
         #htmlElem
         #callback
         constructor(htmlElem, clickCallback, ...blockedControllers) {
            if (htmlElem)
               this.add(htmlElem, clickCallback, ...blockedControllers)
         }
         get htmlElem() {
            return this.#htmlElem
         }
         get callback() {
            return this.#callback
         }
         get isActive() {
            return this.#isActive
         }
         get isBlocked() {
            return Boolean(this.#blockingCount)
         }
         callAction(e) {
            if (!this.isBlocked && this.#callback)
               this.#callback(e)
         }
         callActionOnce(e) {
            const callback = this.#callback
            if (!this.isBlocked && callback) {
               this.#callback = null
               callback(e)
            }
         }
         removeListeners(listenerArray) {
            listenerArray.forEach(listener => listener && ViewListeners.singleton.removeListener(listener))
            listenerArray.length = 0
         }
         block() {
            (1 === ++this.#blockingCount) && this.onBlock()
         }
         unblock() {
            (0 === --this.#blockingCount) && this.onUnblock()
         }
         blockOthers(isBlocked) {
            if (this.#othersBlocked !== Boolean(isBlocked)) {
               this.#othersBlocked = Boolean(isBlocked)
               if (this.#othersBlocked)
                  for (const contr of this.#blockedControllers)
                     contr.block()
               else
                  for (const contr of this.#blockedControllers)
                     contr.unblock()
            }
         }
         deactivate() {
            if (this.#isActive) {
               this.#isActive = false
               this.removeListeners(this.#activeListeners)
               this.blockOthers(false)
            }
         }
         activate(onActivateCallback) {
            if (!this.#isActive) {
               this.#isActive = true
               this.blockOthers(true)
               onActivateCallback?.()
            }
         }
         #addListener(htmlElem, eventType, eventHandler, options) {
            return ViewListeners.singleton.addListener(htmlElem, eventType, eventHandler,
               { ...options, owner: this, blockedOwners: this.#blockedControllers }
            )
         }
         addListener(htmlElem, eventType, eventHandler, options) {
            this.#listeners.push(this.#addListener(htmlElem,eventType,eventHandler,options))
            return this.#listeners.at(-1)
         }
         addActiveListener(htmlElem, eventType, eventHandler, options) {
            this.#activeListeners.push(this.#addListener(htmlElem,eventType,eventHandler,options))
            return this.#activeListeners.at(-1)
         }
         /////////////////////////////
         // overwritten in subclass //
         /////////////////////////////
         add(htmlElem, callback, ...blockedControllers) {
            if (this.#htmlElem)
               this.remove()
            this.#htmlElem = htmlElem
            this.#callback = callback
            this.#blockedControllers = blockedControllers.flat(Infinity).filter(cntrl => cntrl instanceof ViewController)
            return this
         }
         remove() {
            this.deactivate()
            this.removeListeners(this.#listeners)
            this.#htmlElem = null
            this.#callback = null
            this.#blockedControllers = []
            return this
         }
         onBlock() {
            // do nothing
         }
         onUnblock() {
            // do nothing
         }
         ////////////
         // Helper //
         ////////////
         getTouchById(touches, id) {
            for (const t of (touches||[]))
               if (t.identifier === id)
                  return t
         }
      }

      class ClickController extends ViewController {

         add(htmlElem, clickCallback, ...blockedControllers) {
            super.add(htmlElem, clickCallback, ...blockedControllers)
            this.addListener(htmlElem,"click",this.onClick.bind(this))
            this.addListener(htmlElem,"touchstart",this.onStart.bind(this))
            this.addListener(htmlElem,"mousedown",this.onStart.bind(this))
            return this
         }

         onStart(e) {
            this.activate( () => e.touches
               ? [ this.addActiveListener(e.target,"touchend",this.onEnd.bind(this)),
                   this.addActiveListener(e.target,"touchcancel",this.onEnd.bind(this)) ]
               : [ this.addActiveListener(document,"mouseup",this.onEnd.bind(this)) ]
            )
         }

         onClick(e) {
            this.callAction({type:"click", target:e.currentTarget})
         }

         onEnd(e) {
            if (e.targetTouches?.length)
               return
            this.deactivate()
         }
      }

      class MoveController extends ViewController {
         #pos
         #totalxy
         #truncxy
         DEBUG = ""

         add(htmlElem, moveCallback, ...blockedControllers) {
            super.add(htmlElem, moveCallback, ...blockedControllers)
            this.addListener(htmlElem,"mousedown",this.onStart.bind(this))
            this.addListener(htmlElem,"touchstart",this.onStart.bind(this))
            return this
         }

         extractXY(e) {
            return { x:e.pageX, y:e.pageY, id:e.identifier }
         }

         onStart(e) {
            if (this.DEBUG && e.touches)
               logError(`${this.DEBUG}: start ${e.targetTouches.length} active:${this.isActive} block:${this.isBlocked}`)
            if (this.isActive || (e.touches && e.targetTouches.length !== 1)) {
               return
            }
            const touch = (e.targetTouches && e.targetTouches[0])
            this.#pos = this.extractXY(touch || e)
            this.#totalxy = { x:0, y:0 }
            this.#truncxy = { x:0, y:0 }
            e.preventDefault()
            this.activate( () => touch
                  ?  [  this.addActiveListener(e.target,"touchmove",this.onMove.bind(this)),
                        this.addActiveListener(e.target,"touchend",this.onEnd.bind(this)),
                        this.addActiveListener(e.target,"touchcancel",this.onEnd.bind(this)) ]
                  :  [  this.addActiveListener(document,"mousemove",this.onMove.bind(this)),
                        this.addActiveListener(document,"mouseup",this.onEnd.bind(this)) ])
         }

         onMove(e) {
            if (e.touches && e.targetTouches.length !== 1)
               return
            e.preventDefault()
            const touch = e.targetTouches && e.targetTouches[0]
            const pos = this.extractXY(touch || e)
            const totalxy = { x:pos.x-this.#pos.x+this.#totalxy.x, y:pos.y-this.#pos.y+this.#totalxy.y }
            const truncxy = { x:Math.trunc(totalxy.x), y:Math.trunc(totalxy.y) }
            const movexy = { type:"move", dx:truncxy.x-this.#truncxy.x, dy:truncxy.y-this.#truncxy.y }
            this.#pos = pos
            this.#totalxy = totalxy
            if (movexy.dx || movexy.dy) {
               this.#truncxy = truncxy
               this.callAction(movexy)
            }
         }

         onEnd(e) {
            if (e.targetTouches?.length) {
               this.#pos = this.extractXY(e.targetTouches[0])
               return
            }
            this.deactivate()
         }
      }

      class TouchResizeController extends ViewController {
         #pos
         #totalxy
         #truncxy

         add(htmlElem, resizeCallback, ...blockedControllers) {
            super.add(htmlElem, resizeCallback, ...blockedControllers)
            this.addListener(htmlElem,"touchstart",this.onStart.bind(this))
            return this
         }

         extractXY(e1,e2) {
            return { x:Math.abs(e1.pageX - e2.pageX), y:Math.abs(e1.pageY - e2.pageY) }
         }

         onStart(e) {
            if (this.isActive || e.targetTouches?.length !== 2) {
               return
            }
            this.#pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
            this.#totalxy = { x:0, y:0 }
            this.#truncxy = { x:0, y:0 }
            e.preventDefault()
            this.activate( () =>
               [  this.addActiveListener(e.target,"touchmove",this.onMove.bind(this)),
                  this.addActiveListener(e.target,"touchend",this.onEnd.bind(this)),
                  this.addActiveListener(e.target,"touchcancel",this.onEnd.bind(this)) ])
         }

         onMove(e) {
            if (e.targetTouches.length !== 2)
               return
            e.preventDefault()
            const pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
            const totalxy = { x:pos.x-this.#pos.x+this.#totalxy.x, y:pos.y-this.#pos.y+this.#totalxy.y }
            const truncxy = { x:Math.trunc(totalxy.x), y:Math.trunc(totalxy.y) }
            const resizexy = { type:"resize", dx:truncxy.x-this.#truncxy.x, dy:truncxy.y-this.#truncxy.y }
            this.#pos = pos
            this.#totalxy = totalxy
            if (resizexy.dx || resizexy.dy) {
               this.#truncxy = truncxy
               this.callAction(resizexy)
            }
         }

         onEnd(e) {
            if (e.targetTouches?.length >= 2) {
               this.#pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
               return
            }
            this.deactivate()
         }
      }

      class TransitionController extends ViewController {
         constructor(htmlElem, callback, ...blockedControllers) {
            super(htmlElem, callback, ...blockedControllers)
         }

         add(htmlElem, endCallback, ...blockedControllers) {
            super.add(htmlElem, endCallback, ...blockedControllers)
            const onEnd = this.onEnd.bind(this)
            super.addListener(htmlElem, "transitionend", onEnd)
            super.addListener(htmlElem, "transitioncancel", onEnd)
            return this
         }

         onEnd(e) {
            this.callActionOnce({type:"transitionend", target:e.target, cancel:e.type==="transitioncancel"})
            this.remove()
         }

         setTimeout(milliseconds) {
            const htmlElem = this.htmlElem
            if (htmlElem) {
               setTimeout( () => {
                  if (this.htmlElem === htmlElem)
                     TransitionController.cancelTransition(htmlElem)
               }, milliseconds)
            }
            return this
         }

         static isInTransition(htmlElem) {
            const animations = htmlElem?.getAnimations(/*{subtree:true} ONLY parent*/)
            return animations?.some(animation => animation instanceof CSSTransition)
         }
         static cancelTransition(htmlElem) {
            htmlElem && htmlElem.dispatchEvent(new Event("transitioncancel"))
         }
         static ensureInTransition(htmlElem) {
            if (!TransitionController.isInTransition(htmlElem))
               TransitionController.cancelTransition(htmlElem)
         }
      }

      /**
       * Supports handling of drop operations in an HTML element (called dropzone).
       *
       * Following HTML events are handled:
       * "dragenter":  "dragged user data entered dropzone" (is sent before dragleave in case entering child element)
       *               event: {type:"dropstart", items: {type,kind}[], target:HTMLElement }
       *               action: indicate drop possible or impossible
       *
       * "dragover":   "dragged user data is within dropzone and moving"
       *               controller prevents only default which enables customized behaviour
       *
       * "drop":       "user dropped data over dropzone"
       *               event: {type:"drop", items: {type:string, kind:string, getAsFile():File,getAsString():string}[], target:HTMLElement }
       *               action: handle dropped data
       *               contoller calls "dragleave" (see dragleave)
       *
       * "dragleave":  "drop operation ends, user exited dropzone, or canceled operation (ESCape button)"
       *               event: {type:"dropend", items, target }
       *               action: remove indication drop possible or impossible
       */
      class DropController extends ViewController {

         /** Stores last entered HTML element for drop operation.
          * Needed to support child elements within dropzone. */
         #startTarget = null

         add(htmlElem, dropCallback, ...blockedControllers) {
            super.add(htmlElem, dropCallback, ...blockedControllers)
            this.addListener(htmlElem,"dragenter",this.onStart.bind(this))
            // enable executing drop handler
            this.addListener(document,"dragover",DropController.preventDefault)
            // prevent opening of images if dropped not into target zone
            this.addListener(document,"drop",DropController.preventDefault)
            return this
         }

         onStart(e) {
            this.#startTarget = e.target
            if (! this.isActive) {
               const event = {type:"dropstart", target:e.currentTarget, items:e.dataTransfer.items }
               this.callAction(event)
               this.activate( () => [
                  this.addActiveListener(e.currentTarget,"drop",this.onDrop.bind(this)),
                  this.addActiveListener(e.currentTarget,"dragleave",this.onEnd.bind(this))
               ])
            }
         }

         onDrop(e) {
            e.preventDefault()
            this.callAction({type:"drop", target:e.currentTarget, items:e.dataTransfer.items})
            this.onEnd(e)
         }

         onEnd(e) {
            if (this.#startTarget === e.target
               // ESCAPE key aborts operation and text child could be returned instead of startTarget
               || e.target.attributes === undefined) {
               this.callAction({type:"dropend", target:e.currentTarget, items:e.dataTransfer.items})
               this.deactivate()
            }
         }
      }

      class HTMLView {
         static error(msg) {
            throw Error(`View error: ${msg}`)
         }
         static needsBorderBox(htmlElem) {
            const needValue = "border-box"
            const styleProp = "box-sizing"
            const value = getComputedStyle(htmlElem)[styleProp]
            if (value != needValue) {
               console.warn(`${this.constructor.name} needs style['${styleProp}']=='${needValue}' instead of '${value}' to work properly on html element`, htmlElem)
               htmlElem.style.setProperty(styleProp,needValue)
            }
         }
         static isEmptyTextNode(htmlElem) {
            return htmlElem && htmlElem.nodeType === 3/*Node.TEXT_NODE*/ && htmlElem.textContent.trim() === ""
         }
         static isDocumentFragment(htmlElem) {
            return htmlElem && htmlElem.nodeType === 11/*Node.DOCUMENT_FRAGMENT_NODE*/
         }
         static getComputedStyles(htmlElem, styles) {
            const computedStyle = getComputedStyle(htmlElem)
            const styleValues = {}
            if (Array.isArray(styles)) {
               for (const key of styles)
                  styleValues[key] = computedStyle[key]
            }
            else {
               for (const key in styles)
                  styleValues[key] = computedStyle[key]
            }
            return styleValues
         }
         static getStyles(htmlElem, styles) {
            const elemStyle = htmlElem.style
            const styleValues = {}
            if (Array.isArray(styles)) {
               for (const key of styles)
                  styleValues[key] = elemStyle.getPropertyValue(key)
            }
            else {
               for (const key in styles)
                  styleValues[key] = elemStyle.getPropertyValue(key)
            }
            return styleValues
         }
         static setStyles(htmlElem, styles) {
            const elemStyle = htmlElem.style
            const oldValues = { }
            for (const key in styles) {
               oldValues[key] = elemStyle.getPropertyValue(key)
               elemStyle.setProperty(key, styles[key])
            }
            return oldValues
         }
         static restoreStyles(htmlElem, oldValues) {
            const elemStyle = htmlElem.style
            for (const key in oldValues)
               elemStyle.setProperty(key, oldValues[key])
         }
         static newElement(htmlString) {
            const div = document.createElement("div")
            div.innerHTML = htmlString
            const htmlElem = div.children[0]
            htmlElem?.remove()
            return htmlElem
         }
         static newElementList(htmlString) {
            const div = document.createElement("div")
            div.innerHTML = htmlString
            const fragment = document.createDocumentFragment()
            fragment.append(...div.childNodes)
            return fragment
         }
         static newDiv(styles) {
            const htmlElem = document.createElement("div")
            this.setStyles(htmlElem, styles)
            return htmlElem
         }
         static parseNr(str, defaultValue=0) {
            const nr = parseFloat(str)
            return isNaN(nr) ? defaultValue : nr
         }
         static getInitialPos(htmlElem) {
            const isNotConnected = !htmlElem.isConnected
            isNotConnected && document.body.appendChild(htmlElem)
            const cstyle = getComputedStyle(htmlElem)
            const position = cstyle.position
            const height = this.parseNr(cstyle.height)
            const width = this.parseNr(cstyle.width)
            const isStatic = isNotConnected || position === "static"
            const top = isStatic ? 0 : this.parseNr(cstyle.top)
            const left = isStatic ? 0 : this.parseNr(cstyle.left)
            isNotConnected && htmlElem.remove()
            return { width, height, top, left, position }
         }
         /**
          * Selects an HTML element from the document and clones it if second argument is provided and true.
          * If the first argument is already an HTML element or undefined it is returned instead.
          * @param {HTMLElement|string|undefined} elemSel - A CSS selector or an HTML element.
          * @param {boolean=} isClone - Optional flag. Set value to true if a deep clone of the HTML element should be returned.
          **/
         static query(elemSel, isClone=false) {
            if (typeof elemSel === "string") {
               const htmlElem = document.querySelector(elemSel) ?? this.error(`Found no html node matching '${elemSel}'.`)
               if (htmlElem.localName === "template") {
                  const child = htmlElem.content.children[0]?.cloneNode(true) ?? this.error(`Found no child node inside matching template '${elemSel}'.`)
                  // connect at least once (touchstart wont work on tablet in case element created from template)
                  return (document.body.append(child), child.remove(), child)
               }
               return isClone ? htmlElem.cloneNode(true) : htmlElem
            }
            return isClone && elemSel ? elemSel.cloneNode(true) : elemSel
         }
         static clone(elemSel) {
            return this.query(elemSel,true)
         }
      }

      class View extends HTMLView {
         #htmlElem
         constructor(htmlElem) {
            super()
            this.#htmlElem = htmlElem
         }
         error(msg) {
            throw Error(`View error: ${msg}`)
         }
         get htmlElem() {
            return this.#htmlElem
         }
         get html() {
            return this.#htmlElem.innerHTML
         }
         set html(htmlString) {
            this.#htmlElem.innerHTML = htmlString
         }
         append(node) {
            this.#htmlElem.append(node)
            return this
         }
         get node() {
            return this.#htmlElem.childNodes[0]
         }
         set node(node) {
            const elem = this.#htmlElem
            while (elem.childNodes.length)
               elem.childNodes[0].remove()
            elem.append(node)
         }
         getComputedStyles(styles) {
            return HTMLView.getComputedStyles(this.htmlElem, styles)
         }
         getStyles(styles) {
            return HTMLView.getStyles(this.htmlElem, styles)
         }
         setStyles(styles) {
            return HTMLView.setStyles(this.htmlElem, styles)
         }
         addClass(className) {
            this.htmlElem.classList.add(className)
         }
         removeClass(className) {
            this.htmlElem.classList.remove(className)
         }
         switchClass(className, switchOn) {
            if (switchOn) {
               this.addClass(className)
            }
            else {
               this.removeClass(className)
            }
         }
      }

      class ViewConfig {
         #values
         constructor(htmlElem) {
            this.#values = ViewConfig.parse(htmlElem)
         }
         hasValue(name) {
            return name in this.#values
         }
         getValue(name) {
            return this.#values[name]
         }
         getValueNames() {
            return Object.keys(this.#values)
         }
         static parseError(inputStr, msg) {
            throw Error(`ViewConfig error: parsing data-config=»${inputStr}«: ${msg}.`)
         }
         static parse(htmlElem) {
            const inputStr = typeof htmlElem==="string" ? htmlElem : htmlElem.dataset.config
            const nameRegex = /^[ \t]*([_a-zA-Z][-_a-zA-Z0-9]*)?[ \t]*/
            const valueRegex = /^[ \t]*('([^'\\]|\\.)*'|"([^\\"]|\\.)*"|[^'",:}{[\]]([^,:}{[\]]*[^ \t,:}{[\]])*|)[ \t]*/
            let unparsed = inputStr
            const skip = (nrChar) => unparsed = unparsed.substring(nrChar).trimLeft()
            const match = (regex) => {
               const parsed = regex.exec(unparsed); skip(parsed[0].length); return parsed
            }
            const expect = (char, name) => {
               (unparsed[0] != char && this.parseError(inputStr,`expect »${char}« instead of »${unparsed[0] ?? 'end of input'}«${name?' after name »'+name+'«':''}${!unparsed.length?'':' at '+(unparsed.length==1?'last position':'position '+(inputStr.length-unparsed.length))}`)) || skip(1)
            }
            const parseValue = (name) => {
               const matched = match(valueRegex)[1]
               if (matched==="") {
                  ["'",'"'].includes(unparsed[0]) && this.parseError(inputStr,`missing closing »${unparsed[0]}«${name?' after name »'+name+'«':''} at ${unparsed.lnegth==1?'last position':'position '+(inputStr.length-unparsed.length)}`)
                  return unparsed[0]==="{" ? parseNamedValues({}, "{", name) :
                        unparsed[0]==="[" ? parseValues([], name) : undefined
               }
               return !["'",'"'].includes(matched[0]) ? matched : matched.substring(1,matched.length-1).replaceAll("\\"+matched[0],matched[0])
            }
            const parseValues = (values, name) => {
               expect("[", name)
               while (unparsed[0] != ']') {
                  values.push(parseValue(name) ?? (unparsed[0] != ']' && expect("value",name)) )
                  unparsed[0] != ']' && expect(",",name) || (values.at(-1) ?? value.pop())
               }
               return (expect("]", name), values)
            }
            const parseNamedValues = (values, expectChar, name) => {
               expectChar && expect("{", name)
               while (unparsed && unparsed[0] != '}') {
                  const matched = match(nameRegex)[1]
                  if (!matched) { unparsed && unparsed[0] != '}' && expect("name",name); break; }
                  expect(":",(name = matched))
                  values[name] = parseValue(name) ?? ""
                  unparsed && unparsed[0] != '}' && expect(",",name)
               }
               return (expectChar && expect("}", name), values)
            }
            const values = {}
            inputStr && parseNamedValues(values)
            unparsed && this.parseError(inputStr,`unexpected char '${unparsed[0]}' at ${unparsed.length==1?'last position':'position '+(inputStr.length-unparsed.length)}`)
            return values
         }
      }

      class ViewSlots {
         #slots
         constructor(htmlElem,...assertedSlotNames) {
            this.#slots = new Map()
            ViewSlots.getSlots(htmlElem).forEach( (namedNodes, name) => {
               this.#slots.set(name, namedNodes.map( htmlElem => new View(htmlElem)))
            })
            this.assertSlotNames(assertedSlotNames, htmlElem)
         }
         error(msg) {
            throw Error(`ViewSlots error: ${msg}`)
         }
         hasSlot(name) {
            return this.#slots.has(name)
         }
         getSlot(name) {
            this.assertSlotName(name)
            return this.#slots.get(name)[0]
         }
         getSlots(name) {
            this.assertSlotName(name)
            return this.#slots.get(name)
         }
         getSlotNames() {
            return new Set(this.#slots.keys())
         }
         assertSlotName(name, htmlElem) {
            if (!this.#slots.has(name)) {
               if (htmlElem)
                  console.log("htmlElem",htmlElem,htmlElem.children)
               this.error(`Missing attribute data-slot='${name}' in HTML.`)
            }
         }
         assertSlotNames(slotNamesArray, htmlElem) {
            for (const name of slotNamesArray)
               this.assertSlotName(name, htmlElem)
         }
         static getSlots(htmlElem) {
            const slots = new Map()
            const nodes = [...htmlElem.querySelectorAll("[data-slot]")]
            if (htmlElem.dataset.slot)
               nodes.push(htmlElem)
            nodes.forEach(node => {
               const name = node.dataset.slot
               const namedNodes = slots.get(name) ?? []
               namedNodes.push(node)
               slots.set(name, namedNodes)
            })
            return slots
         }
      }

      class ViewUpdateListener {
         #callbacks = []
         #frameID = null
         constructor(callback, delayCounter) {
            if (callback)
               this.addOnViewUpdate(callback, delayCounter)
         }
         #onUpdate(timestamp) {
            const callbacks = this.#callbacks
            this.#callbacks = []
            this.#frameID = null
            for (const callback of callbacks)
               callback(timestamp)
         }
         addOnViewUpdate(callback, delayCounter) {
            this.#callbacks.push( 0 < delayCounter && delayCounter < 300
               ? () => this.addOnViewUpdate(callback, delayCounter-1)
               : callback
            )
            if (this.#frameID == null)
               this.#frameID = requestAnimationFrame(this.#onUpdate.bind(this))
         }
      }

      /**
       * Model which is bound to a single view and manages its state.
       */
      class ViewModel {
         /** Default configurations (for all instances) which could be overwritten in subclass. */
         static Default = {
            /** Defines 'Set' of valid property names which could be observed for change. */
            listenableProperties: new Set(["hidden","connected"]),
            /** Class name which sets display to none if set on htmlElement. */
            hiddenClassName: "js-d-none",
         }
         static #viewUpdateListener = new ViewUpdateListener()
         #config
         #htmlElem
         #name
         #on = {}
         #view
         #propertyListeners = {}
         constructor(htmlElem) {
            this.#config = Object.create(this.constructor.Default)
            this.#htmlElem = htmlElem
            this.#name = this.constructor.name
            this.#view = new View(htmlElem)
            const config = new ViewConfig(htmlElem)
            if (config.hasValue("hiddenClassName"))
               this.#config.hiddenClassName = config.getValue("hiddenClassName")
         }
         addOnViewUpdate(callback, delayCounter) {
            ViewModel.#viewUpdateListener.addOnViewUpdate(callback, delayCounter)
         }
         /** Overwrite setOption in subclass. */
         setOption(name, value) {
            switch (name, value) {
               case "connected": this.connected = value; break;
               case "hidden": this.hidden = value; break;
               case "name": this.#name = String(value); break;
               default: this.logError(`Unsupported option »${String(name)}«.`); break; // in subclass: super.setOption(name, value)
            }
         }

         error(msg) {
            throw Error(`${this.#name} error: ${msg}`)
         }
         logError(msg) {
            try { this.error(msg) } catch(e) { console.error(e) }
         }
         setOptions(options={}) {
            for (const name in options)
               this.setOption(name, options[name])
            return this
         }
         get name() {
            return this.#name
         }
         get htmlElem() {
            return this.#htmlElem
         }
         get view() {
            return this.#view
         }
         isEventHandler(name) {
            return (name in this.#on)
         }
         get on() {
            return this.#on
         }
         getEventHandler(name) {
            return this.on[name]
         }
         bindEventHandler(name, eventHandler, thisValue=null) {
            this.#on[name] = eventHandler.bind(thisValue||this)
         }
         bindEventHandlers(prototype) {
            const overwritten = []
            for (const key of Reflect.ownKeys(prototype))
               if (String(key).startsWith("on")) {
                  const name = key.substring(2)
                  if (this.isEventHandler(name))
                     overwritten.push(key)
                  this.bindEventHandler(name,prototype[key])
               }
            return overwritten
         }
         detach() {
            const htmlElem = this.htmlElem
            this.#htmlElem = null
            this.#on = {}
            this.#view = null
            this.#propertyListeners = {}
            return htmlElem
         }
         get connectedTo() {
            // !htmlElem.isConnected ==> parent == nextSibling == null
            const htmlElem = this.htmlElem
            return { parent: htmlElem.parentNode, nextSibling: htmlElem.nextSibling }
         }
         set connectedTo(connectTo) {
            const htmlElem = this.htmlElem
            const isConnected = htmlElem.isConnected
            if (!connectTo?.parent)
               htmlElem.remove()
            else if (htmlElem.parentNode !== connectTo.parent || htmlElem.nextSibling !== connectTo.nextSibling)
               connectTo.parent.insertBefore(htmlElem, connectTo.parent === connectTo.nextSibling?.parentNode ? connectTo.nextSibling : null )
            if (isConnected != htmlElem.isConnected)
               this.notifyPropertyListener("connected",htmlElem.isConnected)
         }
         get connected() {
            return this.htmlElem.isConnected
         }
         set connected(isConnect) {
            const htmlElem = this.htmlElem
            if (isConnect != htmlElem.isConnected) {
               if (isConnect)
                  document.body.append(htmlElem)
               else
                  htmlElem.remove()
               this.notifyPropertyListener("connected",isConnect)
            }
         }
         get hidden() {
            return getComputedStyle(this.htmlElem).display === "none"
         }
         set hidden(isHidden) {
            if (isHidden != this.hidden) {
               this.view.switchClass(this.#config.hiddenClassName, isHidden)
               this.notifyPropertyListener("hidden",isHidden)
            }
         }
         get visibility() {
            return getComputedStyle(this.htmlElem).visibility === "visible"
         }
         set visibility(isVisible) {
            if (isVisible === true)
               this.htmlElem.style.visibility = "visible"
            else if (isVisible === false)
               this.htmlElem.style.visibility = "hidden"
         }
         assertListenableProperty(name) {
            if (!this.#config.listenableProperties.has(name))
               this.error(`Listenable property '${name}' does not exist.`)
         }
         notifyPropertyListener(name, newValue) {
            const event = { vm:this, value:newValue, name }
            const callbacks = this.#propertyListeners[name]
            callbacks && callbacks.forEach( callback => callback(event))
         }
         addPropertyListener(name, callback) {
            this.assertListenableProperty(name)
            this.#propertyListeners[name] ??= []
            this.#propertyListeners[name].push(callback)
         }
         removePropertyListener(name, callback) {
            this.assertListenableProperty(name)
            if (this.#propertyListeners[name])
               this.#propertyListeners[name] = this.#propertyListeners[name].filter( cb => cb!==callback)
         }
      }

      class ResizeVM extends ViewModel {

         constructor(htmlElem) {
            super(htmlElem)
            super.bindEventHandlers(ResizeVM.prototype)
         }

         setOption(name, value) {
            switch (name) {
               case "left": this.vLeft = value; break;
               case "height": this.vHeight = value; break;
               case "top": this.vTop = value; break;
               case "width": this.vWidth = value; break;
               default: super.setOption(name, value); break;
            }
         }

         set vHeight(value/*pixels*/) {
            if (value < 0)
               value = 0
            this.htmlElem.style.height = value+"px"
         }
         get vHeight() {
            return View.parseNr(getComputedStyle(this.htmlElem).height)
         }
         set vWidth(value/*pixels*/) {
            if (value < 0)
               value = 0
            this.htmlElem.style.width = value+"px"
         }
         get vWidth() {
            return View.parseNr(getComputedStyle(this.htmlElem).width)
         }
         set vTop(value/*pixels*/) {
            this.htmlElem.style.top = value+"px"
         }
         get vTop() {
            return View.parseNr(getComputedStyle(this.htmlElem).top)
         }
         set vLeft(value/*pixels*/) {
            this.htmlElem.style.left = value+"px"
         }
         get vLeft() {
            return View.parseNr(getComputedStyle(this.htmlElem).left)
         }

         moveable(position) {
            return ["fixed","absolute"].includes(position ?? getComputedStyle(this.htmlElem)["position"])
         }

         move(deltax,deltay) { this.vLeft += deltax; this.vTop += deltay; }
         resizeTop(deltay) { this.vTop -= deltay; this.vHeight += deltay; }
         resizeRight(deltax) { this.vWidth += deltax; }
         resizeBottom(deltay) { this.vHeight += deltay; }
         resizeLeft(deltax) { this.vLeft -= deltax; this.vWidth += deltax; }
         resizeTopLeft(deltax,deltay) { this.resizeLeft(deltax); this.resizeTop(deltay); }
         resizeTopRight(deltax,deltay) { this.resizeRight(deltax); this.resizeTop(deltay); }
         resizeBottomRight(deltax,deltay) { this.resizeRight(deltax); this.resizeBottom(deltay); }
         resizeBottomLeft(deltax,deltay) { this.resizeLeft(deltax); this.resizeBottom(deltay); }
         resize(deltax,deltay) { this.resizeRight(deltax); this.resizeBottom(deltay); this.resizeLeft(deltax); this.resizeTop(deltay); }
         resizeStatic(deltax,deltay) { this.resizeRight(2*deltax); this.resizeBottom(2*deltay); }

         // event handlers are prefixed with "on"

         onMove(e) { this.move(e.dx,e.dy) }
         onResizeTop(e) { this.resizeTop(-e.dy) }
         onResizeRight(e) { this.resizeRight(e.dx) }
         onResizeBottom(e) { this.resizeBottom(e.dy) }
         onResizeLeft(e) { this.resizeLeft(-e.dx) }
         onResizeTopLeft(e) { this.resizeLeft(-e.dx); this.resizeTop(-e.dy); }
         onResizeTopRight(e) { this.resizeRight(e.dx); this.resizeTop(-e.dy); }
         onResizeBottomRight(e) { this.resizeRight(e.dx); this.resizeBottom(e.dy); }
         onResizeBottomLeft(e) { this.resizeLeft(-e.dx); this.resizeBottom(e.dy); }
         onResize(e) { this.resize(e.dx,e.dy) }
         onResizeStatic(e) { this.resizeStatic(e.dx,e.dy) }
      }

      class WindowVM extends ResizeVM {
         static Default = Object.assign(Object.create(super.Default),{
            listenableProperties: new Set(["vWindowState", ...super.Default.listenableProperties])
         })
         #windowState
         #visibleState
         #slots
         #oldTransitionStyle

         /// window states ///
         static HIDDEN = "hidden"; static VISIBLE = "visible"; static MINIMIZED = "minimized"; static MAXIMIZED = "maximized"; static CLOSED = "closed";
         /** Transition style for resize and change position animation. */
         static TRANSITION_STYLE = { "transition-delay":"0s", "transition-duration":"0.2s", "transition-property":"width,height,top,left", "transition-timing-function":"ease-out" }

         constructor(htmlElem) {
            super(htmlElem)
            super.bindEventHandlers(WindowVM.prototype)
            // slot names of optional window controls: "close", "min", "max"
            this.#slots = new ViewSlots(htmlElem, "window-content","window-title")
            this.setOption("setInitialWindowState",true)
         }

         setOption(name, value) {
            switch (name) {
               case "content": this.vContent = value; break;
               case "setInitialWindowState": if (value) this.#windowState = (this.isDisplayed() ? WindowVM.VISIBLE : WindowVM.HIDDEN); break;
               case "title": this.vTitle = value; break;
               default: super.setOption(name, value); break;
            }
         }

         hasSlot(name) {
            return this.#slots.hasSlot(name)
         }
         getSlot(name) {
            return this.#slots.getSlot(name)
         }

         isDisplayed() {
            return getComputedStyle(this.htmlElem).width.endsWith("px")
         }

         minimizedHeight() {
            const titleBarHeight = 2*parseFloat(getComputedStyle(this.htmlElem)["border-top"])
                  +this.getSlot("minimized-height").htmlElem.offsetHeight
            return isNaN(titleBarHeight) ? 20 : titleBarHeight
         }

         get vTitle() {
            return this.getSlot("window-title").html
         }
         set vTitle(html) {
            if (typeof html === "string")
               this.getSlot("window-title").html = html
         }

         get vContent() {
            return this.getSlot("window-content").node
         }
         set vContent(content) {
            if (content instanceof Node)
               this.getSlot("window-content").node = content
            else if (typeof content === "string")
               this.getSlot("window-content").node = View.newElement(content)
         }

         get visiblePos() {
            const pos = (this.#visibleState && (this.isInTransition() || this.vWindowState !== WindowVM.VISIBLE))
                        ? this.#visibleState.style
                        : View.getInitialPos(this.htmlElem)
            return { width:parseFloat(pos.width), height:parseFloat(pos.height), top:parseFloat(pos.top), left:parseFloat(pos.left) }
         }
         set visiblePos(pos) {
            const styles = {}
            for (const key of ["width","height","top","left"])
               if (pos[key] != null)
                  styles[key] = pos[key]+"px"
            if (this.#visibleState)
               this.#visibleState.style = Object.assign(this.#visibleState.style, styles)
            if (this.vWindowState === WindowVM.VISIBLE) {
               (pos.transition ? this.#startTransition(styles) : View.setStyles(this.htmlElem, styles))
            }
         }

         #startTransition(styles, onTransitionEnd) {
            if (!this.#oldTransitionStyle)
               this.#oldTransitionStyle = View.setStyles(this.htmlElem, WindowVM.TRANSITION_STYLE)
            new TransitionController(this.htmlElem, () => {
               this.#disableTransition()
               onTransitionEnd?.()
            })
            View.setStyles(this.htmlElem, styles)
            TransitionController.ensureInTransition(this.htmlElem)
         }
         #disableTransition() {
            if (this.#oldTransitionStyle) {
               View.setStyles(this.htmlElem, this.#oldTransitionStyle)
               this.#oldTransitionStyle = undefined
               TransitionController.cancelTransition(this.htmlElem)
            }
         }
         isInTransition() {
            return Boolean(this.#oldTransitionStyle) || TransitionController.isInTransition(this.htmlElem)
         }

         get vWindowState() {
            return this.#windowState
         }
         set vWindowState(state) {
            const oldState = this.#windowState
            if (oldState === state)
               return
            if (oldState === WindowVM.CLOSED) {
               this.connectedTo = this.closedState?.connectedTo
               delete this.closedState
            }
            this.connected = true
            if (!this.#visibleState || (oldState === WindowVM.VISIBLE && !this.#visibleState.locked && !this.isInTransition())) {
               this.hidden = false
               this.#visibleState = { locked:false, style: View.getComputedStyles(this.htmlElem, ["width","height","top","left"]) }
            }
            if (state === WindowVM.VISIBLE) {
               const htmlElem = this.htmlElem
               this.#visibleState.locked = true
               this.addOnViewUpdate( () => {
                  this.hidden = false
                  if (oldState === WindowVM.HIDDEN)
                     View.setStyles(htmlElem, this.#visibleState.style)
                  this.addOnViewUpdate( () => { // switching display from "none" (hidden true->false) needs one frame waiting to make transitions work
                     this.#visibleState.locked = false
                     if (this.#windowState === WindowVM.VISIBLE) {
                        this.#startTransition(this.#visibleState.style, () => {
                           if (this.#windowState === WindowVM.VISIBLE)
                              htmlElem.scrollIntoView?.({block:"nearest"})
                        })
                     }
                  })
               })
            }
            else if (state === WindowVM.HIDDEN) {
               this.addOnViewUpdate( () => this.hidden = true)
            }
            else if (state === WindowVM.MINIMIZED) {
               const htmlElem = this.htmlElem
               this.addOnViewUpdate( () => {
                  this.hidden = false
                  const cstyle = getComputedStyle(htmlElem)
                  const minHeight = this.minimizedHeight()
                  const pos = htmlElem.getBoundingClientRect()
                  const width = (2*minHeight)+"px", height = minHeight+"px"
                  const top = window.innerHeight-2*minHeight, left = 5
                  const newPos = { width, height, top:(top-pos.top+parseFloat(cstyle.top))+"px", left:(left-pos.left+parseFloat(cstyle.left))+"px" }
                  if (oldState === WindowVM.HIDDEN)
                     this.hidden = true
                  this.addOnViewUpdate( () => { // switching display from "none" (hidden true->false) needs one frame waiting to make transitions work
                     if (this.#windowState === WindowVM.MINIMIZED) {
                        this.#startTransition(newPos, () => {
                           if (this.#windowState === WindowVM.MINIMIZED)
                              this.hidden = true
                        })
                     }
                  })
               })
            }
            else if (state === WindowVM.MAXIMIZED) {
               const htmlElem = this.htmlElem
               this.addOnViewUpdate( () => {
                  this.hidden = false
                  const pos = htmlElem.getBoundingClientRect()
                  const cstyle = getComputedStyle(htmlElem)
                  const newPos = { width:"100vw", height:"100vh", top:(parseFloat(cstyle.top)-pos.top)+"px", left:(parseFloat(cstyle.left)-pos.left)+"px" }
                  if (oldState === WindowVM.HIDDEN)
                     View.setStyles(htmlElem, newPos)
                  this.addOnViewUpdate( () => { // switching display from "none" (hidden true->false) needs one frame waiting to make transitions work
                     if (this.#windowState === WindowVM.MAXIMIZED) {
                        this.#startTransition(newPos, () => {
                           if (this.#windowState === WindowVM.MAXIMIZED)
                              htmlElem.scrollIntoView?.({block:"start"})
                        })
                     }
                  })
               })
            }
            else if (state == WindowVM.CLOSED) {
               this.closedState = { connectedTo: this.connectedTo }
               this.connected = false
            }
            else
               this.error(`Unsupported window state: ${state}`)
            if (this.hasSlot("max"))
               this.getSlot("max").switchClass("maximized", (state === WindowVM.MAXIMIZED))
            this.#windowState = state
            this.notifyPropertyListener("vWindowState",state)
         }
      }

      class WindowStackVM extends ViewModel {
         #template = View.query("#js-minimized-window-template")
         #windowVMs = new Map()

         constructor(htmlElem) {
            super(htmlElem)
            super.bindEventHandlers(WindowStackVM.prototype)
         }

         setTemplate(elemSel) {
            this.#template = elemSel
         }

         addMinimized(windowVM) {
            const htmlElem = View.clone(this.#template)
            const slots = new ViewSlots(htmlElem,"window-title")
            slots.getSlot("window-title").html = windowVM.vTitle
            const controllers = [
               slots.hasSlot("close") && new ClickController(slots.getSlot("close").htmlElem, (e) => {
                  windowVM.vWindowState = WindowVM.CLOSED
               }),
               new ClickController(slots.getSlot("window-title").htmlElem, (e) => {
                  this.resetWindowState(windowVM)
               }),
            ]
            this.htmlElem.append(htmlElem)
            return { htmlElem, controllers }
         }
         removeMinimized(windowVM) {
            const state = this.#windowVMs.get(windowVM)
            const minimized = state?.minimized
            if (minimized) {
               state.minimized = null
               minimized.htmlElem.remove()
               minimized.controllers.forEach( cntrl => cntrl.remove())
            }
         }

         resetWindowState(windowVM) {
            const state = this.#windowVMs.get(windowVM)
            if (state)
               windowVM.vWindowState = state.vWindowState
         }

         unregister(windowVM) {
            this.removeMinimized(windowVM)
            this.#windowVMs.delete(windowVM)
            windowVM.removePropertyListener("vWindowState", this.on.Update)
         }
         register(windowVM) {
            if (this.#windowVMs.has(windowVM))
               return
            this.#windowVMs.set(windowVM, { windowVM, vWindowState:windowVM.vWindowState, minimized: null })
            windowVM.addPropertyListener("vWindowState", this.on.Update)
         }

         onUpdate({vm: windowVM, value: vWindowState}) {
            const state = this.#windowVMs.get(windowVM)
            if (!state)
               this.error("received update event for unregistered Window-View-Model.")
            if (vWindowState === WindowVM.MINIMIZED || vWindowState === WindowVM.HIDDEN) {
               if (!state.minimized)
                  state.minimized = winstackVM.addMinimized(windowVM)
            }
            else if (vWindowState === WindowVM.CLOSED)
               this.unregister(windowVM)
            else {
               state.vWindowState = vWindowState
               this.removeMinimized(windowVM)
            }
         }
      }

      /**
       * Stores state of an decorator after applying it to an HTML element.
       */
      class ViewDecorator {
         /**
          * Constructor which decorates an HTML element (creates ViewController and binds their action callbacks).
          * @param {HTMLElement} htmlElem - The HTML element which serves as root view.
          * @param {object} options - Additional options. Property viewModel could be set to provide a ViewModel else a default one is created.
          */
         constructor(htmlElem, options={}) {
            this.viewModel = null
            this.controllers = {}
            this.decorate(htmlElem, options)
         }
         error(msg) {
            throw Error(`ViewDecorator error: ${msg}`)
         }
         defaultModel(htmlElem, options) {
            this.error("defaultModel(htmlElem,options) not implemented in subclass.")
         }
         createOnceViewModel(htmlElem, {viewModel, ...options}={}) {
            this.viewModel ??= viewModel ?? this.defaultModel(htmlElem,options)
            if (!(this.viewModel instanceof ViewModel))
               this.error("Argument viewModel is not of type ViewModel.")
            return this.viewModel
         }
         decorate(htmlElem, options) {
            this.createOnceViewModel(htmlElem,options)
            ViewDecorators.singleton.add(this.viewModel.htmlElem, this)
         }
         undecorate() {
            (this.viewModel) && ViewDecorators.singleton.remove(this.viewModel.htmlElem, this)
            for (const key in this.controllers) {
               if (this.controllers[key] instanceof ViewController)
                  this.controllers[key].remove()
            }
            this.controllers = {}
            this.viewModel = null
         }
      }

      class ResizeDecorator extends ViewDecorator {

         defaultModel(htmlElem, options) {
            return new ResizeVM(htmlElem)
         }

         decorate(htmlElem, { moveable, ...options }) {
            super.decorate(htmlElem, options)
            const viewModel = this.viewModel
            const width = { outer:10, border:15, edge:20 }
            const size = { border: width.border+"px", edge:width.edge+"px", outer:"-"+width.outer+"px" }
            moveable ??= viewModel.moveable()
            const borders = [
               moveable && View.newDiv({top:size.outer, left:0, right:0, height:size.border, cursor:"n-resize", position:"absolute"}),
               View.newDiv({right:size.outer, top:0, bottom:0, width:size.border, cursor:"e-resize", position:"absolute"}),
               View.newDiv({bottom:size.outer, left:0, right:0, height:size.border, cursor:"s-resize", position:"absolute"}),
               moveable && View.newDiv({left:size.outer, top:0, bottom:0, width:size.border, cursor:"w-resize", position:"absolute"}),
               moveable && View.newDiv({top:size.outer, left:size.outer, width:size.edge, height:size.edge, cursor:"nw-resize", position:"absolute"}),
               moveable && View.newDiv({top:size.outer, right:size.outer, width:size.edge, height:size.edge, cursor:"ne-resize", position:"absolute"}),
               View.newDiv({bottom:size.outer, right:size.outer, width:size.edge, height:size.edge, cursor:"se-resize", position:"absolute"}),
               moveable && View.newDiv({bottom:size.outer, left:size.outer, width:size.edge, height:size.edge, cursor:"sw-resize", position:"absolute"}),
            ]
            htmlElem.append(...borders.filter(border=>Boolean(border)))
            this.resizeState = { borders, oldStylesHtmlElem:htmlElem, oldStyles:null, isResizeable:true, controllers:null }
            const moveWin = moveable && new MoveController(htmlElem,viewModel.on.Move)
            moveWin && (moveWin.DEBUG = "movewin")
            const resizeWin = new TouchResizeController(htmlElem,viewModel.on[moveable ? "Resize" : "ResizeStatic"])
            const moveResizeGroup = [moveWin,resizeWin]
            const topResize = moveable && new MoveController(borders[0],viewModel.on.ResizeTop,moveResizeGroup)
            const rightResize = new MoveController(borders[1],viewModel.on.ResizeRight,moveResizeGroup)
            const bottomResize = new MoveController(borders[2],viewModel.on.ResizeBottom,moveResizeGroup)
            const leftResize = moveable && new MoveController(borders[3],viewModel.on.ResizeLeft,moveResizeGroup)
            const topLeftResize = moveable && new MoveController(borders[4],viewModel.on.ResizeTopLeft,moveResizeGroup,topResize,leftResize)
            const topRightResize = moveable && new MoveController(borders[5],viewModel.on.ResizeTopRight,moveResizeGroup,topLeftResize,topResize,rightResize)
            const bottomRightResize = new MoveController(borders[6],viewModel.on.ResizeBottomRight,moveResizeGroup,topRightResize,bottomResize,rightResize)
            const bottomLeftResize = moveable && new MoveController(borders[7],viewModel.on.ResizeBottomLeft,moveResizeGroup,topLeftResize,bottomRightResize,bottomResize,leftResize)
            this.resizeState.controllers = { moveWin, resizeWin, topResize, rightResize, bottomResize, leftResize, topLeftResize, topRightResize, bottomRightResize, bottomLeftResize }
            Object.assign(this.controllers, this.resizeState.controllers)
            this.switchStyles()
         }
         switchStyles() {
            if (this.resizeState?.oldStyles)
               (View.setStyles(this.resizeState.oldStylesHtmlElem, this.resizeState.oldStyles), this.resizeState.oldStyles=null)
            else if (this.controllers.moveWin)
               this.resizeState.oldStyles = View.setStyles(this.resizeState.oldStylesHtmlElem, {cursor:"move"})
         }
         switchResizeable(isResizeable) {
            if (this.resizeState.isResizeable != Boolean(isResizeable) && this.resizeState.controllers) {
               this.resizeState.isResizeable = Boolean(isResizeable)
               if (isResizeable) {
                  for (const name in this.resizeState.controllers)
                     this.resizeState.controllers[name].unblock()
                  for (const border of this.resizeState.borders)
                     View.setStyles(border,{visibility:""})
               }
               else {
                  for (const name in this.resizeState.controllers)
                     this.resizeState.controllers[name].block()
                  for (const border of this.resizeState.borders)
                     View.setStyles(border,{visibility:"hidden"})
               }
               this.switchStyles()
            }
         }
         undecorate() {
            super.undecorate()
            if (this.resizeState) {
               this.switchStyles()
               for (const border of this.resizeState.borders)
                  (border) && border.remove()
               this.resizeState = null
            }
         }
      }

      class WindowDecorator extends ResizeDecorator {

         defaultModel(htmlElem, {template}) {
            const parentHtmlElem = View.query(template) ?? View.clone("#js-window-template")
            return new WindowVM(parentHtmlElem)
         }

         decorate(htmlElem, {title, ...options}={}) {
            const viewModel = this.createOnceViewModel(htmlElem,options)
            const pos = View.getInitialPos(htmlElem)
            viewModel.vTitle = title
            this.windowState = { replacedChild:false, oldChild:htmlElem, oldChildStyles:null }
            // make htmlElem child of viewModel.htmlElem if child instead of viewModel is decorated
            if (htmlElem !== viewModel.htmlElem) {
               this.windowState.replacedChild = Boolean(htmlElem.parentElement)
               htmlElem.parentElement?.replaceChild(viewModel.htmlElem, htmlElem)
               viewModel.vContent = htmlElem
               viewModel.setOptions({ left:pos.left, top:pos.top, width:pos.width||100, height:pos.height||100, setInitialWindowState:true })
               this.windowState.oldChildStyles = View.setStyles(htmlElem, { width:"100%", height:"100%", position:"static" })
               View.setStyles(viewModel.htmlElem, { position: pos.position })
            }
            super.decorate(viewModel.htmlElem, { ...options, moveable: options.moveable ?? viewModel.moveable(pos.position) })
            const moveWin = this.controllers.moveWin
            this.controllers.close = viewModel.hasSlot("close") && new ClickController(viewModel.getSlot("close").htmlElem, () => {
               viewModel.vWindowState = WindowVM.CLOSED
            },moveWin),
            this.controllers.min = viewModel.hasSlot("min") && new ClickController(viewModel.getSlot("min").htmlElem, () => {
               viewModel.vWindowState = WindowVM.MINIMIZED
            },moveWin),
            this.controllers.max = viewModel.hasSlot("max") && new ClickController(viewModel.getSlot("max").htmlElem, () => {
               viewModel.vWindowState = (viewModel.vWindowState === WindowVM.MAXIMIZED
                                 ? WindowVM.VISIBLE
                                 : WindowVM.MAXIMIZED)
            },moveWin)
         }

         undecorate() {
            if (this.windowState) {
               const htmlElem = this.viewModel.htmlElem
               super.undecorate()
               if (this.windowState.replacedChild) {
                  htmlElem.parentElement.replaceChild(this.windowState.oldChild, htmlElem)
               }
               htmlElem.remove()
               if (this.windowState.oldChildStyles) {
                  View.setStyles(this.windowState.oldChild, this.windowState.oldChildStyles)
               }
               this.windowState = null
            }
         }
      }

      /**
       * Maps HTML elements to applied decorators.
       */
       class ViewDecorators {
         static singleton = new ViewDecorators()
         #htmlElements = new WeakMap()
         constructor() {
         }
         error(msg) {
            throw Error(`ViewDecorators error: ${msg}`)
         }
         add(htmlElem, viewDecorator) {
            this.#htmlElements.set(htmlElem,
               (this.#htmlElements.get(htmlElem) || []).concat(viewDecorator)
            )
         }
         remove(htmlElem, viewDecorator) {
            const decorators = this.#htmlElements.get(htmlElem)
            if (decorators) {
               this.#htmlElements.set(htmlElem,
                  decorators.filter(entry => entry !== viewDecorator)
               )
            }
         }
         /**
          * Returns information about decorators applied to an HTML element.
          * @param {HTMLElement} htmlElem Element whose decorators are to be returned.
          * @param {ViewDecorator=} decorator Optional decorator type (constructor). If undefined an array of all decorators applied to the element is returned.
          * @return {ViewDecorator[]} An array describing all applied decorators. The returned array may be empty.
          */
         get(htmlElem, decorator) {
            const decorators = this.#htmlElements.get(htmlElem) || []
            return decorator
               ? decorators.filter( entry => entry instanceof decorator )
               : decorators
         }
         /**
          * Checks if an element is decorated at all or decorated by a specific decorator.
          * @param {HTMLElement} htmlElem Element which checked for being decorated.
          * @param {Decorator=} decorator Optional decorator type (constructor) to check for. If undefined any dorator is considered.
          * @return {boolean} <tt>true</tt> if the element is decorated with provided decorator or decorated at all in case decorator is undefined.
          */
         isDecorated(htmlElem, decorator) {
            return this.get(htmlElem, decorator).length > 0
         }
         getDecoratedElements(rootElem, decorator) {
            const result = []
            if (this.isDecorated(rootElem, decorator))
               result.push(rootElem)
            for (const htmlElem of rootElem.querySelectorAll("*")) {
               if (this.isDecorated(htmlElem, decorator))
                  result.push(htmlElem)
            }
            return result
         }
         static get(htmlElem, decorator) {
            return this.singleton.get(htmlElem, decorator)
         }
         static getDecoratedElements(rootElem, decorator) {
            return this.singleton.getDecoratedElements(rootElem,decorator)
         }
      }

      //////////////////
      // TEST SECTION //
      //////////////////

      const div1 = document.getElementById("window")
      const div2 = document.getElementById("window2")
      const div3 = document.getElementById("window3")

      const win1VM = new WindowDecorator(div1, { title: "Hello 1" }).viewModel
      const win2VM = new WindowDecorator(div2, { template:"#js-window-template2", title: "Hello 2" }).viewModel
      // const win2VM = new ResizeDecorator(div2).viewModel
      const win3VM = new WindowDecorator(div3, { template:View.clone("#js-window-template"), title: "Hello 3"}).viewModel
      const win4VM = new WindowVM(View.clone("#js-window-template")).setOptions({
         top:240, left:600, width:140, height:100, title:"Hello 4",
         content: "<div style='width:100%; height:100%; background-color:beige; color:maroon;'>Created Window</div>"
      })
      new WindowDecorator(win4VM.htmlElem, { viewModel: win4VM, moveable:null/*chosen in decorator*/ })
      win4VM.vWindowState = "visible"

      const child = View.newElement("<div style='background-color:#154360; color:#eafaf1; position:fixed; width:95px; height:85px;'>Created Window</div>")
      const win5VM = new WindowDecorator(child).viewModel
      win5VM.vWindowState = "visible"

      console.log("listened elements",ViewListeners.getListenedElements(document))
      console.log("WindowDecorator decorated elements",ViewDecorators.getDecoratedElements(document,WindowDecorator))

      const winstackVM = new WindowStackVM(View.query("[class='js-window-stack']"))

      View.query("[class='js-window-stack'] button").addEventListener("click", (e) => {
         if (win1VM.vWindowState === WindowVM.CLOSED)
            (win1VM.vWindowState = WindowVM.VISIBLE, winstackVM.register(win1VM))
         else if (win2VM.vWindowState === WindowVM.CLOSED)
            (win2VM.vWindowState = WindowVM.VISIBLE, winstackVM.register(win2VM))
         else if (win3VM.vWindowState === WindowVM.CLOSED)
            (win3VM.vWindowState = WindowVM.VISIBLE, winstackVM.register(win3VM))
         else if (win4VM.vWindowState === WindowVM.CLOSED)
            (win4VM.vWindowState = WindowVM.VISIBLE, winstackVM.register(win4VM))
      })

      winstackVM.register(win1VM)
      winstackVM.register(win2VM)
      winstackVM.register(win3VM)
      winstackVM.register(win4VM)
      winstackVM.register(win5VM)

      const deco1 = ViewDecorators.get(win1VM.htmlElem, WindowDecorator)[0]
      const deco2 = ViewDecorators.get(win2VM.htmlElem, WindowDecorator)[0]
      const deco3 = ViewDecorators.get(win3VM.htmlElem, WindowDecorator)[0]
      const deco4 = ViewDecorators.get(win4VM.htmlElem, WindowDecorator)[0]
      const deco5 = ViewDecorators.get(win5VM.htmlElem, WindowDecorator)[0]

      logError(devicePixelRatio+"dppx")

      function test() {
         console.log("win3VM.vWindowState=",win3VM.vWindowState)
         //win3VM.vWindowState="hidden"
         //win3VM.vWindowState="maximized"
         //win3VM.vWindowState="visible"
         win3VM.vWindowState="maximized"
         setTimeout( () => {
            win3VM.vWindowState="visible"
            setTimeout( () => {
               win3VM.vWindowState="minimized"
               setTimeout( () => {
                  win3VM.vWindowState="visible"
               }, 130)
            }, 30)
         }, 100)
      }

      function test2() {
         const oldPos = win3VM.visiblePos
         console.log("old win3VM.visiblePos", oldPos)
         win3VM.visiblePos = { width:500, height:300, top:50, left:50, transition:true }
         setTimeout( () => {
            win3VM.visiblePos = oldPos
         }, 600)
      }

      let redecorationCount = 0
      function test3() {
         deco2.undecorate()
         setTimeout( () => {
            deco2.decorate(div2, {viewModel:win2VM, title:`Hello 2-(${++redecorationCount})`})
            win2VM.vTop -= 10+redecorationCount
         }, 800)
      }

      const dropzone = View.query(".dropzone")
      const scrollDown = () => new ViewUpdateListener( () => {
                                    dropzone.scrollBy({top:1000, behavior:"smooth"})
                                 }, 1)
      function do_upload_image(file) {
         if (!file.type.startsWith("image/")) {
            dropzone.innerHTML += `<br>Failed: unexpected type »${file.type}«`
            scrollDown()
         }
         else {
            const fr = new FileReader()
            fr.readAsDataURL(file)
            fr.addEventListener("loadend", (e) => {
               if (fr.error)
                  dropzone.innerHTML += `<br>error reading file »${file.name}«`
               else {
                  dropzone.innerHTML += `<br>try uploading <img src='${fr.result}' width="30px">`
                  upload_file(file).then(result => {
                     dropzone.innerHTML += `<br>${result.ok?'':'Failed: '}${result.answer||result.error?.message}`
                     scrollDown()
                  })
               }
               scrollDown()
            })
         }
      }

      var dc1 = new DropController(dropzone, (e) => {
         console.log(e.type,"target",e.target,"items",e.items)
         const items = [...e.items]
         switch (e.type) {
            case "dropstart":
               const allowed = items.every(item => item.kind == "file" && item.type.startsWith("image/"))
               e.target.classList.add(allowed ? "dropallowed" : "dropforbidden")
               break
            case "dropend":
               e.target.classList.remove("dropallowed","dropforbidden")
               break
            case "drop":
               const wrongItems = items.filter(item => item.kind != "file" || !item.type.startsWith("image/"))
               if (wrongItems.length)
                  dropzone.innerHTML += `<br>Failed: unexpected type »${wrongItems[0].kind!=='file' && wrongItems[0].kind || wrongItems[0].type}«`
               else
                  do_upload_image(items[0].getAsFile())
               scrollDown()
               break
         }
      })

      function upload_file(file) {
         const result = { ok:false, status:0, answer:"", error:null }
         return fetch(`http://${window.location.hostname}:9090/uploads/${file.name}`, {
            method:"PUT",
            mode:"cors",
            headers: {
               "Content-Type": file.type
            },
            body:file,
         }).then( resp => { result.ok = resp.ok; result.status = resp.status;
            logError("response"); return resp.text()
         }).then( answer => { result.answer = answer; return result
         }).catch( error => {
            result.ok = false; result.error = error; return result
         })
      }

      const fileinput = View.newElement("<input type=file hidden>")
      dropzone.append(fileinput)
      new ClickController(dropzone, () => fileinput.click())
      fileinput.addEventListener("change", (e) => {
         if (fileinput.files?.length) {
            do_upload_image(fileinput.files[0])
            fileinput.value = ""
         }
      })

   </script>

</body>
</html>