<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Test Resize</title>
   <link rel="stylesheet" href="icons/bootstrap-icons.min.css">
   <link href="bootstrap/bootstrap.css" integrity="sha384-qAlWxD5RDF+aEdUc1Z7GR/tE4zYjX1Igo/LrIexlnzM6G63a6F1fXZWpZKSrSW86" rel="stylesheet" crossorigin="anonymous">
   <script src="bootstrap/bootstrap.bundle.js" integrity="sha384-5xO2n1cyGKAe630nacBqFQxWoXjUIkhoc/FxQrWM07EIZ3TuqkAsusDeyPDOIeid" crossorigin="anonymous"></script>
   <script src="test.js"></script>
   <style>
      .vmx-window {
         --border-color: #333;
         background-color: black; color: white;
         border-radius: 12px 12px 0 0; border: 1px var(--border-color) solid;
         box-sizing: border-box; position: fixed;
         display: grid; grid-template-rows: auto 1fr;
      }
      .vmx-window .head {
         flex: 0 0 auto;
         box-sizing: border-box;
         border-bottom: 1px var(--border-color) solid;
         display: flex; flex-flow: row nowrap;
         overflow: hidden;
      }
      .vmx-window .body {
         flex: 1 1 auto;
         background-color: lightcoral;
         box-sizing: border-box;
         overflow: hidden; contain: layout;
         display: grid; place-items: stretch;
      }
      .vmx-window .head .controls {
         flex: 0 0 auto; align-self: center; order: 2;
         padding: 3px 5px 3px 3px;
      }
      .vmx-window .head .title {
         flex: 1 1 auto; align-self: stretch; order: 1;
         border-radius: 12px 0 0 0; padding: 3px 0px 3px 10px;
         box-sizing: border-box; overflow: hidden; white-space: nowrap;
      }
      .vmx-window .controls :is([data-slot='min'], [data-slot='max'], [data-slot='close']) {
         margin-left: 0.5em; padding: 2px 3px;
         box-sizing: border-box;
         width: 1em;
         cursor: pointer;
      }
      .vmx-window .controls :is([data-slot='min']:hover, [data-slot='max']:hover, [data-slot='close']:hover) {
         padding-left: 4px; padding-right: 2px;
         background-color: lightslategray;
      }
      .vmx-window .controls [data-slot='close']:hover {
         background-color: lightcoral;
      }
      .vmx-window.maximized .controls [data-slot='max']::before {
         text-decoration: underline dotted;
      }

      .vmx-window-stack {
         border: 1px darkgrey solid; background-color: lemonchiffon;
         padding: 3px;
         position: fixed; left: 5px; bottom: 5px;
         display: flex; flex-flow: column-reverse nowrap; place-items: stretch; gap: 5px;
      }
      .vmx-window-stack > * {
         position: static;
      }
      .vmx-window-stack .vmx-window .title:hover {
         background-color: lightslategray;
         cursor: pointer;
      }
      .vmx-window-stack button {
         color:white; background-color:cadetblue;
         border:1px darkgoldenrod solid;
         padding:3px;
      }
      .vmx-window-stack button:hover {
         color:#fafafa;
         outline:1px darkgoldenrod solid;
         padding:4px 2px 2px 4px;
      }
      .dropzone {
         border:2px white dashed;
      }
      .dropzone.dropallowed {
         box-shadow: inset 0 0 3px 2px #33773A;
      }
      .dropzone.dropforbidden {
         box-shadow: inset 0 0 3px 2px red;
      }
   </style>
</head>
<body>
   <template id="vmx-window-template">
      <div class="vmx-window">
         <div class="head">
            <div class="title" data-slot="title"></div>
            <div class="controls"><i data-slot="min" class="bi-dash-lg"></i><i data-slot="max" class="bi-square"></i><i data-slot="close" class="bi-x-lg"></i></div>
         </div>
         <div class="body" data-slot="content"></div>
      </div>
   </template>
   <template id="vmx-minimized-template">
      <div class="vmx-window">
         <div class="head">
            <div class="title" data-slot="title"></div>
            <div class="controls"><i data-slot="close" class="bi-x-lg"></i></div>
         </div>
      </div>
   </template>
   <h3>Test Move & Resize Divs</h3>
   <dl>
      <dt>Components</dt>
      <dd>
         <ul>
            <li>TODO: Replace View/ViewModel with View2/ViewModel2.</li>
            <li>ViewElem (Encapsulates HTMLElement)</li>
            <li>View-Model (Adds state/operations/logic to View)</li>
            <li>View-Controller (Event-Listeners-Handling (no logic))</li>
            <li>ViewExtension decorates View</li>
         </ul>
      </dd>
   </dl>

   <div id=window class="dropzone" style="width:30%;height:150px;background-color:darkblue;color:white;font-size:18px;padding:18px;text-align:center;overflow:auto;box-sizing:border-box;position:relative;left:30px;">
      <div>Drop Image (for upload)</div>
      <div>call testrun()</div>
   </div>

   <div id=window2 style="position:absolute;left:440px;top:160px;width:200px;height:150px;background-color:darkviolet;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;">
      (absolute)<br>undecorate with test3()
   </div>

   <div id=window3 style="position:fixed;left:300px;top:230px;width:200px;height:150px;background-color:teal;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;">
      (fixed)<br>call test() or test2()
      <br><input type="text" value="non moveable" size="10">
   </div>

   <div class="vmx-window-stack">
      <button>Restore closed window</button>
   </div>

   <code><pre style="margin-block:8px">
      # start upload server (localhost:9090)
      > bun server.js</pre></code>
   <form id="radios">
      <input type="radio" value="-1-" name="selection-1">
      <input type="radio" value="-2-" name="selection-1">
      <input type="radio" value="-3-" name="selection-1">
      <input type="checkbox" value="-a-" name="checky-1">
      <select name="selection-2">
         <option value="">please choose</option>
         <option value="-1-">value 1</option>
         <option value="-2-">value 2</option>
         <option value="-3-">value 3</option>
      </select>
      <br><input id=MMMM type="date">
   </form>
   <div>== LOG ==</div>
   <div id="LOG"></div>
   <div style="height:1000px;"></div>

   <script>
      /////////
      // LOG //
      /////////
      let logLines = 0
      /**
       * @type {(msg:string)=>void}
       */
      const logError = (msg) => {
         ++ logLines
         const append = document.getElementById("LOG").innerHTML
         const lastindex = append.lastIndexOf("<br>:"+(logLines-15)+": ")
         const log = append.substring(Math.max(0, lastindex)) + "<br>"
                     + ":"+logLines + ": " + msg.trim().replaceAll("\n","<br>...")
         document.getElementById("LOG").innerHTML = log
      }
      const logException = (exc) => {
         console.error(exc)
         const msg = `${exc.message}\n${exc?.stack??""}`
         logError(msg)
      }
      const logCatch = (exc) => {
         logException(Error(`Catched exception: ${exc}`,{cause:exc}))
      }
      window.addEventListener("error", (e) => {
         logException(e.error)
         e.preventDefault()
      })
   </script>

   <script src="vmx.js"></script>

   <script>

      VMX.log.setLevel(Logger.DEBUG)
      VMX.log.writeLog = (level, context, message) => {
         const args = [context, VMX.log.levelName(level)+":", message]
         console.log(...args)
         logError(args.map( x => x instanceof Error ? `${x.message}\n${x?.stack??""}` : x).join(" "))
      }

      //////////////////
      // TEST SECTION //
      //////////////////

      const div1 = document.getElementById("window")
      const div2 = document.getElementById("window2")
      const div3 = document.getElementById("window3")

      const win1VM = WindowVM.create(DOM.clone("#vmx-window-template"), { content:div1, title:"Hello 1"/*, moveable:false*/ })
      const win2VM = WindowVM.create(DOM.clone("#vmx-window-template"), { content:div2, title:"Hello 2",
         left:20, width:540,
      })
      const win3VM = WindowVM.create(DOM.clone("#vmx-window-template"), { content:div3, title:"Hello 3" })
      const win4VM = WindowVM.create(DOM.clone("#vmx-window-template"), {
         top:240, left:600, width:140, height:100, title:"Hello 4",
         content: "<div style='background-color:beige; color:maroon;'>Created Window</div>"
      })
      win4VM.vWindowState = "visible"

      const child = DOM.newElement("<div style='background-color:#154360; color:#eafaf1; position:fixed; width:95px; height:85px; right:10px; bottom:150px;'>Created Window</div>")
      DOM.connect(child)
      const win5VM = WindowVM.create(DOM.clone("#vmx-window-template"), { content:child, title:"Hello 5" })
      // not needed: win5VM.vWindowState = "visible"

      console.log("listened elements",VMX.getListenedElements(document))

      const winstackVM = WindowStackVM.create(DOM.query("[class='vmx-window-stack']"), { minimizedTemplate:DOM.query("#vmx-minimized-template") })

      DOM.query("[class='vmx-window-stack'] button").addEventListener("click", (e) => {
         if (win1VM.vWindowState === WindowVM.CLOSED)
            (win1VM.vWindowState = WindowVM.VISIBLE, winstackVM.register(win1VM))
         else if (win2VM.vWindowState === WindowVM.CLOSED)
            (win2VM.vWindowState = WindowVM.VISIBLE, winstackVM.register(win2VM))
         else if (win3VM.vWindowState === WindowVM.CLOSED)
            (win3VM.vWindowState = WindowVM.VISIBLE, winstackVM.register(win3VM))
         else if (win4VM.vWindowState === WindowVM.CLOSED)
            (win4VM.vWindowState = WindowVM.VISIBLE, winstackVM.register(win4VM))
      })

      winstackVM.register(win1VM)
      winstackVM.register(win2VM)
      winstackVM.register(win3VM)
      winstackVM.register(win4VM)
      winstackVM.register(win5VM)

      const deco1 = win1VM.decorator
      const deco2 = win2VM.decorator
      const deco3 = win3VM.decorator
      const deco4 = win4VM.decorator
      const deco5 = win5VM.decorator

      logError(devicePixelRatio+"dppx")

      function test() {
         console.log("win3VM.vWindowState=",win3VM.vWindowState)
         //win3VM.vWindowState="hidden"
         //win3VM.vWindowState="maximized"
         //win3VM.vWindowState="visible"
         win3VM.vWindowState="maximized"
         setTimeout( () => {
            win3VM.vWindowState="visible"
            setTimeout( () => {
               win3VM.vWindowState="minimized"
               setTimeout( () => {
                  win3VM.vWindowState="visible"
               }, 130)
            }, 30)
         }, 100)
      }

      function test2() {
         const oldPos = win3VM.visiblePos
         console.log("old win3VM.visiblePos", oldPos)
         win3VM.visiblePos = { width:500, height:300, top:50, left:50, transition:true }
         setTimeout( () => {
            win3VM.visiblePos = oldPos
         }, 600)
      }

      let redecorationCount = 0
      function test3() {
         if (win2VM.replaceWithContent() !== div2)
            throw Error("content is not div2")
         setTimeout( () => {
            win2VM.vContent = div2
            win2VM.vTitle = `Hello 2-(${++redecorationCount})`
         }, 800)
      }

      const dropzone = DOM.query(".dropzone")
      const scrollDown = () => new ViewUpdateListener(1, () => dropzone.scrollBy({top:1000, behavior:"smooth"}))
      function do_upload_image(file) {
         if (!file.type.startsWith("image/")) {
            dropzone.innerHTML += `<br>Failed: unexpected type »${file.type}«`
            scrollDown()
         }
         else {
            const fr = new FileReader()
            fr.readAsDataURL(file)
            fr.addEventListener("loadend", (e) => {
               if (fr.error)
                  dropzone.innerHTML += `<br>error reading file »${file.name}«`
               else {
                  dropzone.innerHTML += `<br>try uploading <img src='${fr.result}' width="40px">`
                  upload_file(file).then(result => {
                     console.log("set result",result.ok,result.answer)
                     dropzone.innerHTML += `<br>${result.ok?'':'Failed: '}${result.answer}`
                     scrollDown()
                  })
               }
               scrollDown()
            })
         }
      }

      var dc1 = new DropController(dropzone, (e) => {
         console.log(e.type,"currentTarget",e.eventCurrentTarget,"items",e.items)
         const target = e.eventCurrentTarget
         const items = [...e.items]
         switch (e.type) {
            case "dropstart":
               const allowed = items.every(item => item.kind == "file" && item.type.startsWith("image/"))
               target.classList.add(allowed ? "dropallowed" : "dropforbidden")
               break
            case "dropend":
               target.classList.remove("dropallowed","dropforbidden")
               break
            case "drop":
               const wrongItems = items.filter(item => item.kind != "file" || !item.type.startsWith("image/"))
               if (wrongItems.length)
                  dropzone.innerHTML += `<br>Failed: unexpected type »${wrongItems[0].kind!=='file' && wrongItems[0].kind || wrongItems[0].type}«`
               else
                  do_upload_image(items[0].getAsFile())
               scrollDown()
               break
         }
      })

      function upload_file(file) {
         const result = { ok:false, status:0, answer:"" }
         return fetch(`http://${window.location.hostname}:9090/uploads/${file.name}`, {
               method:"PUT",
               credentials:"include",
               mode:"cors",
               headers:{ "Content-Type": file.type },
               body:file,
         }).then( resp => {
            result.ok = resp.ok; result.status = resp.status; return resp.text()
         }).then( answer => {
            result.answer = answer
            return result
         }).catch( error => {
            logCatch(error)
            return { ok:false, status:result.status, answer:error }
         })
      }

      const fileinput = DOM.newElement("<input type='file' hidden>")
      dropzone.append(fileinput)
      new ClickController(dropzone, (e) => {
         console.log("dropzone click",e.eventCurrentTarget,e)
         if (e.eventTarget!==fileinput) {
            console.log("fileinput click")
            fileinput.click()
            console.log("after fileinput click")
         }
      })
      fileinput.addEventListener("change", (e) => {
         if (fileinput.files?.length) {
            do_upload_image(fileinput.files[0])
            fileinput.value = ""
         }
      })

      function testrun() {

         async function test_window(vm) {

            await RUN_TEST({name:"No-Transition",timeout:100}, () => {
               let callbackCalled = false
               new TransitionController(document.body, (e) => {
                  TEST(e.type,'=',"transitionend", "all transition end as string")
                  TEST(e.isTransition,'=',false, "all transition end as flag")
                  TEST(e.eventTarget,'=',null, "target points to null if no transition is active")
                  TEST(e.eventCurrentTarget,'=',document.body, "currentTarget points to element listener is registered for")
                  callbackCalled = true
               }).ensureInTransitionElseEnd()
               TEST(callbackCalled,'=',true, "ensureInTransitionElseEnd calls callback if no transition is running")
            })

            await RUN_TEST({name:"vLeft does not change during transition",timeout:1000}, async (context) => {
               vm.vWindowState = "visible"
               await vm.onceOnTransitionEnd()
               TEST(vm.vWindowState,'=',"visible", "wrong precondition: window not in state 'visible'")
               const visibleLeft = vm.vLeft
               vm.vWindowState = "minimized"
               TEST(vm.htmlElem.getAnimations().length,'=',0, "transition not yet started")
               let onceCalled = 0
               await SUB_TEST({context, delay:300}, (context) => {
                  const minimizedLeft = vm.vLeft
                  vm.vWindowState = "visible"
                  TEST(vm.vLeft,'=',minimizedLeft, "transition not yet started")
                  vm.onceOnTransitionEnd(() => {
                     TEST(vm.vLeft,'=',visibleLeft, "vLeft same at end of transition")
                  })
                  vm.onceOnViewUpdate(2, () => {
                     TEST(vm.vLeft,'=',visibleLeft, "vLeft same at start of transition")
                     TEST(parseFloat(vm.view.getComputedStyle().left),'range',[minimizedLeft+1,visibleLeft-1], "left is animated during tansition")
                     ++ onceCalled
                  })
                  SUB_TEST({context}, async () => await vm.onceOnTransitionEnd())
               })
               TEST(onceCalled,'=',1, "onceOnViewUpdate called exactly once")
            })

            await RUN_TEST({name:"vLeft == 0 if window maximized",timeout:1000}, (context) => {
               const left = vm.vLeft
               TEST(left,'>',1, "wrong precondition: vLeft not greater 1")
               vm.vWindowState = "maximized"
               vm.onceOnTransitionEnd(() => {
                  TEST(vm.vLeft,'=',0, "vLeft == 0 in maximized state")
               })
               vm.onceOnViewUpdate(4, () => {
                  TEST(vm.vLeft,'=',0, "vLeft == 0 at start of transition into maximized state")
                  TEST(parseFloat(vm.view.getComputedStyle().left),'range',[1,left-1], "left is animated during tansition")
               })
               SUB_TEST({context}, async () => await vm.onceOnTransitionEnd())
            })

            // TODO: add more tests

            END_TEST()
         }

         test_window(win1VM)
      }
   </script>

   <script>
      //////////////////////////
      // Debug Control Center //
      //////////////////////////
      class ControlCenter {
         #log
         #panel
         #viewsList
         static WindowAdapter = class WindowAdapter extends WindowVM {
            #overwittenClose
            close() { this.#overwittenClose() }
            // TODO: add overwritesupport to !!! ViewModel !!!
            init({overwiteClose, ...initOptions}) {
               this.#overwittenClose = overwiteClose
               return super.init(initOptions)
            }
         }
         constructor() {
            const log = {}
            log.htmlElem = ControlCenter.createLogWindowElement()
            log.winVM = ControlCenter.WindowAdapter.create(log.htmlElem, { overwiteClose:this.hideLogWindow.bind(this) })
            log.winVM.show()
            log.width = log.winVM.vWidth
            this.#log = log
            const panel = {}
            panel.htmlElem = ControlCenter.createPanelElement()
            panel.logWindowCheckbox = panel.htmlElem.querySelector("[data-slot=LogWindowCheckbox]")
            panel.winVM = ControlCenter.WindowAdapter.create(panel.htmlElem, { overwiteClose:this.hidePanel.bind(this) })
            panel.winVM.show()
            panel.top = panel.winVM.vTop
            panel.onEscape = new KeyController(document, (e) => {
               // (e.type === KeyController.KEYDOWN) && console.log(e) // TODO: remove line
               if (e.key === KeyController.KEYS.ESCAPE && e.type === KeyController.KEYDOWN) {
                  if (KeyController.lockKeyFromEvent(e)) {
                     this.togglePanel()
                  }
               }
            })
            panel.onLogSwitch = new ChangeController(panel.logWindowCheckbox, (e) => {
               this.switchLogWindow(e.checked)
            })
            this.#panel = panel
         }
         get log() {
            return this.#log
         }
         get panel() {
            return this.#panel
         }
         get isLogWindowHidden() {
            return this.log.winVM.hidden
         }
         get viewsList() {
            return this.#viewsList
         }
         showLogWindow() {
            if (this.isLogWindowHidden) {
               this.log.winVM.show()
               this.log.winVM.visiblePos = {transition:true, width:this.log.width}
               this.panel.logWindowCheckbox.checked = true
            }
         }
         hideLogWindow() {
            if (!this.isLogWindowHidden) {
               this.log.width = this.log.winVM.vWidth
               this.log.winVM.visiblePos = {transition:true, width:0}
               this.panel.logWindowCheckbox.checked = false
               this.log.winVM.onceOnTransitionEnd( () => this.log.winVM.hide())
            }
         }
         switchLogWindow(switchOn) {
            switchOn ? this.showLogWindow() : this.hideLogWindow()
         }

         get hiddenPanel() {
            return this.panel.winVM.hidden
         }
         showPanel() {
            if (this.hiddenPanel) {
               this.panel.winVM.show()
               this.panel.winVM.visiblePos = {transition:true, top:this.panel.top}
            }
         }
         hidePanel() {
            if (!this.hiddenPanel) {
               this.panel.top = Math.max(0,this.panel.winVM.vTop)
               this.panel.winVM.visiblePos = {transition:true, top:-this.panel.winVM.vHeight-30}
               this.panel.winVM.onceOnTransitionEnd( () => this.panel.winVM.hide())
            }
         }
         togglePanel() {
            this.hiddenPanel ? this.showPanel() : this.hidePanel()
         }

         unhighlight() {
            const table = this.viewsList
            if (table.lastHighlighted.viewModel) {
               table.lastHighlighted.viewModel.view.setStyles(table.lastHighlighted.oldStyle)
               table.lastHighlighted.viewModel = null
            }
         }
         endEditName(e, abort) {
            const table = this.viewsList
            const row = e ? e.eventTarget.closest("tr") : table.edits[0]?.row
            if (!row || row.parentElement.nodeName !== "TBODY") return
            const editIndex = table.edits.findIndex(edit => edit.row === row)
            if (editIndex >= 0) {
               const edit = table.edits.splice(editIndex,1)[0]
               document.createDocumentFragment().append(...edit.col.children)
               document.createDocumentFragment().append(...edit.col2.children)
               edit.col.append(edit.colchilds)
               edit.col2.append(edit.col2childs)
               for (const ctrl in edit.controller)
                  edit.controller[ctrl].free()
               if (!abort) {
                  // TODO: does no more work, edit.viewModel.name = edit.input.value.trim()
                  edit.col.querySelector("label").textContent = edit.viewModel.LID.toString(edit.viewModel)
               }
               this.unhighlight()
            }
         }

         ID=1

         openViewsList() {
            this.closeViewsList()
            const table = this.#viewsList = {}
            table.edits = []
            table.lastHighlighted = {}
            table.htmlElem = this.createViewsListElement()
            table.winVM = ControlCenter.WindowAdapter.create(table.htmlElem, { overwiteClose:this.closeViewsList.bind(this) })
            table.winVM.show()
            table.htmlElem.addEventListener("focusin", (e) => {
                     console.log("focusin",e)
                  })
            table.htmlElem.addEventListener("focusout", (e) => {
                     console.log("focusout",e)
                  })
            table.onTouch = new TouchController(table.htmlElem, (e) => {
               const viewmodels = this.viewsList.viewmodels
               const row = e.eventTarget.closest("tr")
               logError("touch "+e.type+":"+e.eventTarget?.nodeName+","+e.eventTarget.id+","+e.eventCurrentTarget?.nodeName)
               e.type === TouchController.TOUCHEND && this.unhighlight()
               if (!row || row.parentElement.nodeName !== "TBODY") return
               const rowOffset = row.sectionRowIndex
               if (! (0 <= rowOffset && rowOffset < viewmodels.length)) return
               if (e.type === TouchController.DOUBLECLICK && row && row !== table.edits[0]?.row) {
                  this.endEditName(null)
                  const col = row.children[0]
                  const input = DOM.newElement("<input type=text class='w-100'>")
                  const cancel = DOM.newElement("<a class='btn btn-warning'>cancel <i class='bi bi-trash'></i></a>")
                  const controller = {}
                  const edit = { input, cancel, row, col, col2: col.nextElementSibling,
                                 colchilds: document.createDocumentFragment(),
                                 col2childs: document.createDocumentFragment(),
                                 viewModel: viewmodels[rowOffset], controller }
                  edit.colchilds.append(...col.childNodes)
                  edit.col2childs.append(...edit.col2.childNodes)
                  input.id = "inp-"+(this.ID++)
                  // input.value = edit.viewModel.name
                  col.append(input)
                  edit.col2.append(cancel)
                  controller.onKey = new KeyController(input, (e) => {
                     console.log(e.type, e.key, KeyController.KEYS.ENTER)
                     if (e.type === KeyController.KEYDOWN && (e.key === KeyController.KEYS.ESCAPE || e.key === KeyController.KEYS.ENTER)
                        && KeyController.lockKeyFromEvent(e))
                        this.endEditName(e, e.key === KeyController.KEYS.ESCAPE)
                  })
                  controller.onCancel = new ClickController(cancel, (e) => {
                     this.endEditName(e, true)
                  })
                  table.winVM.onceOnViewUpdate(1, () => {
                     input.focus()
                     input.value = edit.viewModel.name
                     input.setSelectionRange(input.value.length,input.value.length)
                  })
                  table.edits.push(edit)
               }
               if (e.type === TouchController.TOUCHSTART && !table.lastHighlighted.viewModel) {
                  const vm = viewmodels[rowOffset]
                  table.lastHighlighted.viewModel = vm
                  table.lastHighlighted.oldStyle = vm.view.setStyles({
                     outline: "#FF9D77 dashed 3px", outlineOffset: 0
                  })
               }
            }, {enableDoubleClick:true})
         }
         closeViewsList() {
            const table = this.viewsList
            if (table) {
               this.endEditName()
               table.onTouch.free()
               table.winVM.free().remove()
            }
            this.#viewsList = null
         }


         static createLogWindowElement() {
            const logID = DOM.nextUnusedID("LogWindow")
            return DOM.newElement(`
               <div id="${logID}" style="position:fixed; width:50%; top:0; right:0;">
                  <div class="card overflow-hidden" style="height:100%">
                     <div class="card-header">
                        <span data-slot="title">Log Window</span> <tt><small><small>(TODO: implement)</small></small></tt>
                        <button type="button" class="btn-close float-end" aria-label="Close" data-slot="close"></button>
                     </div>
                     <div class="card-body overflow-y-scroll" data-slot="content">
                        <table class="table">
                           <thead>
                              <tr><th>nr&nbsp;</th><th>ms</th><th>name</th><th>msg</th></tr>
                           </thead>
                           <tbody>
                              <tr><td>1.</td><td>1234567</td><td>Log-Window</td><td>Shown</td></tr>
                           </tbody>
                        </table>
                     </div>
                  </div>
               </div>`
            )
         }

         static createPanelElement() {
            const panelID = DOM.nextUnusedID("ControlPanel")
            return DOM.newElement(`
               <div id="${panelID}" class="toast show position-fixed" style="top:0; left:0;" role="alert" aria-live="assertive" aria-atomic="true">
                  <div class="toast-header">
                     <div class="rounded me-2 bg-secondary bg-gradient" style="width:1.3em">&nbsp;</div>
                     <strong class="me-auto" data-slot="title">Control Center</strong>
                     <small>Toggle with ESC</small>
                     <button type="button" class="btn-close" aria-label="Close" data-slot="close"></button>
                  </div>
                  <div class="toast-body" data-slot="content">
                     This is under construction!
                     <div class="form-check form-switch"><small><label class="form-check-label"><input class="form-check-input" type="checkbox" value="" checked data-slot="LogWindowCheckbox">Log Window</label></small></div>
                  </div>
               </div>`
            )
         }

         createViewsListElement() {
            const tableID = DOM.nextUnusedID("ViewsList")
            let rows = ""
            this.viewsList.viewmodels = []
            let id=6
            for (const vm of VMX.getConnectedViewModels()) {
               const decorator = vm.decorator
               rows += "<tr><td style='cursor:initial' id='"+(++id)+"'><label>"+vm.LID.toString(vm)+"</label></td>"
               rows += "<td id='"+(++id)+"'>"+(decorator?decorator.constructor.name:'&mdash;')+"</td>"
               rows += "<td id='"+(++id)+"'>"+vm.constructor.name+"</td>"
               rows += "<td id='"+(++id)+"'>"+(vm.vTitle
                                 ? vm.vTitle.substring(0,15)
                                 : "") + "</td></tr>"
               this.viewsList.viewmodels.push(vm)
            }
            const bStyle = getComputedStyle(document.body)
            return DOM.newElement(`
               <div id="${tableID}" style="position:fixed; height:50%; width:50%; top:20px; left:${parseFloat(bStyle.width)/4}px;">
                  <div class="card overflow-hidden" style="height:100%">
                     <div class="card-header" data-slot="move">
                        <span data-slot="title">Decorated Elements <tt><small><small>(try pressing / dbl-clicking row)</small></small></tt></span>
                        <button type="button" class="btn-close float-end" aria-label="Close" data-slot="close"></button>
                     </div>
                     <div class="card-body overflow-y-scroll" data-slot="content" >
                        <table class="table table-striped table-hover align-middle">
                           <thead>
                              <tr><th><i class='bi bi-pencil-square'></i> Name</th><th>Decorator</th><th>VModel</th><th>Info</th></tr>
                           </thead>
                           <tbody>
                              ${rows}
                           </tbody>
                        </table>
                     </div>
                  </div>
               </div>`
            )
         }

      }

      const ccCenter = new ControlCenter()
      ccCenter.openViewsList()
      const viewsList=ccCenter.viewsList.winVM.htmlElem

      ////////////
      // TODOs: //
      ////////////

      // 1. assign IDs to every element
      // 2. write logs into log-window
      // 10. Create ViewListener and add it to ViewListeners instead of
      //     providing all arguments to Addlistener which pipes
      //     them through to constructor of ViewListener
      //     10.1 Adding same eventhandler encapsulated in different ViewListener more than once
      //          => calling same handler more than once (nothing to do)
      //          => handler must call preventmultiple(handlerfunction) to ensure single exec
      // X. overlapping Escape key handling

      new ChangeController(document.getElementById("radios"), (e) => {
         console.log("change form",e.checked,e)
      })
      new ChangeController(document.getElementById("radios"), (e) => {
         console.log("change group (radio buttons in form radios)",e.checked,e)
      }, { group: document.getElementById("radios").querySelectorAll("[type=radio]") })

      function logEvent(e) {
         console.log("event",new Date().valueOf(),ViewListener.eventToString(e),e)
      }

      document.addEventListener(ViewListener.KEYDOWN,logEvent)
      // document.addEventListener(ViewListener.KEYUP,logEvent)

      async function testOptionsParser() {
         const parse = OptionsParser.parse
         RUN_TEST({name:"parse-empty",timeout:100}, (context) => {
            TEST(parse(``),"{=}",{},"Expect empty object")
            TEST(parse(`{}`),"{=}",{},"Expect empty object")
            TEST(parse(`\t   \t\t `),"{=}",{},"Expect empty object")
            TEST(parse(` \t\t {\t \t} \t\t `),"{=}",{},"Expect empty object")
         })
         RUN_TEST({name:"parse-boolean",timeout:100}, () => {
            TEST(parse(`v:true`).v,"=",true,"Expect true value")
            TEST(parse(`v:false`).v,"=",false,"Expect false value")
         })
         RUN_TEST({name:"parse-string",timeout:100}, () => {
            TEST(parse(`v:'string'`).v,"=","string","Expect string value")
            TEST(parse(`v:"\\1234\\"`).v,"=","\\1234\\","Expect string value")
            TEST(parse(`v:''''`).v,"=","'","Doubling enclosing character removes special meaning")
            TEST(parse(`v:""""""`).v,"=",'""',"Doubling enclosing character removes special meaning")
            TEST(()=>parse(`v:"`),"throw",new Error(`OptionsParser error: expect »"« instead of »end of input« after name »v«.\ninput=v:"`),"Unclosed string")
            TEST(()=>parse(`v:'`),"throw",new Error(`OptionsParser error: expect »'« instead of »end of input« after name »v«.\ninput=v:'`),"Unclosed string")
         })
         RUN_TEST({name:"parse-number",timeout:100}, () => {
            TEST(parse(`v:123`).v,"=",123,"Expect number 123")
            TEST(parse(`v:-1.87`).v,"=",-1.87,"Expect number -1.87")
            TEST(parse(`v:+12.3e5`).v,"=",1.23e6,"Expect number -1.23e6")
            TEST(parse(`v:-9.22e+30`).v,"=",-9.22e30,"Expect number -9.22e+30")
            TEST(()=>parse(`v:-1.3e`),"throw",Error,"Missing exponent")
         })
         RUN_TEST({name:"parse-array",timeout:100}, () => {
            TEST(parse(`v:[]`).v,"[=]",[],"Expect empty array")
            TEST(parse(` v  :  [  ]  `).v,"[=]",[],"Expect empty array")
            TEST(parse(`v:[ 1 ,   ]`).v,"[=]",[1],"Expect array with one element")
            TEST(parse(`v:[ 1, true, 'xy', {} ]`).v,"[=]",[1,true,"xy",{}],"Expect array with 3 elements")
         })
         RUN_TEST({name:"parse-object",timeout:100}, () => {
            TEST(parse(`a : 1 , b : false, c3po: 'gold', r2d2: { x: -30, y: +40 }`),"{=}",{a:1,b:false,c3po:"gold",r2d2:{x:-30,y:40}},"Expect object with 4 elements")
         })
         await END_TEST()
      }
      const win2FrameContainer = win2VM.htmlElem.parentElement
      let xvm, xvv
      function xxx() {
         let win2Frame = win2VM.htmlElem
         while (win2Frame.parentElement !== win2FrameContainer) win2Frame = win2Frame.parentElement;
         const content=new ViewElem(win2Frame)
         const vm=new WindowVM2()
         const vv=new WindowView(ViewElem.query("#vmx-window-template").clone(), vm)
         if (false) {
            if (false) {
               vv.viewElem.setPos({width:300, height:120, top:10, left:0})
               vv.viewElem.connect()
               vv.init({content:ViewElem.fromHtml("<div>Hello</div>")})
            }
            else {
               vv.init({content, reframe:true})
            }
            return
         }
         const connection = {
            locks: {
               click: { path:[["click"]], shared:true },
               resize: { path:[["resize"]], notlocked:"click" },
               resizeTop: { path:[["resize"],["top"]], notlocked:"click" },
               resizeTopRight: { path:[["resize"],["top","right"]], notlocked:"click" },
               resizeRight: { path:[["resize"],["right"]], notlocked:"click" },
               resizeRightBottom: { path:[["resize"],["right","bottom"]], notlocked:"click" },
               resizeBottom: { path:[["resize"],["bottom"]], notlocked:"click" },
               resizeBottomLeft: { path:[["resize"],["bottom","left"]], notlocked:"click" },
               resizeLeft: { path:[["resize"],["left"]], notlocked:"click" },
               resizeLeftTop: { path:[["resize"],["left","top"]], notlocked:"click" },
            },
            // view-controller event (e) --> view-model method (mapArgs(e))
            actions: {
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               move: { method:"move", lock:"resize", mapArgs:(e) => ({ dx:e.dx, dy:e.dy }) },
               /** @type {{method:string, lock:string, mapArgs:(TouchResizeControllerEvent)=>any)}} */
               resize: { method:"resize", lock:"resize", mapArgs:(e) => ({ dtop:e.dy, dright:e.dx, dbottom:e.dy, dleft:e.dx }) },
               /** @type {{method:string, lock:string, mapArgs:(TouchResizeControllerEvent)=>any)}} */
               resizeNotMoveable: { method:"resize", lock:"resize", mapArgs:(e) => ({ dright:2*e.dx, dbottom:2*e.dy }) },
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               resizeTop: { method:"resize", lock:"resizeTop", mapArgs:(e) => ({ dtop:-e.dy }) },
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               resizeTopRight: { method:"resize", lock:"resizeTopRight", mapArgs:(e) => ({ dtop:-e.dy, dright:e.dx }) },
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               resizeRight: { method:"resize", lock:"resizeRight", mapArgs:(e) => ({ dright:e.dx }) },
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               resizeRightBottom: { method:"resize", lock:"resizeRightBottom", mapArgs:(e) => ({ dright:e.dx, dbottom:e.dy }) },
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               resizeBottom: { method:"resize", lock:"resizeBottom", mapArgs:(e) => ({ dbottom:e.dy }) },
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               resizeBottomLeft: { method:"resize", lock:"resizeBottomLeft", mapArgs:(e) => ({ dbottom:e.dy, dleft:-e.dx }) },
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               resizeLeft: { method:"resize", lock:"resizeLeft", mapArgs:(e) => ({ dleft:-e.dx }) },
               /** @type {{method:string, lock:string, mapArgs:(MoveControllerEvent)=>any)}} */
               resizeLeftTop: { method:"resize", lock:"resizeLeftTop", mapArgs:(e) => ({ dleft:-e.dx, dtop:-e.dy }) },
               /** @type {{method:string, lock:string, mapArgs:(ClickControllerEvent)=>any)}} */
               close: { method:"close", lock:"click", mapArgs:(e) => (undefined) },
               /** @type {{method:string, lock:string, mapArgs:(ClickControllerEvent)=>any)}} */
               minimize: { method:"minimize", lock:"click", mapArgs:(e) => (undefined) },
               /** @type {{method:string, lock:string, mapArgs:(ClickControllerEvent)=>any)}} */
               toggleMaximize: { method:"toggleMaximize", lock:"click", mapArgs:(e) => (undefined) },
            },
            properties: [
               { init:"vm", view:"hidden", vm:"windowState", mapToVM:(isHidden)=>isHidden?"hidden":"visible" },
               { update:"both", init:"vm", view:"pos", vm:"pos", mapToVM:null, mapToView:null },
               { update:"view", view:"windowState", vm:"windowState", mapToView:null },
            ],
            // restrictions are transfered from view to view-model during init once to adapt vm to view imposed restrictions
            restrictions: [
               { view:"moveable", vm:"moveable", mapToVM:null },
               { view:"resizeable", vm:"resizeable", mapToVM:null }
            ],
         }
         vv.init({content, controls:true, reframe:true, resizeable:true, moveable:true, connection, viewModel:vm})

         setTimeout( () => {
            vv.viewElem.startTransition(true, () => vv.pos = {top:0,left:0})
         }, 10)
         setTimeout( () => {
            vv.viewElem.startTransition(false, () => {
               vv.pos = {top:200,left:0}
            })
         }, 1000)
         xvm = vm, xvv = vv
         return { vm, vv }
      }

      function xx() {
         const type = "keydown"
         document.addEventListener(type,(e) => {
            console.log("document click",e)
         })
         window.addEventListener(type,(e) => {
            console.log("window click",e)
         })
         win3VM.htmlElem.addEventListener(type,(e) => {
            console.log("win3 click",e)
            queueMicrotask(()=>console.log("win3 microtask"))
         })
         document.body.addEventListener(type,(e) => {
            console.log("body click",e)
         })
      }

      setTimeout(xxx,1000)
</script>
</body>
</html>