<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Test Resize</title>
   <style>
   </style>
</head>
<body>
   <h3>Test Move & Resize Divs</h3>
   <div id="LOG"></div>
   <dl>
      <dt>Components</dt>
      <dd>
         <ul>
            <li>View</li>
            <li>View-Model</li>
            <li>View-Controller</li>
            <li>ResizeDecorator</li>
         </ul>
      </dd>
      <dt>Missing Features</dt>
      <dd>
         <ul>
            <li>Window decorations</li>
            <li>All things Model and Data-Binding to View-Model</li>
            <li>Data types for model properties</li>
         </ul>
      </dd>
   </dl>

   <div id=window style="width:150px;height:150px;background-color:darkblue;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box">
      Resize div<br>(static)
   </div>

   <div id=window2 style="position:absolute;left:440px;top:160px;width:150px;height:150px;background-color:darkviolet;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;z-index:1;">
      Move or resize div<br>(absolute)
   </div>

   <div id=window3 style="position:fixed;left:300px;top:230px;width:150px;height:150px;background-color:teal;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;z-index:1;">
      Move or resize div<br>(fixed)
   </div>

   <div style="height:1000px;"></div>

   <script>
      const div1 = document.getElementById("window")
      const div2 = document.getElementById("window2")
      const div3 = document.getElementById("window3")
      let logLines = 0
      const logError = (msg) => {
         ++ logLines
         let append = document.getElementById("LOG").innerHTML
         if (logLines > 15) {
            append = append.substring(0,append.lastIndexOf("<br>"))
            if (logLines === 1000)
               logLines=100
         }
         document.getElementById("LOG").innerHTML = logLines + " " + msg + "<br>" + append
      }

      /**
       * Function which decorates the provided HTML element with additional functionality
       * and uses the provided {@link ViewModel} to manage its state.
       * @callback Decorator
       * @param {HTMLElement} htmlElem - The HTML element which is decorated.
       * @param {ViewModel} viewModel - The {@link ViewModel} which manages all view state and updates the view if state changes occur.
       * @return {object} State information about what decorator has changed (useful for unding all changes).
       */

      /**
       * Description of applied decorator to an HTML element.
       * @typedef {object} AppliedDecorator
       * @property {Decorator} decorator - The applied decorator function.
       * @property {object} decoratorState - State information returned by the {@link Decorator} function.
       * @property {HTMLElement} htmlElem - The HTML element which serves as root view.
       * @property {ViewModel} viewModel - The {@link ViewModel} which manages whole view state and is bound to root view or its sub views.
       */

      /** Description fo added listener to an HTML element.
       * @typedef {object} AddedListener
       * @property {(e:Event)=>void} eventHandler - Registered callback which handles event type for an html element.
       * @property {string} eventType - The event type ("click","touchstart",...).
       * @property {HTMLElement} htmlElem - The HTML element which for which the event handler is registered.
       * @property {bigint} ID - Unique number which identifies the added event listener.
       * @property {AddedListener[]} blockedListeners - An array of listeners which have lower priority and are suppressed if this listeners is also executed.
       */

      class Listener {
         /////////////
         // Options //
         /////////////
         static TARGET_ONLY = true
      }

      /**
       * Manages event listeners and allows to prioritize them.
       * One listener could block one or more other listeners.
       * So if two listeners would be executed, and one is blocked by the other
       * only one is executed. Higher priority of a listener is expresses by
       * blocking the one with lower priority.
       */
      const htmlListeners = {
         htmlElements: new WeakMap(),
         uniqueID: 0n,
         bubbleEvent: null,
         captureEvent: null,
         blockedListeners: null,
         capturedTargets: null,
         TARGET_ONLY: false,
         continuePropagation: false,
         onCaptureBind: null,
         onBubbleBind: null,
         error(msg) {
            throw Error(`htmlListener error: ${msg}`)
         },
         onCapture(e) {
            if (!this.captureEvent) {
               this.captureEvent = e
               this.bubbleEvent = null
               this.blockedListeners = new Set()
               this.capturedTargets = new WeakSet()
               this.TARGET_ONLY = false
               this.continuePropagation = true
            }
            else if (e !== this.captureEvent)
               this.error("Internal: Event loop processes two capture events at same time.")
            if (this.capturedTargets.has(e.currentTarget)) {
               console.warn("Internal: onCapture called with same target more than once.")
            }
            else {
               this.capturedTargets.add(e.currentTarget)
               const listeners = this.get(e.currentTarget,e.type)
               for (const listener of listeners) {
                  for (const blockedListener of listener.blockedListeners) {
                     this.blockedListeners.add(blockedListener)
                  }
                  if (listener.TARGET_ONLY) {
                     if (e.target === listener.htmlElem)
                        this.TARGET_ONLY = true
                     else
                        this.blockedListeners.add(listener)
                  }
               }
            }
         },
         onBubble(e) {
            if (!this.bubbleEvent) {
               this.bubbleEvent = e
               this.captureEvent = null
            }
            else if (e !== this.bubbleEvent)
               this.error("Internal: Event loop processes two bubble events at same time.")
            if (  this.continuePropagation
               && this.capturedTargets.has(e.currentTarget)
               && (!this.TARGET_ONLY || e.currentTarget === e.target)) {
               this.capturedTargets.delete(e.currentTarget)
               const listeners = this.get(e.currentTarget,e.type)
               for (const listener of listeners) {
                  if (!this.blockedListeners.has(listener)) {
                     listener.eventHandler(e)
                     if (!this.continuePropagation)
                        break;
                  }
               }
            }
         },
         addListener(htmlElem, eventType, eventHandler, options={}) {
            const blockedListeners = options.blockedListeners || []
            const TARGET_ONLY = Boolean(options.TARGET_ONLY)
            const eventTypes = this.htmlElements.get(htmlElem) || {}
            const map = eventTypes[eventType] || new Map()
            if (!map.has(eventHandler)) {
               const listener = { htmlElem, eventType, eventHandler, ID: ++this.uniqueID, blockedListeners, TARGET_ONLY }
               if (map.size === 0) {
                  this.onCaptureBind ??= this.onCapture.bind(this)
                  this.onBubbleBind ??= this.onBubble.bind(this)
                  listener.htmlElem.addEventListener(listener.eventType,this.onCaptureBind,{capture:true,passive:false})
                  listener.htmlElem.addEventListener(listener.eventType,this.onBubbleBind,{capture:false,passive:false})
                  if (!this.htmlElements.has(htmlElem))
                     this.htmlElements.set(htmlElem,eventTypes)
                  eventTypes[eventType] = map
               }
               map.set(eventHandler,listener)
               return listener
            }
         },
         removeListener(listener) {
            const eventTypes = this.htmlElements.get(listener.htmlElem)
            const map = eventTypes && eventTypes[listener.eventType]
            if (map && map.size > 0) {
               map.delete(listener.eventHandler)
               if (map.size === 0) {
                  listener.htmlElem.removeEventListener(listener.eventType,this.onCaptureBind,{capture:true,passive:false})
                  listener.htmlElem.removeEventListener(listener.eventType,this.onBubbleBind,{capture:false,passive:false})
               }
            }
         },
         stopImmediatePropagation() {
            this.continuePropagation = false
         },
         /**
          * Returns iterator of all matching listeners.
          * @param {HTMLElement} htmlElem The HTML element whose listeners are queried.
          * @param {string=} eventType Optional type of the event the listener must match else listeners with any event type are matched.
          * @param {(e:Event)=>void} eventHandler Optional event handler function the listener must match else all listeners with any event handler are matched.
          */
         get(htmlElem, eventType, eventHandler) {
            const eventTypes = this.htmlElements.get(htmlElem)
            if (!eventTypes)
               return [].values()
            if (eventType)
               if (eventHandler)
                  return eventTypes[eventType] && eventTypes[eventType].get(eventHandler)
                     ? [eventTypes[eventType].get(eventHandler)].values()
                     : [].values()
               else
                  return (eventTypes[eventType] || []).values()
            return (function*() {
               for (const key in eventTypes) {
                  const map = eventTypes[key]
                  if (map) {
                     if (!eventHandler)
                        yield* map.values()
                     const listener = map.get(eventHandler)
                     if (listener)
                        yield listener
                  }
               }
            })()
         },
         isListener(htmlElem, eventType, eventHandler) {
            return !this.get(htmlElem,eventType,eventHandler).next().done
         },
         getListenedElements(rootElem, eventType, eventHandler) {
            const result = []
            if (this.isListener(rootElem,eventType,eventHandler))
               result.push(rootElem)
            for (const htmlElem of rootElem.querySelectorAll("*")) {
               if (this.isListener(htmlElem,eventType,eventHandler))
                  result.push(htmlElem)
            }
            return result
         },
      }
      function addListener(htmlElem, eventType, eventHandler, options) {
         return htmlListeners.addListener(htmlElem, eventType, eventHandler, options)
      }
      function removeListeners(...listeners) {
         listeners.forEach( listener => listener && htmlListeners.removeListener(listener))
      }
      function stopImmediatePropagation() {
         htmlListeners.stopImmediatePropagation()
      }

      /**
       * Maps an HTML element to array of applied decorators.
       */
      const htmlDecorators = {
         htmlElements: new WeakMap(),
         error(msg) {
            throw Error(`htmlDecorators error: ${msg}`)
         },
         /**
          * Applies decorator by calling it and adds it to list of applied docorators for htmlElem.
          * @param {HTMLElement} htmlElem
          * @param {Decorator} decorator
          * @param {ViewModel} viewModel
          */
         decorate(htmlElem, decorator, viewModel) {
            if (!(htmlElem instanceof HTMLElement)) this.error("htmlElem argument expects type HTMLElement.")
            if (!(decorator instanceof Function)) this.error("decorator argument expects type Function.")
            if (!(viewModel instanceof ViewModel)) this.error("viewModel argument expects type ViewModel.")
            if (!this.isDecorated(htmlElem, decorator)) {
               const decoratorState = decorator(htmlElem, viewModel)
               const newDecorator = { decorator, decoratorState, htmlElem, viewModel }
               this.htmlElements.set(htmlElem,
                  (this.htmlElements.get(htmlElem) || []).concat(newDecorator)
               )
               if (!viewModel.isBound())
                  viewModel.bindView(htmlElem)
               return newDecorator
            }
         },
         /**
          * Returns information about decorators applied to an HTML element.
          * @param {HTMLElement} htmlElem Element whose decorators are to be returned.
          * @param {Decorator=} decorator Optional decorator to return information about a single decorator. If undefined an array of all decorators applied to the element is returned.
          * @return {AppliedDecorator[]} An array describing all applied decorators. The returned array may be empty.
          */
         get(htmlElem, decorator) {
            const decorators = this.htmlElements.get(htmlElem) || []
            return decorator
               ? decorators.filter( entry => entry.decorator === decorator )
               : decorators
         },
         /**
          * Checks if an element is decorated at all or decorated by a specific decorator.
          * @param {HTMLElement} htmlElem Element which checked for being decorated.
          * @param {Decorator=} decorator Optional decorator to check for. If undefined any dorator is considered.
          * @return {boolean} <tt>true</tt> if the element is decorated with provided decorator or decorated at all in case decorator is undefined.
          */
         isDecorated(htmlElem, decorator) {
            return this.get(htmlElem, decorator).length > 0
         },
         /**
          * Returns view model of a single decorator.
          * @param {HTMLElement} htmlElem Element which checked for being decorated.
          * @param {Decorator} decorator Decorator whose state should be returned. Value is not optional.
          * @return {object|undefined} Returned state of applied decorator or undefined if decorator was not applied to given element.
          */
         getDecoratorState(htmlElem, decorator) {
            return this.get(htmlElem, decorator)[0]?.decoratorState
         },
         /**
          * Returns view model of a single decorator.
          * @param {HTMLElement} htmlElem Element which checked for being decorated.
          * @param {Decorator} decorator Decorator whose view model should be returned. Value is not optional.
          * @return {ViewModel|undefined} ViewModel of applied decorator or undefined if decorator was not applied to given element.
          */
         getDecoratorViewModel(htmlElem, decorator) {
            return this.get(htmlElem, decorator)[0]?.viewModel
         },
         getDecoratedElements(rootElem, decorator) {
            const result = []
            if (this.isDecorated(rootElem, decorator))
               result.push(rootElem)
            for (const htmlElem of rootElem.querySelectorAll("*")) {
               if (this.isDecorated(htmlElem, decorator))
                  result.push(htmlElem)
            }
            return result
         },
      }
      function decorateElement(htmlElem, decorator, viewModel) {
         return htmlDecorators.decorate(htmlElem, decorator, viewModel)
      }
      const UIupdates = {
         callbacks: [],
         frameID: null,
         oldTimestamp: null,
         milliseconds: 0,
         loop(timestamp) {
            const callbacks = this.callbacks
            const oldTimestamp = this.oldTimestamp || timestamp
            this.callbacks = []
            this.frameID = null
            this.oldTimestamp = timestamp
            this.milliseconds += timestamp-oldTimestamp
            for (const callback of callbacks)
               callback(this.milliseconds)
         },
         add(callback) {
            this.callbacks.push(callback)
            if (this.frameID == null)
               this.frameID = requestAnimationFrame(this.loop.bind(this))
         }
      }
      function asyncUIUpdate(callback) {
         UIupdates.add(callback)
      }

      // implement controller blocking other controller
      class ViewController {
         #inhibitedControllers=[]
         #isActionCallback=true
         #actionCallback
         constructor() {
         }
         getInhibitedControllers() {
            return this.#inhibitedControllers
         }
         setInhibitedControllers(inhibitedControllers) {
            this.#inhibitedControllers = inhibitedControllers
         }
         get isActionCallback() {
            return this.#isActionCallback
         }
         callAction(e) {
            if (this.#isActionCallback)
               this.#actionCallback(e)
         }
         inhibitControllers(turnInhibitionOn) {
            const isActionCallback = !turnInhibitionOn
            for (const ic of this.#inhibitedControllers) {
               ic.#isActionCallback = isActionCallback
            }
         }
         getTouchById(touches, id) {
            for (const t of (touches||[]))
               if (t.identifier === id)
                  return t
         }
         getStartListenersFrom(controllers) {
            return controllers.flatMap(bc => bc.startListeners)
         }
         removeListeners(listenersArray) {
            removeListeners(...listenersArray)
            listenersArray.length = 0
         }
         /////////////////////////////
         // overwritten in subclass //
         /////////////////////////////
         get startListeners() {
            return []
         }
         add(htmlElem, actionCallback, ...inhibitedControllers) {
            this.remove()
            this.#actionCallback = actionCallback
            this.setInhibitedControllers(inhibitedControllers)
            return this
         }
         remove() {
            return this
         }
      }

      class MoveController extends ViewController {
         #startListeners = []
         #listeners = []
         #pos

         debug = 0

         constructor(htmlElem, moveCallback, ...inhibitedControllers) {
            super()
            return this.add(htmlElem, moveCallback, ...inhibitedControllers)
         }

         get startListeners() {
            return this.#startListeners
         }

         add(htmlElem, moveCallback, ...inhibitedControllers) {
            super.add(htmlElem, moveCallback, ...inhibitedControllers)
            this.#startListeners = [
               addListener(htmlElem,"mousedown",this.onStart.bind(this),{TARGET_ONLY:true}),
               addListener(htmlElem,"touchstart",this.onStart.bind(this),{TARGET_ONLY:true}),
            ]
            return this
         }

         remove() {
            if (this.#listeners.length)
               this.onEnd()
            if (this.#startListeners.length)
               this.removeListeners(this.#startListeners)
            return this
         }

         extractXY(e) {
            return { x:e.pageX, y:e.pageY, id:e.identifier }
         }

         onStart(e) {
            if (this.debug && e.touches)
               logError(`${this.debug}: start ${e.targetTouches.length} id:${e.targetTouches.length==1?e.targetTouches[0].identifier:'?'}`)
            if (this.#listeners.length || (e.touches && e.targetTouches.length !== 1)) {
               if (e.touches && e.targetTouches.length !== 1)
                  this.inhibitControllers(false)
               return
            }
            const touch = (e.targetTouches && e.targetTouches[0])
            this.#pos = this.extractXY(touch || e)
            e.preventDefault()
            if (touch) {
               this.#listeners.push(addListener(e.target,"touchmove",this.onMove.bind(this),{TARGET_ONLY:true}))
               this.#listeners.push(addListener(e.target,"touchend",this.onEnd.bind(this),{TARGET_ONLY:true}))
               this.#listeners.push(addListener(e.target,"touchcancel",this.onEnd.bind(this)))
            }
            else {
               this.#listeners.push(addListener(document,"mousemove",this.onMove.bind(this)))
               this.#listeners.push(addListener(document,"mouseup",this.onEnd.bind(this)))
            }
            this.inhibitControllers(true)
         }

         onMove(e) {
            const touch = this.getTouchById(e.touches,this.#pos.id)
            if (e.touches && (e.targetTouches.length !== 1 || !touch))
               return
            if (this.debug && e.touches)
               logError(`${this.debug}: move ${e.targetTouches.length} id:${e.targetTouches[0].identifier} id2:${touch.identifier}`)
            e.preventDefault()
            const pos = this.extractXY(touch || e)
            const deltaxy = { dx:pos.x-this.#pos.x, dy:pos.y-this.#pos.y }
            this.#pos = pos
            this.callAction(deltaxy)
         }

         onEnd(e) {
            if (this.debug && e?.type === "touchcancel")
               logError(`${this.debug}: cancel ${e?.touches?.length} ${e?.targetTouches?.length}`)
            if (e?.targetTouches?.length > 0) {
               this.#pos = this.extractXY(e.targetTouches[0])
               if (e.targetTouches.length === 1)
                  this.inhibitControllers(true)
               return
            }
            e.preventDefault()
            this.removeListeners(this.#listeners)
            this.inhibitControllers(false)
         }
      }

      class TouchResizeController extends ViewController {
         #startListeners = []
         #listeners = []
         #pos

         constructor(htmlElem, moveCallback, ...inhibitedControllers) {
            super()
            return this.add(htmlElem, moveCallback, ...inhibitedControllers)
         }

         get startListeners() {
            return this.#startListeners
         }

         add(htmlElem, resizeCallback, ...inhibitedControllers) {
            super.add(htmlElem, resizeCallback, ...inhibitedControllers)
            this.#startListeners = [
               addListener(htmlElem,"touchstart",this.onStart.bind(this)),
            ]
            return this
         }

         remove() {
            if (this.#listeners.length)
               this.onEnd()
            if (this.#startListeners.length)
               this.removeListeners(this.#startListeners)
            return this
         }

         extractXY(e1,e2) {
            return { x:Math.abs(e1.pageX - e2.pageX), y:Math.abs(e1.pageY - e2.pageY) }
         }

         onStart(e) {
            if (this.#listeners.length || e.targetTouches?.length !== 2) {
               if (e.touches && e.targetTouches.length !== 2)
                  this.inhibitControllers(false)
               return
            }
            this.#pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
            e.preventDefault()
            this.#listeners.push(addListener(e.target,"touchmove",this.onMove.bind(this)))
            this.#listeners.push(addListener(e.target,"touchend",this.onEnd.bind(this)))
            this.#listeners.push(addListener(e.target,"touchcancel",this.onEnd.bind(this)))
            this.inhibitControllers(true)
         }

         onMove(e) {
            if (e.targetTouches.length !== 2)
               return
            e.preventDefault()
            const pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
            const deltaxy = { dx:pos.x-this.#pos.x, dy:pos.y-this.#pos.y }
            this.#pos = pos
            this.callAction(deltaxy)
         }

         onEnd(e) {
            if (e?.targetTouches?.length >= 2) {
               if (this.debug)
                  logError(`${this.debug}: end continue ${e.targetTouches.length} id:${e.targetTouches[0].identifier} ${e.targetTouches[1].identifier}`)
               if (e.targetTouches.length === 2)
                  this.inhibitControllers(true)
               this.#pos = this.extractXY(e.targetTouches[0],e.targetTouches[1])
               return
            }
            if (this.debug)
               logError(`${this.debug}: end ${e?.targetTouches?.length}`)
            this.removeListeners(this.#listeners)
            this.inhibitControllers(false)
         }
      }

      function setStyles(htmlElem, styles) {
         for (const key in styles) {
            htmlElem.style.setProperty(key,styles[key])
         }
         return htmlElem
      }
      function newDiv(styles){
         return setStyles(document.createElement("div"),styles)
      }

      function ResizeDecorator(htmlElem, viewModel) {
         const isMoveable = (["absolute","fixed"].includes(getComputedStyle(htmlElem)["position"]))
         const display = isMoveable ? "initial" : "none"
         const outerWidth = 8
         const innerWidth = 4
         const borderSize = (outerWidth+innerWidth)+"px"
         const outerSize = "-"+outerWidth+"px"
         const edgeSize = (outerWidth+3*innerWidth)+"px"
         const borders = [
            newDiv({top:outerSize, left:0, right:0, height:borderSize, cursor:"n-resize", position:"absolute", "z-index":1, display}),
            newDiv({right:outerSize, top:0, bottom:0, width:borderSize, cursor:"e-resize", position:"absolute", "z-index":1}),
            newDiv({bottom:outerSize, left:0, right:0, height:borderSize, cursor:"s-resize", position:"absolute", "z-index":1}),
            newDiv({left:outerSize, top:0, bottom:0, width:borderSize, cursor:"w-resize", position:"absolute", "z-index":1, display}),
            newDiv({top:outerSize, left:outerSize, width:edgeSize, height:edgeSize, cursor:"nw-resize", position:"absolute", "z-index":1, display}),
            newDiv({top:outerSize, right:outerSize, width:edgeSize, height:edgeSize, cursor:"ne-resize", position:"absolute", "z-index":1, display}),
            newDiv({bottom:outerSize, right:outerSize, width:edgeSize, height:edgeSize, cursor:"se-resize", position:"absolute", "z-index":1}),
            newDiv({bottom:outerSize, left:outerSize, width:edgeSize, height:edgeSize, cursor:"sw-resize", position:"absolute", "z-index":1, display}),
         ]
         htmlElem.append(...borders)
         if (isMoveable) {
            // TODO: add inhibit controller -> suppresses action but does not block events !!!
            const moveWin = new MoveController(htmlElem,viewModel.on.move)
            moveWin.debug = "movewin"
            const resizeWin = new TouchResizeController(htmlElem,viewModel.on.resize)
            resizeWin.debug = "resizewin"
            const topResize = new MoveController(borders[0],viewModel.on.resizeTop,moveWin,resizeWin)
            const rightResize = new MoveController(borders[1],viewModel.on.resizeRight,moveWin,resizeWin)
            const bottomResize = new MoveController(borders[2],viewModel.on.resizeBottom,moveWin,resizeWin)
            const leftResize = new MoveController(borders[3],viewModel.on.resizeLeft,moveWin,resizeWin)
            new MoveController(borders[4],viewModel.on.resizeTopLeft,moveWin,resizeWin,topResize,leftResize)
            new MoveController(borders[5],viewModel.on.resizeTopRight,moveWin,resizeWin,topResize,rightResize)
            new MoveController(borders[6],viewModel.on.resizeBottomRight,moveWin,resizeWin,bottomResize,rightResize)
            new MoveController(borders[7],viewModel.on.resizeBottomLeft,moveWin,resizeWin,bottomResize,leftResize)
            setStyles(htmlElem,{ cursor:"move" })
         }
         else {
            const resizeWin = new TouchResizeController(htmlElem,viewModel.on.resizeStatic)
            const rightResize = new MoveController(borders[1],viewModel.on.resizeRight, resizeWin)
            const bottomResize = new MoveController(borders[2],viewModel.on.resizeBottom, resizeWin)
            new MoveController(borders[6],viewModel.on.resizeBottomRight,bottomResize,rightResize)
         }
         setStyles(htmlElem,{ contain: "size layout" })

         return { borders, /* TODO: store controllers */ }
      }
      /**
       * Model which is bound to a single view and manages its state.
       */
      class ViewModel {
         #modelName
         #properties = {}
         #proxy
         #proxyKeepView
         #on = {}
         constructor(modelName) {
            this.#modelName = modelName
            this.#proxy = new Proxy(this, {
               get(target, p) {
                  return target.getValue(p)
               },
               set(target, p, value) {
                  return target.setValue(p, value), true
               }
            })
            this.#proxyKeepView = new Proxy(this, {
               get(target, p) {
                  return target.getValue(p)
               },
               set(target, p, value) {
                  return target.setValueKeepView(p, value), true
               }
            })
         }
         error(msg) {
            throw Error(`ViewModel-${this.#modelName} error: ${msg}`)
         }
         isProperty(name) {
            return (name in this.#properties)
         }
         isEventHandler(name) {
            return (name in this.#on)
         }
         get values() {
            return this.#proxy
         }
         get valuesKeepView() {
            return this.#proxyKeepView
         }
         get on() {
            return this.#on
         }
         /**
          * Adds new property to view model wuth default value and data Accessor mechanism.
          *
          * @param {string} name Name of view model property.
          * @param {any} value Start value assigned to property.
          * @param {ViewValueAccessor} viewvalue Implements accessing a single data value of a HTML view.
          */
         addProperty(name, value, viewvalue) {
            if (this.isProperty(name))
               this.error(`Can not add property ${String(name)} twice.`)
            this.#properties[name] = { name, value, viewvalue, htmlElem:null }
         }
         bindEventHandler(name, eventHandler, thisValue=null) {
            if (this.isEventHandler(name))
               this.error(`Can not add event handler ${String(name)} twice.`)
            this.#on[name] = eventHandler.bind(thisValue||this)
         }
         bindEventHandlers(prototype) {
            for (const name of Reflect.ownKeys(prototype))
               if (String(name).startsWith("on"))
                  this.bindEventHandler(name.substring(2,3).toLowerCase()+name.substring(3),prototype[name])
         }
         #getProperty(name) {
            const prop = this.#properties[name]
            if (!prop)
               this.error(`Missing property ${String(name)}.`)
            return prop
         }
         #bindView(prop, htmlElem) {
            if (prop.htmlElem !== htmlElem)
               return this.#properties[prop.name] = { ...prop, htmlElem }
            else
               return prop
         }
         #setValueKeepView(prop, value) {
            if (prop.value !== value)
               return this.#properties[prop.name] = { ...prop, value }
            else
               return prop
         }
         #setValue(prop, value) {
            this.#updateView(this.#setValueKeepView(prop, value))
         }
         #updateView(prop) {
            if (prop.htmlElem) {
               asyncUIUpdate(
                  () => prop.viewvalue.set(prop.htmlElem, prop.value)
               )
            }
         }
         /**
          * Binds all view model properties to a html view.
          * To sync values call either {@link ViewModel.setValuesFromView}
          * or {@link ViewModel.updateView} after this method.
          *
          * @param {HTMLElement} htmlElem The default html view all properties are bound to.
          * @param {{"propName":HTMLElement}=} propNameHtmlElemMap Oprional key value map which overwrites the default html view with a more specific subview.
          */
         bindView(htmlElem, propNameHtmlElemMap) {
            for (const name of Reflect.ownKeys(this.#properties)) {
               const prop = this.#bindView(this.#getProperty(name), (propNameHtmlElemMap && propNameHtmlElemMap[name]) || htmlElem)
               if (prop.htmlElem)
                  prop.viewvalue.bindView(prop.htmlElem)
            }
         }
         /**
          * Returns true if any property of model is bound to a HTML view.
          */
         isBound() {
            for (const name of Reflect.ownKeys(this.#properties)) {
               const prop = this.#getProperty(name)
               if (prop.htmlElem)
                  return true
            }
            return false
         }
         /**
          * Sets every property value to value read from its bound HTML view.
          * Properties which are not bound (htmlElem == null) are skipped.
          */
         setValuesFromView() {
            for (const name of Reflect.ownKeys(this.#properties))
               this.setValueFromView(name)
         }
         /**
          * Sets a single property value from to value read from its bound HTML view.
          * If no view is bound nothing is done.
          * Call this function from a bound view in case a view value has changed.
          *
          * @param {string} name Name of view model property.
          */
         setValueFromView(name) {
            const prop = this.#getProperty(name)
            if (prop.htmlElem)
               this.#setValueKeepView(prop, prop.viewvalue.get(prop.htmlElem))
         }
         /**
          * Assigns all property values to the bound HTML view.
          */
         updateView() {
            for (const name of Reflect.ownKeys(this.#properties))
               this.#updateView(this.#getProperty(name))
         }
         getValue(name, value) {
            return this.#getProperty(name).value
         }
         setValue(name, value) {
            this.#setValue(this.#getProperty(name), value)
         }
         /**
          * Sets a property value without updating the bound HTML view.
          * Call this function from a view listener in case user has input new value.
          *
          * @param {string} name Name of view model property.
          * @param {any} value Value of HTML view property.
          */
         setValueKeepView(name, value) {
            this.#setValueKeepView(this.#getProperty(name), value)
         }
         getEventHandler(name) {
            return this.#on[name]
         }
      }

      class ViewValueAccessor {
         bindView(htmlElem) { /* subtype should could overwrite to prepare view (calling needsBorderBox) */ }
         set(htmlElem, value) { throw Error("Not implemented") }
         get(htmlElem) { throw Error("Not implemented") }
         needsBorderBox(htmlElem) {
            const needValue = "border-box"
            const styleProp = "box-sizing"
            const value = getComputedStyle(htmlElem)[styleProp]
            if (value != needValue) {
               console.warn(`${this.constructor.name} needs style['${styleProp}']=='${needValue}' instead of '${value}' to work properly on html element`, htmlElem)
               htmlElem.style.setProperty(styleProp,needValue)
            }
         }
      }
      class TopStyleAccessor extends ViewValueAccessor {
         set(htmlElem, value) { htmlElem.style.top = value+"px" }
         get(htmlElem) { return htmlElem.offsetTop }
      }
      class LeftStyleAccessor extends ViewValueAccessor {
         set(htmlElem, value) { htmlElem.style.left = value+"px" }
         get(htmlElem) { return htmlElem.offsetLeft }
      }
      class WidthStyleAccessor extends ViewValueAccessor {
         bindView(htmlElem) { this.needsBorderBox(htmlElem) }
         set(htmlElem, value) { htmlElem.style.width = value+"px" }
         get(htmlElem) { return htmlElem.offsetWidth }
      }
      class HeightStyleAccessor extends ViewValueAccessor {
         bindView(htmlElem) { this.needsBorderBox(htmlElem) }
         set(htmlElem, value) { htmlElem.style.height = value+"px" }
         get(htmlElem) { return htmlElem.offsetHeight }
      }

      class WindowResizeVM extends ViewModel {
         constructor({top=0, left=0, width=100, height=100}={}) {
            super("WindowResize")
            this.addProperty("top", top, new TopStyleAccessor())
            this.addProperty("left", left, new LeftStyleAccessor())
            this.addProperty("width", width, new WidthStyleAccessor())
            this.addProperty("height", height, new HeightStyleAccessor())
            this.bindEventHandlers(WindowResizeVM.prototype)
         }

         move(deltax,deltay) { this.values.left += deltax; this.values.top += deltay; }
         resizeTop(deltay) { this.values.top -= deltay; this.values.height += deltay; }
         resizeRight(deltax) { this.values.width += deltax; }
         resizeBottom(deltay) { this.values.height += deltay; }
         resizeLeft(deltax) { this.values.left -= deltax; this.values.width += deltax; }
         resizeTopLeft(deltax,deltay) { this.resizeLeft(deltax); this.resizeTop(deltay); }
         resizeTopRight(deltax,deltay) { this.resizeRight(deltax); this.resizeTop(deltay); }
         resizeBottomRight(deltax,deltay) { this.resizeRight(deltax); this.resizeBottom(deltay); }
         resizeBottomLeft(deltax,deltay) { this.resizeLeft(deltax); this.resizeBottom(deltay); }
         resize(deltax,deltay) { this.resizeRight(deltax); this.resizeBottom(deltay); this.resizeLeft(deltax); this.resizeTop(deltay); }
         resizeStatic(deltax,deltay) { this.resizeRight(2*deltax); this.resizeBottom(2*deltay); }

         // event handler starts with on

         onMove(e) { this.move(e.dx,e.dy) }
         onResizeTop(e) { this.resizeTop(-e.dy) }
         onResizeRight(e) { this.resizeRight(e.dx) }
         onResizeBottom(e) { this.resizeBottom(e.dy) }
         onResizeLeft(e) { this.resizeLeft(-e.dx) }
         onResizeTopLeft(e) { this.resizeLeft(-e.dx); this.resizeTop(-e.dy); }
         onResizeTopRight(e) { this.resizeRight(e.dx); this.resizeTop(-e.dy); }
         onResizeBottomRight(e) { this.resizeRight(e.dx); this.resizeBottom(e.dy); }
         onResizeBottomLeft(e) { this.resizeLeft(-e.dx); this.resizeBottom(e.dy); }
         onResize(e) { this.resize(e.dx,e.dy) }
         onResizeStatic(e) { this.resizeStatic(e.dx,e.dy) }
      }

      decorateElement(div1, ResizeDecorator, new WindowResizeVM()).viewModel.setValuesFromView()
      decorateElement(div2, ResizeDecorator, new WindowResizeVM()).viewModel.setValuesFromView()
      decorateElement(div3, ResizeDecorator, new WindowResizeVM()).viewModel.setValuesFromView()
      var vm3 = htmlDecorators.getDecoratorViewModel(div3,ResizeDecorator)
      window.addEventListener("error", (e) => logError("line "+e.lineno+":"+e.message))

      console.log(htmlListeners.getListenedElements(document))
   </script>
</body>
</html>
