<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Test Resize</title>
   <style>
   </style>
</head>
<body style="">
   <h3>Test Move & Resize Divs</h3>
   <div id="LOG">error log:</div>
   <dl>
      <dt>Components</dt>
      <dd>
         <ul>
            <li>View</li>
            <li>View-Model</li>
            <li>Controller</li>
            <li>ResizeDecorator</li>
         </ul>
      </dd>
      <dt>Missing Features</dt>
      <dd>
         <ul>
            <li>Window decorations</li>
            <li>Model and Data-Binding to View-Model</li>
            <li>Data types for model properties</li>
         </ul>
      </dd>
   </dl>

   <div id=window style="width:150px;height:150px;background-color:darkblue;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box">
      Resize div<br>(static)
   </div>

   <div id=window2 style="position:absolute;left:440px;top:160px;width:150px;height:150px;background-color:darkviolet;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;z-index:1;">
      Move or resize div<br>(absolute)
   </div>

   <div id=window3 style="position:fixed;left:300px;top:230px;width:150px;height:150px;background-color:teal;color:white;font-size:18px;padding:18px;text-align:center;overflow:visible;box-sizing:border-box;z-index:1;">
      Move or resize div<br>(fixed)
   </div>

   <div style="height:1000px;"></div>

   <script>
      const div1 = document.getElementById("window")
      const div2 = document.getElementById("window2")
      const div3 = document.getElementById("window3")
      const logError = (msg) => {
         document.getElementById("LOG").innerHTML += msg
      }
      const htmlDecorators = {
         htmlElements: new WeakMap(),
         get(htmlElem, decorator) {
            const decorators = this.htmlElements.get(htmlElem)
            return decorators && decorator
               ? decorators.find( entry => entry.decorator === decorator )
               : decorators
         },
         isElementDecorated(htmlElem, decorator) {
            return Boolean(this.get(htmlElem, decorator))
         },
         getDecoratedElements(rootElem, decorator) {
            const result = []
            if (isElementDecorated(rootElem, decorator))
               result.push(rootElem)
            for (const htmlElem of rootElem.querySelectorAll("*")) {
               if (isElementDecorated(htmlElem, decorator))
                  result.push(htmlElem)
            }
         },
         decorate(htmlElem, decorator, viewModel) {
            if (!this.isElementDecorated(htmlElem, decorator)) {
               const decoratorState = decorator(htmlElem, viewModel)
               const addedDecorator = { decorator, decoratorState, htmlElem, viewModel }
               this.htmlElements.set(htmlElem,
                  (this.htmlElements.get(htmlElem) || []).concat(addedDecorator)
               )
               if (!viewModel.isBound())
                  viewModel.bindToView(htmlElem)
            }
            return this.get(htmlElem, decorator)
         }
      }
      function decorateElement(htmlElem, decorator, viewModel) {
         return htmlDecorators.decorate(htmlElem, decorator, viewModel)
      }
      const UIupdates = {
         callbacks: [],
         frameID: null,
         oldTimestamp: null,
         milliseconds: 0,
         loop(timestamp) {
            const callbacks = this.callbacks
            const oldTimestamp = this.oldTimestamp || timestamp
            this.callbacks = []
            this.frameID = null
            this.oldTimestamp = timestamp
            this.milliseconds += timestamp-oldTimestamp
            for (const callback of callbacks)
               callback(this.milliseconds)
         },
         add(callback) {
            this.callbacks.push(callback)
            if (this.frameID == null)
               this.frameID = requestAnimationFrame(this.loop.bind(this))
         }
      }
      function asyncUIUpdate(callback) {
         UIupdates.add(callback)
      }

      function setStyles(htmlElem, styles) {
         for (const key in styles) {
            htmlElem.style.setProperty(key,styles[key])
         }
         return htmlElem
      }
      function newDiv(styles){
         return setStyles(document.createElement("div"),styles)
      }
      function addMoveController(htmlElem, onMove) {
         const onMousedown = (e) => {
            const touch = (e.touches && e.touches[0])
            if (touch && e.touches.length !== 1)
               return
            const event = touch || e
            const abortController = new AbortController()
            const removeSignal = abortController.signal
            const removeListener = abortController.abort.bind(abortController)
            let prevPos = { x:event.pageX, y:event.pageY }
            e.stopPropagation()
            e.preventDefault()
            const onMouseMove = (e) => {
               const touch = (e.touches && e.touches[0])
               if (touch && e.touches.length !== 1) {
                  removeListener()
                  return
               }
               const event = touch || e
               const pos = { x:event.pageX, y:event.pageY }
               const xydiff = { xdiff:pos.x-prevPos.x, ydiff:pos.y-prevPos.y }
               prevPos = pos
               onMove({type:"move", target:htmlElem, ...xydiff})
            }
            const onMouseUp = (e) => {
               removeListener()
            }
            if (touch) {
               window.addEventListener("touchmove",onMouseMove,{capture:true, passive:false, signal:removeSignal})
               window.addEventListener("touchend",onMouseUp,{capture:true, passive:false, signal:removeSignal})
            }
            else {
               window.addEventListener("mousemove",onMouseMove,{capture:true, passive:false, signal:removeSignal})
               window.addEventListener("mouseup",onMouseUp,{capture:true, passive:false, signal:removeSignal})
            }
         }
         htmlElem.addEventListener("mousedown",onMousedown,{capture:false,passive:false})
         htmlElem.addEventListener("touchstart",onMousedown,{capture:false,passive:false})
      }
      function addTouchResizeController(htmlElem, onResize) {
         const onTouchStart = (e) => {
            const touches = e.targetTouches
            if (touches.length !== 2 || !touches[0] || !touches[1])
               return
            const abortController = new AbortController()
            const removeSignal = abortController.signal
            const removeListener = abortController.abort.bind(abortController)
            let prevPos = { x:Math.abs(touches[0].pageX - touches[1].pageX), y:Math.abs(touches[0].pageY - touches[1].pageY) }
            e.stopPropagation()
            e.preventDefault()

            const onTouchMove = (e) => {
               const touches = e.targetTouches
               if (touches.length !== 2 || !touches[0] || !touches[1]) {
                  removeListener()
                  return
               }
               const pos = { x: Math.abs(touches[0].pageX - touches[1].pageX), y:Math.abs(touches[0].pageY - touches[1].pageY) }
               const xydiff = { xdiff:pos.x-prevPos.x, ydiff:pos.y-prevPos.y }
               prevPos = pos
               onResize({type:"touchresize", target:htmlElem, ...xydiff})
            }
            const onTouchEnd = (e) => {
               removeListener()
            }
            window.addEventListener("touchmove",onTouchMove,{capture:true, passive:false, signal:removeSignal})
            window.addEventListener("touchend",onTouchEnd,{capture:true, passive:false, signal:removeSignal})
         }
         htmlElem.addEventListener("touchstart",onTouchStart,{capture:false,passive:false})
      }

      function ResizeDecorator(htmlElem, viewModel) {
         const display =
            (["absolute","fixed"].includes(getComputedStyle(htmlElem)["position"]))
            ? "initial"
            : "none"
         const outerWidth = 6
         const innerWidth = 4
         const borderSize = (outerWidth+innerWidth)+"px"
         const outerSize = "-"+outerWidth+"px"
         const edgeSize = (outerWidth+3*innerWidth)+"px"
         const borders = [
            newDiv({top:outerSize, left:0, right:0, height:borderSize, cursor:"n-resize", position:"absolute", "z-index":1, display}),
            newDiv({right:outerSize, top:0, bottom:0, width:borderSize, cursor:"e-resize", position:"absolute", "z-index":1}),
            newDiv({bottom:outerSize, left:0, right:0, height:borderSize, cursor:"s-resize", position:"absolute", "z-index":1}),
            newDiv({left:outerSize, top:0, bottom:0, width:borderSize, cursor:"w-resize", position:"absolute", "z-index":1, display}),
            newDiv({top:outerSize, left:outerSize, width:edgeSize, height:edgeSize, cursor:"nw-resize", position:"absolute", "z-index":1, display}),
            newDiv({top:outerSize, right:outerSize, width:edgeSize, height:edgeSize, cursor:"ne-resize", position:"absolute", "z-index":1, display}),
            newDiv({bottom:outerSize, right:outerSize, width:edgeSize, height:edgeSize, cursor:"se-resize", position:"absolute", "z-index":1}),
            newDiv({bottom:outerSize, left:outerSize, width:edgeSize, height:edgeSize, cursor:"sw-resize", position:"absolute", "z-index":1, display}),
         ]
         htmlElem.append(...borders)
         const resizeTop = (e) => { viewModel.addValue("top", e.ydiff); viewModel.addValue("height", -e.ydiff); }
         const resizeRight = (e) => { viewModel.addValue("width", e.xdiff); }
         const resizeBottom = (e) => { viewModel.addValue("height", e.ydiff); }
         const resizeLeft = (e) => { viewModel.addValue("left", e.xdiff); viewModel.addValue("width", -e.xdiff); }
         addMoveController(borders[1],resizeRight)
         addMoveController(borders[2],resizeBottom)
         addMoveController(borders[6],(e) => { resizeBottom(e); resizeRight(e); })
         if (display !== "none") {
            addMoveController(borders[0],resizeTop)
            addMoveController(borders[3],resizeLeft)
            addMoveController(borders[4],(e) => { resizeTop(e); resizeLeft(e); })
            addMoveController(borders[5],(e) => { resizeTop(e); resizeRight(e); })
            addMoveController(borders[7],(e) => { resizeBottom(e); resizeLeft(e); })
            addMoveController(htmlElem,(e) => { viewModel.addValue("top", e.ydiff); viewModel.addValue("left", e.xdiff); })
            addTouchResizeController(htmlElem,(e) => { resizeRight(e); resizeBottom(e); e.xdiff*=-1; e.ydiff*=-1; resizeTop(e); resizeLeft(e); })
            setStyles(htmlElem,{ cursor:"move" })
         }
         else
            addTouchResizeController(htmlElem,(e) => { e.xdiff*=2; e.ydiff*=2; resizeRight(e); resizeBottom(e); })
         setStyles(htmlElem,{ contain: "size layout" })
         return { borders }
      }
      class ViewModel {
         #modelName
         #properties = {}
         constructor(modelName) {
            this.#modelName = modelName
         }
         error(msg) {
            throw Error(`View model ${this.#modelName} error: ${msg}`)
         }
         isProperty(name) {
            return (name in this.#properties)
         }
         /**
          * Adds new property to view model wuth default value and data Accessor mechanism.
          *
          * @param {string} name Name of view model property.
          * @param {any} value Start value assigned to property.
          * @param {ViewValueAccessor} viewvalue Implements accessing a single data value of a HTML view.
          */
         addProperty(name, value, viewvalue) {
            if (this.isProperty(name))
               this.error(`Can not add property ${String(name)} twice.`)
            this.#properties[name] = { name, value, viewvalue, htmlElem:null }
         }
         #getProperty(name) {
            const prop = this.#properties[name]
            if (!prop)
               this.error(`Missing property ${String(name)}.`)
            return prop
         }
         #setPropertyView(prop, htmlElem) {
            if (prop.htmlElem !== htmlElem)
               return this.#properties[prop.name] = { ...prop, htmlElem }
            else
               return prop
         }
         #setPropertyValue(prop, value) {
            if (prop.value !== value)
               return this.#properties[prop.name] = { ...prop, value }
            else
               return prop
         }
         #setPropertyValueWithUpdate(prop, value) {
            this.#updatePropertyView(this.#setPropertyValue(prop, value))
         }
         #updatePropertyView(prop) {
            if (prop.htmlElem) {
               asyncUIUpdate(
                  () => prop.viewvalue.set(prop.htmlElem, prop.value)
               )
            }
         }
         /**
          * Binds all view model properties to a html view.
          * To sync values call either {@link ViewModel.setValuesFromView}
          * or {@link ViewModel.updateView} after this method.
          *
          * @param {HTMLElement} htmlElem The default html view all properties are bound to.
          * @param {{"propName":HTMLElement}=} propNameHtmlElemMap Oprional key value map which overwrites the default html view with a more specific subview.
          */
         bindToView(htmlElem, propNameHtmlElemMap) {
            for (const name of Reflect.ownKeys(this.#properties)) {
               const prop = this.#setPropertyView(this.#getProperty(name), (propNameHtmlElemMap && propNameHtmlElemMap[name]) || htmlElem)
               if (prop.htmlElem)
                  prop.viewvalue.bindToView(prop.htmlElem)
            }
         }
         /**
          * Returns true if any property of model is bound to a HTML view.
          */
         isBound() {
            for (const name of Reflect.ownKeys(this.#properties)) {
               const prop = this.#getProperty(name)
               if (prop.htmlElem)
                  return true
            }
            return false
         }
         /**
          * Sets every property value to value read from its bound HTML view.
          * Properties which are not bound (htmlElem == null) are skipped.
          */
         setValuesFromView() {
            for (const name of Reflect.ownKeys(this.#properties))
               this.setValueFromView(name)
         }
         /**
          * Sets a single property value from to value read from its bound HTML view.
          * If no view is bound nothing is done.
          * Call this function from a bound view in case a view value has changed.
          *
          * @param {string} name Name of view model property.
          */
         setValueFromView(name) {
            const prop = this.#getProperty(name)
            if (prop.htmlElem)
               this.#setPropertyValue(prop, prop.viewvalue.get(prop.htmlElem))
         }
         /**
          * Assigns all property values to the bound HTML view.
          */
         updateView() {
            for (const name of Reflect.ownKeys(this.#properties))
               this.#updatePropertyView(this.#getProperty(name))
         }
         getValue(name, value) {
            return this.#getProperty(name).value
         }
         setValue(name, value) {
            this.#setPropertyValueWithUpdate(this.#getProperty(name), value)
         }
         addValue(name, increment) {
            const prop = this.#getProperty(name)
            this.#setPropertyValueWithUpdate(prop, prop.value+increment)
         }
         /**
          * Sets a property value without updating the bound HTML view.
          * Call this function from a view listener in case user has input new value.
          *
          * @param {string} name Name of view model property.
          * @param {any} value Value of HTML view property.
          */
         setValueNoUpdate(name, value) {
            this.#setPropertyValue(this.#getProperty(name), value)
         }
      }

      class ViewValueAccessor {
         bindToView(htmlElem) { /* subtype should could overwrite to prepare view (calling needsBorderBox) */ }
         set(htmlElem, value) { throw Error("Not implemented") }
         get(htmlElem) { throw Error("Not implemented") }
         needsBorderBox(htmlElem) {
            const needValue = "border-box"
            const styleProp = "box-sizing"
            const value = getComputedStyle(htmlElem)[styleProp]
            if (value != needValue) {
               console.warn(`${this.constructor.name} needs style['${styleProp}']=='${needValue}' instead of '${value}' to work properly on html element`, htmlElem)
               htmlElem.style.setProperty(styleProp,needValue)
            }
         }
      }
      class TopStyleAccessor extends ViewValueAccessor {
         set(htmlElem, value) { htmlElem.style.top = value+"px" }
         get(htmlElem) { return htmlElem.offsetTop }
      }
      class LeftStyleAccessor extends ViewValueAccessor {
         set(htmlElem, value) { htmlElem.style.left = value+"px" }
         get(htmlElem) { return htmlElem.offsetLeft }
      }
      class WidthStyleAccessor extends ViewValueAccessor {
         bindToView(htmlElem) { this.needsBorderBox(htmlElem) }
         set(htmlElem, value) { htmlElem.style.width = value+"px" }
         get(htmlElem) { return htmlElem.offsetWidth }
      }
      class HeightStyleAccessor extends ViewValueAccessor {
         bindToView(htmlElem) { this.needsBorderBox(htmlElem) }
         set(htmlElem, value) { htmlElem.style.height = value+"px" }
         get(htmlElem) { return htmlElem.offsetHeight }
      }

      function newWindowResizeViewModel() {
         const vmWindowResize = new ViewModel("WindowResize")
         vmWindowResize.addProperty("top", 0, new TopStyleAccessor())
         vmWindowResize.addProperty("left", 0, new LeftStyleAccessor())
         vmWindowResize.addProperty("width", 100, new WidthStyleAccessor())
         vmWindowResize.addProperty("height", 100, new HeightStyleAccessor())
         return vmWindowResize
      }
      decorateElement(div1, ResizeDecorator, newWindowResizeViewModel()).viewModel.setValuesFromView()
      decorateElement(div2, ResizeDecorator, newWindowResizeViewModel()).viewModel.setValuesFromView()
      decorateElement(div3, ResizeDecorator, newWindowResizeViewModel()).viewModel.setValuesFromView()
      window.addEventListener("error", (e) => logError("<br>line "+e.lineno+":"+e.message))
   </script>
</body>
</html>
