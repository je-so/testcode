/* title: Core-Interrupt

   Gibt Zugriff auf auf Cortex-M4 (STM32F303xC spezifisch) Prozessor Peripherie:

      o Nested Vectored Interrupt Controller (NVIC) – Exceptions und Interrupts
      o Extended interrupts and events controller (EXTI) - Anbindung Peripherie, etwa GPIO, an NVIC

   Copyright:
   This program is free software. See accompanying LICENSE file.

   Author:
   (C) 2016 Jörg Seebohn

   file: µC/interrupt.h
    Header file <Core-Interrupt>.

   file: TODO: µC/interrupt.c
    Implementation file <Core-Interrupt impl>.
*/
#ifndef STM32F303xC_MC_INTERRUPT_HEADER
#define STM32F303xC_MC_INTERRUPT_HEADER

// == exported Peripherals/HW-Units
#define hNVIC    ((core_nvic_t*) HW_REGISTER_BASEADDR_NVIC)

// == exported types

// TODO: remove after gpio changed
typedef enum interrupt_edge_e {
   interrupt_edge_FALLING = 1,
   interrupt_edge_RISING = 2,
} interrupt_edge_e;

typedef enum interrupt_priority_e {
   interrupt_priority_HIGH = 0,
   interrupt_priority_MID  = (1u << HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS) / 2,
   interrupt_priority_LOW  = (1u << HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS) - 1,
} interrupt_priority_e;

#define interrupt_priority__NROF (1u << HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS)

typedef enum coreinterrupt_e {
   coreinterrupt_RESET = 1, // hard coded Priority: -3 (highest possible); Power-On-Reset or Software Reset
   coreinterrupt_NMI   = 2, // hard coded Priority: -2 ; Non maskable interrupt.
   coreinterrupt_FAULT = 3, // hard coded Priority: -1 ; All cases of faults, called if other fault handlers disabled
   coreinterrupt_MPUFAULT = 4, // Settable Priority: 0; default disabled; Memory Error.
   coreinterrupt_BUSFAULT = 5, // Settable Priority: 0; default disabled; Pre-fetch Fault, illegal address.
   coreinterrupt_USAGEFAULT = 6, // Settable Priority: 0; default disabled; Undefined Instruction or Illegal State.
   coreinterrupt_SVCALL  = 11, // Settable Priority: 0; Generated by Execution of Supervisor Call: SVC{cond} #imm
   coreinterrupt_DEBUGMONITOR = 12, // Settable Priority: 0; Cortex-M4 Debug Monitor.
   coreinterrupt_PENDSV  = 14, // Settable Priority: 0; Pendable request for system service.
   coreinterrupt_SYSTICK = 15, // Settable Priority: 0; System tick timer.
} coreinterrupt_e;

typedef enum interrupt_e {
   interrupt_WWDG = 16, // Window Watchdog interrupt
   interrupt_PVD  = 17, // PVD through EXTI line 16 detection interrupt
   interrupt_GPIOPIN0 = 22, // EXTI Line0 interrupt (Pin 0 of PortA - PortH)
   interrupt_GPIOPIN1 = 23, // EXTI Line1 interrupt (Pin 1 of PortA - PortH)
   interrupt_GPIOPIN2_TSC = 24, // EXTI Line2 and Touch sensing interrupts

   interrupt_DMA1_CHANNEL1 = 27,
   interrupt_DMA1_CHANNEL2,
   interrupt_DMA1_CHANNEL3,
   interrupt_DMA1_CHANNEL4,
   interrupt_DMA1_CHANNEL5,
   interrupt_DMA1_CHANNEL6,
   interrupt_DMA1_CHANNEL7,

   interrupt_TIMER6_DAC = 70, // Timer6 and DAC underflow/underrun interrupt
   interrupt_TIMER7     = 71, // Timer7 interrupt

   interrupt_DMA2_CHANNEL1 = 72,
   interrupt_DMA2_CHANNEL2,
   interrupt_DMA2_CHANNEL3,
   interrupt_DMA2_CHANNEL4,
   interrupt_DMA2_CHANNEL5,
} interrupt_e;

// == exported functions

static inline void wait_for_interrupt(void); // enter sleep mode (see WFI)
static inline void enable_all_interrupt(void);
static inline void disable_all_interrupt(void); // masks interrupts with priority >= 0
static inline uint32_t getmask_interrupt(void);
static inline void enable_fault_interrupt(void);
static inline void disable_fault_interrupt(void);  // masks interrupts including fault interrupt with priority >= -1
static inline uint32_t getfaultmask_interrupt(void);
static inline void setprioritymask_interrupt(uint8_t priority/*0:no priority masking*/); // mask interrupts with priority <= priority
static inline uint32_t getprioritymask_interrupt(void); // 0: No masking. M!=0: Interrups with priority <= M are masked.
static inline void clearprioritymask_interrupt(void);

static inline int setpriority_interrupt(interrupt_e intnr, interrupt_priority_e priority);
static inline uint8_t getpriority_interrupt_nvic(interrupt_e intnr);
static inline int isenabled_interrupt_nvic(interrupt_e intnr);
static inline int enable_interrupt(interrupt_e intnr);
static inline int disable_interrupt(interrupt_e intnr);
static inline int generate_interrupt(interrupt_e intnr);
static inline int clear_interrupt(interrupt_e intnr);
static inline int is_interrupt(interrupt_e intnr);
static inline int is_any_interrupt(void); // returns 1: External interrupt_e is pending (coreinterrupt_e are not considered). 0: No external interrupt is pending.
static inline uint8_t highestpriority_interrupt(void); // returns coreinterrupt_e/interrupt_e with highest priority ready for execution if priority allows it
static inline uint8_t active_interrupt(void);   // returns 0: Thread mode. M!=0: coreinterrupt_e/interrupt_e with number M is active.


static inline int setpriority_coreinterrupt(coreinterrupt_e intnr, interrupt_priority_e priority);
static inline uint8_t getpriority_coreinterrupt(coreinterrupt_e intnr);
static inline int generate_coreinterrupt(coreinterrupt_e intnr);
static inline int clear_coreinterrupt(coreinterrupt_e intnr);
static inline int is_coreinterrupt(coreinterrupt_e intnr);
static inline int enable_coreinterrupt(coreinterrupt_e intnr);
static inline int disable_coreinterrupt(coreinterrupt_e intnr);

// functions exclusively callable by exception/interrupt handlers
static inline int isret2threadmode_interrupt(void);   // returns 1: Processor was interrupted in "Thread mode". 0: Another active handler was interrupted/Processor was interrupted in "Handler mode".


// == definitions

// == Register Offsets

// TODO: remove EXTI
/* Register Offset (EXTI_IMR1) Interrupt mask register; Reset value: 0x1F800000
 * Bits 31:0 MRx: Event mask on external/internal line x; 0 == Masked, 1 == Interrupt Enabled */
#define HW_REGISTER_OFFSET_EXTI_IMR1 0x00
/* Register Offset (EXTI_IMR2) Interrupt mask register; Reset value: 0xFFFFFFFC
 * Bits 3:0 MRx: Interrupt mask on external/internal line x, x = 32..35; 0 == Masked, 1 == Interrupt Enabled */
#define HW_REGISTER_OFFSET_EXTI_IMR2 0x20
/* Register Offset (EXTI_RTSR1) Rising trigger selection register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Rising trigger event configuration bit of line x; 1 == Rising Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_RTSR1 0x08
/* Register Offset (EXTI_RTSR2) Rising trigger selection register; Reset value: 0x00000000
 * Bits 1:0 TRx: Rising trigger event configuration bit of line x, x=32..33; 1 == Rising Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_RTSR2 0x28
/* Register Offset (EXTI_FTSR1) Falling trigger selection register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Falling trigger event configuration bit of line x; 1 == Falling Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_FTSR1 0x0C
/* Register Offset (EXTI_FTSR2) Falling trigger selection register; Reset value: 0x00000000
 * Bits 1:0 TRx: Falling trigger event configuration bit of line x, x=32..33; 1 == Falling Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_FTSR2 0x2C
/* Register Offset (EXTI_SWIER1) Software interrupt event register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Software interrupt on line x; 1 == Sets Pending Bit if IMR Bit also == 1 */
#define HW_REGISTER_OFFSET_EXTI_SWIER1 0x10
/* Register Offset (EXTI_SWIER2) Software interrupt event register; Reset value: 0x00000000
 * Bits 1:0 TRx: Software interrupt on line x, x=32..33; 1 == Sets Pending Bit if IMR Bit also == 1 */
#define HW_REGISTER_OFFSET_EXTI_SWIER2 0x30
/* Register Offset (EXTI_PR1) Pending register ; Reset value: undefined
 * Bits 31:29 + Bits 22:0 TRx: Pending bit on line x; 1 == Selected trigger request occurred
 * The bits are cleared by writing a ‘1’ to the bit (interrupt acknowledge) */
#define HW_REGISTER_OFFSET_EXTI_PR1 0x14
/* Register Offset (EXTI_PR2) Pending register ; Reset value: undefined
 * Bits 1:0 TRx: Pending bit on line x, x=32..33; 1 == Selected trigger request occurred
 * The bits are cleared by writing a ‘1’ to the bit (interrupt acknowledge) */
#define HW_REGISTER_OFFSET_EXTI_PR2 0x34

// TODO: move scb into core

/* Register Offset (SCB_ICSR) Interrupt control and state register; Reset value: 0x00000000
 * Definiert pending, active, clear pending bits für <coreinterrupts_e>. */
#define HW_REGISTER_OFFSET_SCB_ICSR  0x004
/* Register Offset (SCB_SHPR) System handler priority registers; Reset value: 0x00000000
 * Byte accessible. */
#define HW_REGISTER_OFFSET_SCB_SHPR  0x018
/* Register Offset (SCB_SHCSR) System handler control and state register; Reset value: 0x00000000 */
#define HW_REGISTER_OFFSET_SCB_SHCSR 0x024

// == Register Bit Werte

#define HW_REGISTER_BIT_SCB_ICSR_NMIPENDSET  (1u << 31) // NMI set-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_PENDSVSET   (1u << 28) // PendSV set-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_PENDSVCLR   (1u << 27) // PendSV clear-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_PENDSTSET   (1u << 26) // SysTick exception set-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_PENDSTCLR   (1u << 25) // SysTick exception clear-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_ISRPENDING  (1u << 22) // Interrupt pending flag, excluding NMI and Faults.
#define HW_REGISTER_BIT_SCB_ICSR_VECTPENDING (0x7f << 12) // Pending vector. Indicates the exception number of
                                                          // the highest priority pending enabled exception.
#define HW_REGISTER_BIT_SCB_ICSR_RETTOBASE   (1u << 11) // Return to base level. Indicates whether there are
                                                        // preempted active exceptions:
                                                        // 0: There are preempted active exceptions to execute
                                                        // 1: There are no active exceptions, or the currently-executing
                                                        //    exception is the only active exception
#define HW_REGISTER_BIT_SCB_ICSR_VECTACTIVE  (0x1ff)    // Active exception number. 0: Thread mode.
                                                        // (== Cortex-M IPS Spezial Register)

#define HW_REGISTER_BIT_SCB_SHCSR_USGFAULTENA (1u << 18) // Usage fault enable bit. 1: enabled
#define HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTENA (1u << 17) // Bus fault enable bit. 1: enabled
#define HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTENA (1u << 16) // Memory management fault enable bit. 1: enabled
#define HW_REGISTER_BIT_SCB_SHCSR_SVCALLPENDED (1u << 15) // SVC call pending bit. Read 1: exception is pending
#define HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTPENDED (1u << 14) // Bus fault exception pending bit. Read 1: exception is pending
#define HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTPENDED (1u << 13) // Memory management fault exception pending bit. Read 1: exception is pending
#define HW_REGISTER_BIT_SCB_SHCSR_USGFAULTPENDED (1u << 12) // Usage fault exception pending bit. Read 1: exception is pending
#define HW_REGISTER_BIT_SCB_SHCSR_SYSTICKACT     (1u << 11) // SysTick exception active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_PENDSVACT      (1u << 10) // PendSV exception active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_MONITORACT     (1u << 8) // Debug monitor active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_SVCALLACT      (1u << 7) // SVC call active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_USGFAULTACT    (1u << 3) // Usage fault exception active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTACT    (1u << 1) // Bus fault exception active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTACT    (1u << 0) // Memory management fault exception active bit. Reads 1: exception is active


// section: inline implementation

/* function: wait_for_interrupt
 * Versetzt den Prozessor in den Schlafmodus.
 * Daraust erwacht er mit dem nächsten Interrupt. */
static inline void wait_for_interrupt(void)
{
   __asm( "WFI" );
}

/* function: enable_all_interrupt
 * Schaltet alle Interrupts wieder ein, die mit disable_all_interrupt ausgeschaltet wurden.
 *
 * Ergebnis:
 * <getmask_interrupt> liefert 0 zurück (Default nach Reset). */
static inline void enable_all_interrupt(void)
{
   __asm( "cpsie I" );
}

/* function: disable_all_interrupt
 * Maskiert alle Interrupts (Pending Bits bleiben erhalten), bis auf NMI, Reset und Fault.
 *
 * Ergebnis:
 * <getmask_interrupt> liefert 1 zurück. */
static inline void disable_all_interrupt(void)
{
   __asm( "cpsid I" );
}

/* function: getmask_interrupt
 * Liefert 1 zurück, falls die Interrupts (ausser NMI,Reset,Fault) maskiert sind, sonst 0.
 * disable_all_interrupts schaltet die "normalen" Interrupts aus mit maximal Priorität 0. */
static inline uint32_t getmask_interrupt(void)
{
   uint32_t mask;
   __asm( "mrs %[result], PRIMASK" : [result] "=r" (mask) ::);
   return mask;
}

/* function: enable_fault_interrupt
 * Schaltet alle Interrupts wieder ein.
 *
 * Ergebnis:
 * <getfaultmask_interrupt> liefert 0 zurück (Default nach Reset). */
static inline void enable_fault_interrupt(void)
{
   __asm( "cpsie F" );
}

/* function: enable_fault_interrupt
 * Maskiert alle Interrupts (Pending Bits bleiben erhalten), bis auf NMI und Reset.
 * Diese Maske ist zusätzlich und unabhängig von <disable_all_interrupt> zu verstehen.
 *
 * Ergebnis:
 * <getfaultmask_interrupt> liefert 1 zurück. */
static inline void disable_fault_interrupt(void)
{
   __asm( "cpsid F" );
}

static inline uint32_t getfaultmask_interrupt(void)
{
   uint32_t mask;
   __asm( "mrs %[result], FAULTMASK" : [result] "=r" (mask) ::);
   return mask;
}

/* function: setprioritymask_interrupt
 * Erlaubt nur Interrupts mit höherer Priorität als priority.
 * Parameterwert 0 schaltet die Basispriortät aus.
 * Mit <disable_all_interrupt> können alle Interrupts einschliesslich der höchsten Priorität 0
 * temporär maskiert werden. */
static inline void setprioritymask_interrupt(uint8_t priority/*0:no priority masking*/)
{
   priority <<= (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
   __asm( "msr BASEPRI, %[bp]" :: [bp] "r" (priority) :);
}

static inline uint32_t getprioritymask_interrupt(void)
{
   uint32_t priority;
   __asm( "mrs %[result], BASEPRI" : [result] "=r" (priority) ::);
   return priority >> (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
}

static inline void clearprioritymask_interrupt(void)
{
   __asm( "msr BASEPRI, %[bp]" :: [bp] "r" (0) :);
}

#define VALIDATE_ADAPT_INTNR_NVIC(intnr, return_code) \
         intnr -= 16;                                                \
         if ((uint32_t)intnr > (HW_KONFIG_NVIC_INTERRUPT_MAXNR-16)){ \
            return return_code;                                      \
         }

static inline int setpriority_interrupt(interrupt_e intnr, interrupt_priority_e priority)
{
   static_assert(interrupt_priority_HIGH == 0 && interrupt_priority_HIGH < interrupt_priority_LOW);
   if (priority > interrupt_priority_LOW) {
      return EINVAL;
   }

   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->ipr[intnr] = (uint8_t) (priority << (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS));

   return 0;
}

static inline uint8_t getpriority_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 255)

   return hNVIC->ipr[intnr] >> (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
}

static inline int enable_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->iser[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int disable_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->icer[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int isenabled_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   return (hNVIC->iser[intnr/32] >> (intnr & 31)) & 1;
}

static inline int generate_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->ispr[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int clear_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->icpr[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int is_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   return (hNVIC->ispr[intnr/32] >> (intnr & 31)) & 0x1;
}

static inline int is_any_interrupt(void)
{
   return (hSCB->icsr >> HW_BIT(SCB, ICSR, ISRPENDING_POS)) & 1;
}

/* Gibt Nummer des anstehenden(pending) Interrupts/Coreinterrupts mit höchster Priorität zurück.
 * Die Interruptnummern coreinterrupt_RESET, coreinterrupt_NMI und coreinterrupt_FAULT
 * werden niemals zurückgegeben, da diese nicht Pending sein können.
 * Interrupts, die anstehen aber nicht eingeschaltet wurden, werden von dieser
 * Funktion nicht berücksichtigt. Interrupts werden dann nicht sofort ausgeführt,
 * wenn der Prozessor einen Interrupt mit höherer oder gleicher Priorität ausführt
 * oder die Interruptpriorität kleiner oder gleich der mittels setprioritymask_interrupt
 * gesetzten ist. */
static inline uint8_t highestpriority_interrupt(void)
{
   return (uint8_t) (hCORE->scb.icsr >> HW_BIT(SCB, ICSR, VECTPENDING_POS));
}

static inline uint8_t active_interrupt(void)
{
    uint32_t active;
   __asm( "mrs %[result], IPSR" : [result] "=r" (active) ::);
   return (uint8_t) active;
}

#undef VALIDATE_ADAPT_INTNR_NVIC

static inline int setpriority_coreinterrupt(coreinterrupt_e intnr, interrupt_priority_e priority)
{
   static_assert(interrupt_priority_HIGH < interrupt_priority_LOW);
   intnr -= coreinterrupt_MPUFAULT; // intnr < coreinterrupt_MPUFAULT ==> hard coded priority
   if ((uint32_t)intnr > (15-coreinterrupt_MPUFAULT) || priority > interrupt_priority_LOW) {
      return EINVAL;
   }

   volatile uint8_t *shpr = (volatile uint8_t*)& HW_REGISTER(SCB, SHPR);
   shpr[intnr] = (uint8_t) (priority << (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS));

   return 0;
}

static inline uint8_t getpriority_coreinterrupt(coreinterrupt_e intnr)
{
   intnr -= coreinterrupt_MPUFAULT; // intnr < coreinterrupt_MPUFAULT ==> hard coded priority
   if ((uint32_t)intnr > (15-coreinterrupt_MPUFAULT)) {
      return 255;
   }

   volatile uint8_t *shpr = (volatile uint8_t*)& HW_REGISTER(SCB, SHPR);
   return shpr[intnr] >> (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
}

static inline int generate_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   // TODO: add LDREX/STREX to make access to SHCSR atomic !!
   case coreinterrupt_NMI:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_NMIPENDSET;
      break;
   case coreinterrupt_MPUFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTPENDED;
      break;
   case coreinterrupt_BUSFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTPENDED;
      break;
   case coreinterrupt_USAGEFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_USGFAULTPENDED;
      break;
   case coreinterrupt_SVCALL:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_SVCALLPENDED;
      break;
   case coreinterrupt_DEBUGMONITOR:
      HW_REGISTER(SCS, DEMCR) |= HW_REGISTER_BIT_SCS_DEMCR_MONPEND;
      break;
   case coreinterrupt_PENDSV:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_PENDSVSET;
      break;
   case coreinterrupt_SYSTICK:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_PENDSTSET;
      break;
   }

   return 0;
}

static inline int clear_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTPENDED;
      break;
   case coreinterrupt_BUSFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTPENDED;
      break;
   case coreinterrupt_USAGEFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_USGFAULTPENDED;
      break;
   case coreinterrupt_SVCALL:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_SVCALLPENDED;
      break;
   case coreinterrupt_DEBUGMONITOR:
      HW_REGISTER(SCS, DEMCR) &= ~HW_REGISTER_BIT_SCS_DEMCR_MONPEND;
      break;
   case coreinterrupt_PENDSV:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_PENDSVCLR;
      break;
   case coreinterrupt_SYSTICK:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_PENDSTCLR;
      break;
   }

   return 0;
}

static inline int is_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      break;
   case coreinterrupt_MPUFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTPENDED) & 1;
   case coreinterrupt_BUSFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTPENDED) & 1;
   case coreinterrupt_USAGEFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_USGFAULTPENDED) & 1;
   case coreinterrupt_SVCALL:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_SVCALLPENDED) & 1;
   case coreinterrupt_DEBUGMONITOR:
      return (HW_REGISTER(SCS, DEMCR) / HW_REGISTER_BIT_SCS_DEMCR_MONPEND) & 1;
   case coreinterrupt_PENDSV:
      return (HW_REGISTER(SCB, ICSR) / HW_REGISTER_BIT_SCB_ICSR_PENDSVSET) & 1;
   case coreinterrupt_SYSTICK:
      return (HW_REGISTER(SCB, ICSR) / HW_REGISTER_BIT_SCB_ICSR_PENDSTSET) & 1;
   }

   return 0;
}

static inline int enable_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTENA;
      break;
   case coreinterrupt_BUSFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTENA;
      break;
   case coreinterrupt_USAGEFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_USGFAULTENA;
      break;
   case coreinterrupt_DEBUGMONITOR:
      HW_REGISTER(SCS, DEMCR) |= HW_REGISTER_BIT_SCS_DEMCR_MONEN;
      break;
   }
   return 0;
}

static inline int disable_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTENA;
      break;
   case coreinterrupt_BUSFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTENA;
      break;
   case coreinterrupt_USAGEFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_USGFAULTENA;
      break;
   case coreinterrupt_DEBUGMONITOR:
      HW_REGISTER(SCS, DEMCR) &= ~HW_REGISTER_BIT_SCS_DEMCR_MONEN;
      break;
   }

   return 0;
}

static inline int isret2threadmode_interrupt(void)
{
   return (hSCB->icsr >> HW_BIT(SCB, ICSR, RETTOBASE_POS)) & 1;
}

#endif
