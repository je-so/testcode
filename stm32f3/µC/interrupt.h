/* title: Core-Interrupt

   Gibt Zugriff auf auf Cortex-M4 (STM32F303xC spezifisch) Prozessor Peripherie:

      o Nested Vectored Interrupt Controller (NVIC) – Exceptions und Interrupts
      o Extended interrupts and events controller (EXTI) - Anbindung Peripherie, etwa GPIO, an NVIC

   Definition Pending:
   Pending Bits werden auf 1 gesetzt, wenn eine Exception auftritt are und sie werden
   auf 0 gesetzt, wenn diese aktiv wird. Pending Bits können mit is_[core]interrupt abgefragt werden.
   Sie können auch noch vor der Aktivierung der Exception gelöscht werden mit clear_[core]interrupt.
   Damit wird die Ausführung einer Exception verhindert.

   Definition Active:
   Active Bits werden auf 1 gesetzt, wenn die zugehörige Exception die gerade aktive ist, also die
   implementierende Funktion (IRQ-Handler) ausgeführt wird, oder diese durch eine weitere Exception
   mit höherer Priorität unterbrochen wurde, also verschachtelt (nested) ist.
   Mittels isactive_[core]interrupt kann dieses Bit abgefragt werden.
   Damit Exceptions überhaupt aktiv werden können, müssen diese vorher eingeschaltet worden sein
   mit enable_[core]interrupt.

   Copyright:
   This program is free software. See accompanying LICENSE file.

   Author:
   (C) 2016 Jörg Seebohn

   file: µC/interrupt.h
    Header file <Core-Interrupt>.

   file: TODO: µC/interrupt.c
    Implementation file <Core-Interrupt impl>.
*/
#ifndef STM32F303xC_MC_INTERRUPT_HEADER
#define STM32F303xC_MC_INTERRUPT_HEADER

// == Exported Peripherals/HW-Units
#define hNVIC    ((core_nvic_t*) HW_BASEADDR_NVIC)

// == Exported Types

// TODO: remove after gpio changed
typedef enum interrupt_edge_e {
   interrupt_edge_FALLING = 1,
   interrupt_edge_RISING = 2,
} interrupt_edge_e;

typedef enum interrupt_priority_e {
   interrupt_priority_MAX  = 0,
   interrupt_priority_HIGH = 1,
   interrupt_priority_MID  = HW_BIT(SCB, SHPR, PRI_MAX) / 2,
   interrupt_priority_LOW  = HW_BIT(SCB, SHPR, PRI_MAX) - 1,
   interrupt_priority_MIN  = HW_BIT(SCB, SHPR, PRI_MAX),
} interrupt_priority_e;

#define interrupt_priority__NROF (interrupt_priority_LOW+1)

typedef enum coreinterrupt_e {
   coreinterrupt_RESET = 1,      // hard coded Priority: -3; always enabled; Power-On-Reset or Software Reset
   coreinterrupt_NMI   = 2,      // hard coded Priority: -2; always enabled; Non maskable interrupt.
   coreinterrupt_FAULT = 3,      // hard coded Priority: -1; always enabled; All cases of faults, called if other fault handlers disabled
   coreinterrupt_MPUFAULT = 4,   // Settable Priority: 0; default disabled; Memory Protection Error.
   coreinterrupt_BUSFAULT = 5,   // Settable Priority: 0; default disabled; Pre-fetch Fault, illegal address.
   coreinterrupt_USAGEFAULT = 6, // Settable Priority: 0; default disabled; Undefined Instruction or Illegal State.
   coreinterrupt_SVCALL  = 11,   // Settable Priority: 0; always enabled; Generated by Execution of Supervisor Call: SVC{cond} #imm
   coreinterrupt_DEBUGMONITOR = 12, // Settable Priority: 0; default disabled; Cortex-M4 Debug Monitor.
                                    // Setting the pending bit makes it active even if it is disabled.
                                    // Enabling it is a hint to the debug unit to handle debug events with activation of DEBUGMONITOR exception if no external debugger is connected.
   coreinterrupt_PENDSV  = 14,   // Settable Priority: 0; always enabled; Pendable request for system service.
   coreinterrupt_SYSTICK = 15,   // Settable Priority: 0; always enabled; System tick timer.
} coreinterrupt_e;

typedef enum interrupt_e {
   // default state for all interrupt_e: disabled

   interrupt_WWDG = 16,    // Window Watchdog interrupt
   interrupt_PVD  = 17,    // PVD (Programmable Voltage Detector) through EXTI line 16 detection interrupt
   interrupt_GPIOPIN0 = 22,   // EXTI Line0 interrupt (Pin 0 of PortA - PortH)
   // TODO: interrupt_GPIOPIN1 = 23,   // EXTI Line1 interrupt (Pin 1 of PortA - PortH)
   interrupt_GPIOPIN2_TSC = 24, // EXTI Line2 and Touch sensing interrupts
   // TODO: interrupt_GPIOPIN3 = 25,
   // TODO: interrupt_GPIOPIN4 = 26,

   interrupt_DMA1_CHANNEL1 = 27,
   interrupt_DMA1_CHANNEL2 = 28,
   interrupt_DMA1_CHANNEL3 = 29,
   interrupt_DMA1_CHANNEL4 = 30,
   interrupt_DMA1_CHANNEL5 = 31,
   interrupt_DMA1_CHANNEL6 = 32,
   interrupt_DMA1_CHANNEL7 = 33,
   // TODO: interrupt 34-69
   interrupt_TIMER6_DAC = 70, // Timer6 and DAC underflow/underrun interrupt
   interrupt_TIMER7     = 71, // Timer7 interrupt

   interrupt_DMA2_CHANNEL1 = 72,
   interrupt_DMA2_CHANNEL2 = 73,
   interrupt_DMA2_CHANNEL3 = 74,
   interrupt_DMA2_CHANNEL4 = 75,
   interrupt_DMA2_CHANNEL5 = 76,
   // TODO: interrupt 77-97
} interrupt_e;

typedef enum interrupt_retcode_e {
   // -- 1. select one of
   interrupt_retcode_FPU   = 0,           // (default) Interrupt stackframe has 26 words {r0-r3,r12,lr,pc,xpsr(+bit 9),s0-s15,fpscr,fpu-align,+padding(if xpsr bit 9 == 1)
   interrupt_retcode_NOFPU = (1 << 4),    // Interrupt stackframe has 8 words {r0-r3,r12,lr,pc,xpsr(+bit 9),+padding(if xpsr bit 9 == 1)
   // -- 2. select one of
   interrupt_retcode_HANDLERMODE    = 0,           // (default) Nested handler interrupted another handler (isret2threadmode_interrupt()==0).
   interrupt_retcode_THREADMODE_MSP = (1u << 3),   // Handler interrupted cpu in thread mode which used main stack pointer (isret2threadmode_interrupt()==1).
   interrupt_retcode_THREADMODE_PSP = (3u << 2),   // Handler interrupted cpu in thread mode which used process stack pointer (isret2threadmode_interrupt()==1).
} interrupt_retcode_e;

// == exported functions

// == priority management (interrupt masks set execution priority cpu in Thread mode)
//    Offers 3 mechanisms. They work independently from each other. If more than one mask is set the one with the highest priority wins.
//    setfaultmask_interrupt sets mask with highest priority (-1)
//    setprio0mask_interrupt sets mask with 2nd highest priority (0)
//    setprioritymask_interrupt sets mask with 3rd highest priority (> 0)
static inline void setprio0mask_interrupt(void);      // mask interrupts (sets PRIMASK) with priority >= 0)
static inline void clearprio0mask_interrupt(void);    // allow interrupts (clears PRIMASK)
static inline uint32_t getprio0mask_interrupt(void);  // returns 1: setprio0mask_interrupt called last. 0: clearprio0mask_interrupt called last.
static inline void setfaultmask_interrupt(void);      // mask interrupts including fault interrupt with priority >= -1 (interrupt handlers clear that mask at return except NMI)
static inline void clearfaultmask_interrupt(void);    // allow interrupts (clears FAULTMASK)
static inline uint32_t getfaultmask_interrupt(void);  // returns 1: setfaultmask_interrupt called last. 0: clearfaultmask_interrupt called last.
static inline void setprioritymask_interrupt(uint8_t priority/*0:no priority masking*/); // Only for priority > 0: Mask interrupts whose priority >= parameter-priority.
static inline void clearprioritymask_interrupt(void);    // allow interrupts (set BASEPRI to 0).
static inline uint32_t getprioritymask_interrupt(void);  // returns 0: No masking, clearprioritymask_interrupt called last. M!=0: Interrups with priority >= M are masked.

// == interrupt_e
static inline int setpriority_interrupt(interrupt_e intnr, interrupt_priority_e priority);
static inline uint8_t getpriority_interrupt(interrupt_e intnr);
static inline int isenabled_interrupt(interrupt_e intnr);
static inline int enable_interrupt(interrupt_e intnr);
static inline int disable_interrupt(interrupt_e intnr);
static inline int generate_interrupt(interrupt_e intnr);
static inline int clear_interrupt(interrupt_e intnr);
static inline int is_interrupt(interrupt_e intnr);
static inline int isactive_interrupt(interrupt_e intnr); // returns 1: interrupt_e intnr is active and cpu is in Handler mode. 0: Not active but others could be.
static inline int is_any_interrupt(void); // returns 1: External interrupt_e is pending (coreinterrupt_e are not considered). 0: No external interrupt is pending.
static inline uint8_t highestpriority_interrupt(void); // returns coreinterrupt_e/interrupt_e with highest priority ready for execution if priority allows it
static inline uint8_t active_interrupt(void);   // returns 0: Thread mode. M!=0: coreinterrupt_e/interrupt_e with number M is active.

// == coreinterrupt_e
static inline int setpriority_coreinterrupt(coreinterrupt_e intnr, interrupt_priority_e priority);
static inline uint8_t getpriority_coreinterrupt(coreinterrupt_e intnr);
static inline int generate_coreinterrupt(coreinterrupt_e intnr);
static inline int clear_coreinterrupt(coreinterrupt_e intnr);
static inline int is_coreinterrupt(coreinterrupt_e intnr);
static inline int isactive_coreinterrupt(coreinterrupt_e intnr);
static inline int is_any_coreinterrupt(void); // returns 1: interruptcore_e is pending (interrupt_e are not considered). 0: No coreinterrupt_e is pending.
static inline int enable_coreinterrupt(coreinterrupt_e intnr);
static inline int disable_coreinterrupt(coreinterrupt_e intnr);
static inline int isenabled_coreinterrupt(coreinterrupt_e intnr);

// == sleep support
static inline void wait_interrupt(void); // Enter sleep mode (see WFI) and wakes up with next interrupt (effects of PRIMASK (setprio0mask_interrupt) are ignored. pending interrupt which would execute if PRIMASK is cleared let the CPU wake-up).

// == functions exclusively callable by exception/interrupt handlers
static inline int isret2threadmode_interrupt(void);   // returns 1: Processor was interrupted in "Thread mode". 0: Another active handler was interrupted/Processor was interrupted in "Handler mode".

// == functions to handle interrupt return/stackframe
static inline uint32_t retcode_interrupt(interrupt_retcode_e rc); // returns special code for LR register used to indicate return from exception or interrupt handler

// == interrupt vector table
static inline uint32_t sizealign_interruptTable(void);   // ramaddr must be aligned to this byte size (512 bytes)
static inline uint32_t len_interruptTable(void);         // number of entries in vector table (size_in_bytes=sizeof(uint32_t)*len_vectab_interrupt())
static inline int  relocate_interruptTable(/*out*/uint32_t ramaddr[/*len_interruptTable()*/]);  // copies ROM table into RAM and stores new address into NVIC
static inline void reset_interruptTable(void);           // switch back to ROM table

// == interrupt configuration control
static inline void setevent_onpending_interrupt(bool isOn);       // isOn 1: Eventflag of core is set with every new arrived pending interrupt. 0: (default) Pending interrupt do not set eventflag, only active interrupts.
static inline int  isevent_onpending_interrupt(void);             // Returns 1: setevent_onpending_interrupt(1) called last. 0: setevent_onpending_interrupt(0) called last.
static inline void enable_ignoresyncbusfault_interrupt(void);     // ignores synchronous/precise BUSFAULT in FAULT or NMI interrupt handler (if execution priority <= -1) which would lead to lockup
static inline void disable_ignoresyncbusfault_interrupt(void);    // (default after reset) synchronous/precise BUSFAULT in FAULT or NMI interrupt handler leads to cpu lockup
static inline int  isenabled_ignoresyncbusfault_interrupt(void);  // returns 1: enable_ignoresyncbusfault_interrupt called last. 0: disable_ignoresyncbusfault_interrupt called last.
static inline void enable_nested2threadmode_interrupt(void);      // Allows to jump from nested exception back to Thread mode and despite other active interrupts. Preempted interrupts keep their state active and execution priority of Thread mode is equal to highest of active interrupts.
static inline void disable_nested2threadmode_interrupt(void);     // (default after reset) Jumping back to Thread mode from nested interrupt with other interrupts active causes a USAGEFAULT interrupt and a lockup if priority <= -1.
static inline int  isenabled_nested2threadmode_interrupt(void);   // returns 1: enable_nested2threadmode_interrupt called last. 0: disable_nested2threadmode_interrupt called last.
static inline void enable_unalignedaccess_interrupt(void);        // Unaligned word or halfword accesses generate USAGEFAULT exception (escalates to FAULT if disabled).
static inline void disable_unalignedaccess_interrupt(void);       // (default) Unaligned word or halfword accesses allowed. Unaligned load-store multiples and word or halfword exclusive accesses always fault. Stack access must always be aligned.
static inline int  isenabled_unalignedaccess_interrupt(void);     // returns 1: enable_unalignedaccess_interrupt called last. 0: disable_unalignedaccess_interrupt called last.
static inline void enable_divby0_interrupt(void);                 // Division by 0 (udiv,sdiv) generate USAGEFAULT exception (escalates to FAULT if disabled).
static inline void disable_divby0_interrupt(void);                // (default) Division by 0 will result in value 0 without generating an exception.
static inline int  isenabled_divby0_interrupt(void);              // returns 1: enable_divby0_interrupt called last. 0: disable_divby0_interrupt called last.


// == definitions

// == Register Offsets

// TODO: remove EXTI
/* Register Offset (EXTI_IMR1) Interrupt mask register; Reset value: 0x1F800000
 * Bits 31:0 MRx: Event mask on external/internal line x; 0 == Masked, 1 == Interrupt Enabled */
#define HW_OFF_EXTI_IMR1 0x00
/* Register Offset (EXTI_IMR2) Interrupt mask register; Reset value: 0xFFFFFFFC
 * Bits 3:0 MRx: Interrupt mask on external/internal line x, x = 32..35; 0 == Masked, 1 == Interrupt Enabled */
#define HW_OFF_EXTI_IMR2 0x20
/* Register Offset (EXTI_RTSR1) Rising trigger selection register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Rising trigger event configuration bit of line x; 1 == Rising Trigger enabled */
#define HW_OFF_EXTI_RTSR1 0x08
/* Register Offset (EXTI_RTSR2) Rising trigger selection register; Reset value: 0x00000000
 * Bits 1:0 TRx: Rising trigger event configuration bit of line x, x=32..33; 1 == Rising Trigger enabled */
#define HW_OFF_EXTI_RTSR2 0x28
/* Register Offset (EXTI_FTSR1) Falling trigger selection register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Falling trigger event configuration bit of line x; 1 == Falling Trigger enabled */
#define HW_OFF_EXTI_FTSR1 0x0C
/* Register Offset (EXTI_FTSR2) Falling trigger selection register; Reset value: 0x00000000
 * Bits 1:0 TRx: Falling trigger event configuration bit of line x, x=32..33; 1 == Falling Trigger enabled */
#define HW_OFF_EXTI_FTSR2 0x2C
/* Register Offset (EXTI_SWIER1) Software interrupt event register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Software interrupt on line x; 1 == Sets Pending Bit if IMR Bit also == 1 */
#define HW_OFF_EXTI_SWIER1 0x10
/* Register Offset (EXTI_SWIER2) Software interrupt event register; Reset value: 0x00000000
 * Bits 1:0 TRx: Software interrupt on line x, x=32..33; 1 == Sets Pending Bit if IMR Bit also == 1 */
#define HW_OFF_EXTI_SWIER2 0x30
/* Register Offset (EXTI_PR1) Pending register ; Reset value: undefined
 * Bits 31:29 + Bits 22:0 TRx: Pending bit on line x; 1 == Selected trigger request occurred
 * The bits are cleared by writing a ‘1’ to the bit (interrupt acknowledge) */
#define HW_OFF_EXTI_PR1 0x14
/* Register Offset (EXTI_PR2) Pending register ; Reset value: undefined
 * Bits 1:0 TRx: Pending bit on line x, x=32..33; 1 == Selected trigger request occurred
 * The bits are cleared by writing a ‘1’ to the bit (interrupt acknowledge) */
#define HW_OFF_EXTI_PR2 0x34


/* == Inline == */

static inline void assert_values_interrupt(void)
{
         static_assert(core_priority_NONE == (core_priority_e) interrupt_priority_MAX);
         static_assert(core_priority_HIGH == (core_priority_e) interrupt_priority_HIGH);
         static_assert(core_priority_MID  == (core_priority_e) interrupt_priority_MID);
         static_assert(core_priority_LOW  == (core_priority_e) interrupt_priority_LOW);
         static_assert(core_priority_MIN  == (core_priority_e) interrupt_priority_MIN);
}

/* function: clearprio0mask_interrupt
 * Schaltet alle Interrupts wieder ein, die mit setprio0mask_interrupt ausgeschaltet wurden.
 *
 * Ergebnis:
 * <getprio0mask_interrupt> liefert 0 zurück (Default nach Reset). */
static inline void clearprio0mask_interrupt(void)
{
   __asm volatile( "cpsie I" );
}

/* function: setprio0mask_interrupt
 * Setzt die Ausführungspriorität auf 0.
 * Maskiert alle Interrupts bis auf NMI, RESET und FAULT.
 * Diese Maske ist zusätzlich und unabhängig von setfaultmask_interrupt und setprioritymask_interrupt zu verstehen.
 * Werden mehrere Prioritätsmasken gesetzt ist die Ausführungspriorität das Maximum aller (d.h. der numerisch kleinste Wert).
 *
 * Ergebnis:
 * <getprio0mask_interrupt> liefert 1 zurück. */
static inline void setprio0mask_interrupt(void)
{
   __asm volatile( "cpsid I" );
}

/* function: getprio0mask_interrupt
 * Liefert 1 zurück, falls die Interrupts (ausser NMI,Reset,Fault) maskiert sind, sonst 0.
 * setprio0mask_interrupt schaltet die "normalen" Interrupts aus mit maximal Priorität 0. */
static inline uint32_t getprio0mask_interrupt(void)
{
   uint32_t mask;
   __asm volatile( "mrs %[result], PRIMASK" : [result] "=r" (mask) ::);
   return mask;
}

/* function: clearfaultmask_interrupt
 * Schaltet alle Interrupts wieder ein.
 *
 * Ergebnis:
 * <getfaultmask_interrupt> liefert 0 zurück (Default nach Reset). */
static inline void clearfaultmask_interrupt(void)
{
   __asm volatile( "cpsie F" );
}

/* function: setfaultmask_interrupt
 * Setzt die Ausführungspriorität auf -1.
 * Damit können nur noch Interrupts mit Priorität -2 und -3 ausgeführt werden.
 * Maskiert daher alle Interrupts bis auf NMI und Reset.
 * Diese Maske ist zusätzlich und unabhängig von setprio0mask_interrupt und setprioritymask_interrupt zu verstehen.
 * Werden mehrere Prioritätsmasken gesetzt ist die Ausführungspriorität das Maximum aller (d.h. der numerisch kleinste Wert).
 *
 * Interruptbesonderheiten:
 * Bei Verlassen eines anderen Interrupts als NMI wird automatisch clearfaultmask_interrupt aufgerufen. Bei NMI Interrupts
 * wird diese Maske nicht angetastet.
 * Diese Funktion wird ignoriert, sollte sie aus NMI und FAULT Interrupts heraus ausgerufen werden.
 *
 * Precondition:
 * - Does only work if not called from NMI or FAULT interrupts else function ignored.
 *
 * Ergebnis:
 * <getfaultmask_interrupt> liefert 1 zurück. */
static inline void setfaultmask_interrupt(void)
{
   __asm volatile( "cpsid F" );
}

static inline uint32_t getfaultmask_interrupt(void)
{
   uint32_t mask;
   __asm volatile( "mrs %[result], FAULTMASK" : [result] "=r" (mask) ::);
   return mask;
}

/* function: setprioritymask_interrupt
 * Erlaubt nur Interrupts mit höherer Priorität als priority.
 * Parameterwert 0 schaltet die Basispriortät aus.
 * Mit setprio0mask_interrupt können alle Interrupts einschliesslich der höchsten Priorität 0 temporär maskiert werden.
 * Diese Maske ist zusätzlich und unabhängig von setprio0mask_interrupt und setfaultmask_interrupt zu verstehen.
 * Werden mehrere Prioritätsmasken gesetzt ist die Ausführungspriorität das Maximum aller (d.h. der numerisch kleinste Wert).
 *
 */
static inline void setprioritymask_interrupt(uint8_t priority/*0:no priority masking*/)
{
   priority <<= (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
   __asm volatile( "msr BASEPRI, %[bp]" :: [bp] "r" (priority) :);
}

static inline uint32_t getprioritymask_interrupt(void)
{
   uint32_t priority;
   __asm volatile( "mrs %[result], BASEPRI" : [result] "=r" (priority) ::);
   return priority >> (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
}

static inline void clearprioritymask_interrupt(void)
{
   __asm volatile( "msr BASEPRI, %[bp]" :: [bp] "r" (0) :);
}

#define VALIDATE_ADAPT_INTNR_NVIC(intnr, return_code) \
         intnr -= 16;                                                \
         if ((uint32_t)intnr > (HW_KONFIG_NVIC_INTERRUPT_MAXNR-16)){ \
            return return_code;                                      \
         }

static inline int setpriority_interrupt(interrupt_e intnr, interrupt_priority_e priority)
{
   static_assert(interrupt_priority_MAX == 0 && interrupt_priority_MIN > 0);
   if (priority > interrupt_priority_MIN) {
      return EINVAL;
   }

   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->ipr[intnr] = (uint8_t) (priority << (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS));

   return 0;
}

static inline uint8_t getpriority_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 255)

   return hNVIC->ipr[intnr] >> (8-HW_KONFIG_NVIC_INTERRUPT_PRIORITY_NROFBITS);
}

static inline int enable_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->iser[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int disable_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->icer[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int isenabled_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   return (hNVIC->iser[intnr/32] >> (intnr & 31)) & 1;
}

static inline int generate_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->ispr[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int clear_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   hNVIC->icpr[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int is_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   return (hNVIC->ispr[intnr/32] >> (intnr & 31)) & 0x1;
}

static inline int isactive_interrupt(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   return (hNVIC->iabr[intnr/32] >> (intnr & 31)) & 0x1;
}

static inline int is_any_interrupt(void)
{
   return (hSCB->icsr >> HW_BIT(SCB, ICSR, ISRPENDING_POS)) & 1;
}

/* Gibt Nummer des anstehenden(pending) Interrupts/Coreinterrupts mit höchster Priorität zurück.
 * Die Interruptnummern coreinterrupt_RESET, coreinterrupt_NMI und coreinterrupt_FAULT
 * werden niemals zurückgegeben, da diese nicht Pending sein können.
 * Interrupts, die anstehen aber nicht eingeschaltet wurden, werden von dieser
 * Funktion nicht berücksichtigt. Interrupts werden dann nicht sofort ausgeführt,
 * wenn der Prozessor einen Interrupt mit höherer oder gleicher Priorität ausführt
 * oder die Interruptpriorität kleiner oder gleich der mittels setprioritymask_interrupt
 * gesetzten ist. */
static inline uint8_t highestpriority_interrupt(void)
{
   return (uint8_t) (hCORE->scb.icsr >> HW_BIT(SCB, ICSR, VECTPENDING_POS));
}

static inline uint8_t active_interrupt(void)
{
    uint32_t active;
   __asm volatile( "mrs %[result], IPSR" : [result] "=r" (active) ::);
   return (uint8_t) active;
}

#undef VALIDATE_ADAPT_INTNR_NVIC

static inline int setpriority_coreinterrupt(coreinterrupt_e intnr, interrupt_priority_e priority)
{
   static_assert(interrupt_priority_MAX < interrupt_priority_MIN);
   intnr -= coreinterrupt_MPUFAULT; // intnr < coreinterrupt_MPUFAULT ==> hard coded priority
   if ((uint32_t)intnr > (15-coreinterrupt_MPUFAULT) || priority > interrupt_priority_MIN) {
      return EINVAL;
   }

   hSCB->shpr[intnr] = (uint8_t) (priority << HW_BIT(SCB, SHPR, PRI_POS));

   return 0;
}

static inline uint8_t getpriority_coreinterrupt(coreinterrupt_e intnr)
{
   intnr -= coreinterrupt_MPUFAULT; // intnr < coreinterrupt_MPUFAULT ==> hard coded priority
   if ((uint32_t)intnr > (15-coreinterrupt_MPUFAULT)) {
      return 255;
   }

   return hSCB->shpr[intnr] >> HW_BIT(SCB, SHPR, PRI_POS);
}

static inline int generate_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_NMI:
      hSCB->icsr = HW_BIT(SCB, ICSR, NMIPENDSET);
      break;
   case coreinterrupt_MPUFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, MEMFAULTPENDED));
      break;
   case coreinterrupt_BUSFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, BUSFAULTPENDED));
      break;
   case coreinterrupt_USAGEFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, USGFAULTPENDED));
      break;
   case coreinterrupt_SVCALL:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, SVCALLPENDED));
      break;
   case coreinterrupt_DEBUGMONITOR:
      // TODO: atomic ?
      setbits_atomic(&hDBG->demcr, HW_BIT_SCS_DEMCR_MONPEND); // TODO: use HW_BIT from core !!!
      break;
   case coreinterrupt_PENDSV:
      hSCB->icsr = HW_BIT(SCB, ICSR, PENDSVSET);
      break;
   case coreinterrupt_SYSTICK:
      hSCB->icsr = HW_BIT(SCB, ICSR, PENDSTSET);
      break;
   }

   return 0;
}

static inline int clear_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, MEMFAULTPENDED));
      break;
   case coreinterrupt_BUSFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, BUSFAULTPENDED));
      break;
   case coreinterrupt_USAGEFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, USGFAULTPENDED));
      break;
   case coreinterrupt_SVCALL:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, SVCALLPENDED));
      break;
   case coreinterrupt_DEBUGMONITOR:
      // TODO: atomic ?
      clearbits_atomic(&hDBG->demcr, HW_BIT_SCS_DEMCR_MONPEND); // TODO: use HW_BIT from core !!!
      break;
   case coreinterrupt_PENDSV:
      hSCB->icsr = HW_BIT(SCB, ICSR, PENDSVCLR);
      break;
   case coreinterrupt_SYSTICK:
      hSCB->icsr = HW_BIT(SCB, ICSR, PENDSTCLR);
      break;
   }

   return 0;
}

static inline int is_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      break;
   case coreinterrupt_MPUFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, MEMFAULTPENDED_POS)) & 1;
   case coreinterrupt_BUSFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, BUSFAULTPENDED_POS)) & 1;
   case coreinterrupt_USAGEFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, USGFAULTPENDED_POS)) & 1;
   case coreinterrupt_SVCALL:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, SVCALLPENDED_POS)) & 1;
   case coreinterrupt_DEBUGMONITOR:
      return (hDBG->demcr / HW_BIT_SCS_DEMCR_MONPEND) & 1;
   case coreinterrupt_PENDSV:
      return (hSCB->icsr >> HW_BIT(SCB, ICSR, PENDSVSET_POS)) & 1;
   case coreinterrupt_SYSTICK:
      return (hSCB->icsr >> HW_BIT(SCB, ICSR, PENDSTSET_POS)) & 1;
   }

   return 0;
}

static inline int isactive_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      break;
   case coreinterrupt_MPUFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, MEMFAULTACT_POS)) & 1;
   case coreinterrupt_BUSFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, BUSFAULTACT_POS)) & 1;
   case coreinterrupt_USAGEFAULT:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, USGFAULTACT_POS)) & 1;
   case coreinterrupt_SVCALL:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, SVCALLACT_POS)) & 1;
   case coreinterrupt_DEBUGMONITOR:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, MONITORACT_POS)) & 1;
   case coreinterrupt_PENDSV:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, PENDSVACT_POS)) & 1;
   case coreinterrupt_SYSTICK:
      return (hSCB->shcsr >> HW_BIT(SCB, SHCSR, SYSTICKACT_POS)) & 1;
   }

   return 0;
}

static inline int is_any_coreinterrupt(void)
{
   return 0 != (  (hDBG->demcr & HW_BIT_SCS_DEMCR_MONPEND)
               |  (hSCB->icsr & (HW_BIT(SCB, ICSR, PENDSVSET) | HW_BIT(SCB, ICSR, PENDSTSET)))
               |  (hSCB->shcsr & (  HW_BIT(SCB, SHCSR, MEMFAULTPENDED)
                                 |  HW_BIT(SCB, SHCSR, BUSFAULTPENDED)
                                 |  HW_BIT(SCB, SHCSR, USGFAULTPENDED)
                                 |  HW_BIT(SCB, SHCSR, SVCALLPENDED)))
               );
}


static inline int enable_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, MEMFAULTENA));
      break;
   case coreinterrupt_BUSFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, BUSFAULTENA));
      break;
   case coreinterrupt_USAGEFAULT:
      setbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, USGFAULTENA));
      break;
   case coreinterrupt_DEBUGMONITOR:
      // TODO: atomic ?
      hDBG->demcr |= HW_BIT_SCS_DEMCR_MONEN;
      break;
   }
   return 0;
}

static inline int disable_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, MEMFAULTENA));
      break;
   case coreinterrupt_BUSFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, BUSFAULTENA));
      break;
   case coreinterrupt_USAGEFAULT:
      clearbits_atomic(&hSCB->shcsr, HW_BIT(SCB, SHCSR, USGFAULTENA));
      break;
   case coreinterrupt_DEBUGMONITOR:
      // TODO: atomic ?
      hDBG->demcr &= ~HW_BIT_SCS_DEMCR_MONEN;
      break;
   }
   return 0;
}

/* Versetzt den Prozessor in den Schlafmodus.
 * Daraust erwacht er mit dem nächsten Interrupt.
 * Die Effekte von PRIMASK werden ignoriert, d.h. ein wartender Interrupt, der ausgeführt würde,
 * wäre nur PRIMASK nicht gesetzt (PRIMASK wird gesetzt mit setprio0mask_interrupt), lässt WFI
 * zurückkehren. So kann es vermieden werden, dass ein Interrupt kurz vor dem Aufruf von WFI auftritt,
 * der dann die CPU aus WFI nicht mehr aufwecken kann. Es kann auch dazu dienen, dass nach dem Aufwachen
 * erst Initialsiierungen durchgeführt werden müssen und es dem Interrupt erst danach erlaubt ist,
 * ausgeführt zu werden. */
static inline void wait_interrupt(void)
{
   __asm volatile( "WFI" );
}

static inline int isenabled_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      break;
   case coreinterrupt_MPUFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_BIT_SCB_SHCSR_MEMFAULTENA) & 1;
   case coreinterrupt_BUSFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_BIT_SCB_SHCSR_BUSFAULTENA) & 1;
   case coreinterrupt_USAGEFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_BIT_SCB_SHCSR_USGFAULTENA) & 1;
   case coreinterrupt_DEBUGMONITOR:
      return (hDBG->demcr / HW_BIT_SCS_DEMCR_MONEN) & 1;
   }
   return 1/*default is enabled*/;
}

static inline int isret2threadmode_interrupt(void)
{
   return (hSCB->icsr >> HW_BIT(SCB, ICSR, RETTOBASE_POS)) & 1;
}

/* Gibt den WErt zurück, durch den die neue Ramdresse (ramaddr) der Vektortabelle teilbar sein muss.
 * Der zurückgegebene Wert beträgt 512, so dass ramaddr auf eine 512 Byte Seitengrenze ausgerichtet sein muss. */
static inline uint32_t sizealign_interruptTable(void)
{
   return 1u << HW_BIT(SCB, VTOR, TBLOFF_POS);
}

/* Gibt die Länge des neuen Interruptvektors an.
 * Die Größe in Bytes ergibt sich aus: len_interruptTable() * sizeof(uint32_t). */
static inline uint32_t len_interruptTable(void)
{
   return HW_KONFIG_NVIC_INTERRUPT_MAXNR+1;
}

/* Initialisiert ramaddr Array und lässt NVIC dieses als neuen Interruptvektor nutzen.
 * Zur Initialsierung werden len_interruptTable() Einträge aus dem ROM-Interruptvektor an die neue ramaddr kopiert.
 * Die Größe des Speicherblockes, auf den ramaddr zeigt, muss mindestens (len_interruptTable() * sizeof(uint32_t))
 * Bytes betragen.
 * Wenn ramaddr nicht korrekt auf sizealign_interruptTable() Bytes ausgerichtet wurde, wird der Fehlercode EINVAL zurückgegeben. */
static inline int relocate_interruptTable(/*out*/uint32_t ramaddr[/*len_interruptTable()*/])
{
   if (((uintptr_t)ramaddr & ~HW_BIT(SCB, VTOR, TBLOFF))) {
      return EINVAL;
   }

   uint32_t *ROMTABLE = (uint32_t*) 0;
   for (uint32_t i = 0; i <= HW_KONFIG_NVIC_INTERRUPT_MAXNR; ++i) {
      ramaddr[i] = ROMTABLE[i];
   }

   __asm volatile("dmb");  // ensure all changes to ramaddr are written before ramaddr is written into vtor
   hSCB->vtor = (uintptr_t) ramaddr;

   return 0;
}

/* Der Interruptcontroller wird veranlasst, wieder den Interruptvektor aus dem ROM zu nutzen.
 * Die RAM-Tabelle wird dabei nicht geändert. */
static inline void reset_interruptTable(void)
{
   hSCB->vtor = 0;         // switch back to vector table stored in rom
   __asm volatile("dsb");  // wait until change is written to vtor
}

static inline void setevent_onpending_interrupt(bool isOn)
{
   setclrbits_atomic(&hSCB->scr, (0u-isOn) & HW_BIT(SCB, SCR, SEVEONPEND), HW_BIT(SCB, SCR, SEVEONPEND));
}

static inline int isevent_onpending_interrupt(void)
{
   return (hSCB->scr >> HW_BIT(SCB, SCR, SEVEONPEND_POS)) & 1;
}

static inline void disable_ignoresyncbusfault_interrupt(void)
{
   clearbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, BFHFNMIGN));
}

static inline void enable_ignoresyncbusfault_interrupt(void)
{
   setbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, BFHFNMIGN));
}

static inline int isenabled_ignoresyncbusfault_interrupt(void)
{
   return (hSCB->ccr >> HW_BIT(SCB, CCR, BFHFNMIGN_POS)) & 1;
}

static inline void enable_nested2threadmode_interrupt(void)
{
   setbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, NONBASETHRDENA));
}

static inline void disable_nested2threadmode_interrupt(void)
{
   clearbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, NONBASETHRDENA));
}

static inline int isenabled_nested2threadmode_interrupt(void)
{
   return (hSCB->ccr >> HW_BIT(SCB, CCR, NONBASETHRDENA_POS)) & 1;
}

static inline void enable_unalignedaccess_interrupt(void)
{
   setbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, UNALIGN_TRP));
}

static inline void disable_unalignedaccess_interrupt(void)
{
   clearbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, UNALIGN_TRP));
}

static inline int isenabled_unalignedaccess_interrupt(void)
{
   return (hSCB->ccr >> HW_BIT(SCB, CCR, UNALIGN_TRP_POS)) & 1;
}

static inline void enable_divby0_interrupt(void)
{
   setbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, DIV_0_TRP));
}

static inline void disable_divby0_interrupt(void)
{
   clearbits_atomic(&hSCB->ccr, HW_BIT(SCB, CCR, DIV_0_TRP));
}

static inline int isenabled_divby0_interrupt(void)
{
   return (hSCB->ccr >> HW_BIT(SCB, CCR, DIV_0_TRP_POS)) & 1;
}

static inline uint32_t retcode_interrupt(interrupt_retcode_e rc)
{
   return (0xffffffe1 | rc);
}


#endif
