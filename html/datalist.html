<!doctype html>
<html>
<head>
   <meta charset="utf-8">
   <link href="bootstrap/bootstrap.css" rel="stylesheet">
   <script src="bootstrap/bootstrap.bundle.js"></script>
   <style>

.autocomplete-container {
    position: relative;
    width: 100%;
    max-width: 300px;
    margin: 20px auto;
}

.autocomplete-container ul {
    display: none;
    position: absolute;
    cursor: pointer;
    border: var(--bs-border-width) var(--bs-border-style) var(--bs-border-color);
    top: 100%;
    left: 0;
    right: 0;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
}

.autocomplete-container ul li {
    border: none;
}

  </style>
</head>
<body>
   <div class="container my-4">

   <h5>Autocomplete HTML component</h5>
   <h6><small><tt>less than 120 LOC of JavaScript</tt></small></h6>

   <div class="autocomplete-container">
      <input type="text" placeholder="Search..." class="form-control">
      <ul class="list-group"></ul>
   </div>

   <p>Focus the text input to open the list of all autocompletion entries.</p>
   <ul>
      <li>Pressing <kbd>Enter</kbd> autocompletes the entered text with content of active element.</li>
      <li>Supported keys are: <kbd>Escape</kbd>, <kbd>Home</kbd>, <kbd>End</kbd>, <kbd>Enter</kbd>,<kbd>PageDown</kbd>,<kbd>ArrowDown</kbd>, <kbd>ArrowRight</kbd>, <kbd>PageUp</kbd>, <kbd>ArrowUp</kbd>, and <kbd>ArrowLeft</kbd>.</li>
      <li>A mouse click on an element of the list autocompletes the entered text with content of clicked element.</li>
      <li>Scrolling the list changes the active element so that it is always visible to the user.</li>
      <li>The list entries are filterd by the entered text.</li>
      <li>The order of elements is determined once at construction.</li>
   </ul>

   <h6>Usage with Bootstrap</h6>
   <p>You can style the component with other CSS frameworks.</p>
   <ul>
      <li>The active element is marked with class options.activeClass.</li>
      <li>A list entry is styled with options.liClass.</li>
   </ul>
   <pre class="my-2">HTML</pre>
   <p>Before adding the following HTML to your page replace classes <code>form-control</code> and <code>list-group</code>
      with those of your framework:</p>
   <code><pre>
   &lt;div class="autocomplete-container">
      &lt;input type="text" placeholder="Search..." class="form-control">
      &lt;ul class="list-group">&lt;/ul>
   &lt;/div>
   </pre></code>

   <pre class="my-2">Javascript</pre>
   <p>Initialize component with <code>new AutocompleteTextInput(container, data, options)</code></p>
   <code><pre>
   new AutocompleteTextInput(
      document.querySelector(".autocomplete-container"),
      [ 'Apple', 'Banana', 'Cherry', 'Mapped-Cherr_y' ],
      {
         activeClass: "active",
         liClass: "list-group-item list-group-item-action",
         datamap: {'Mapped-Cherr_y':'Cherry'}
      })
   </pre></code>

   <pre class="my-2">CSS</pre>
   <p>The container needs to be positioned to work as anchor point for the positioned list.</p>
   <code><pre>
   .autocomplete-container { position: relative; }
   </pre></code>
   <p>
      The autocompletion list needs a little more styling and is positioned absolute.<br>
      It should not be displayed (<code>display:none</code>) initially.<br>
      Use <code>max-height</code> and <code>overflow-y:auto</code> to set the maximum height of visible entries and to enable scrolling.<br>
      With <code>left:0;right:0</code> the list takes the whole width of the container.<br>
      Use <code>top:100%</code> to position the list below the text input field.
   </p>
   <code><pre>
   .autocomplete-container ul {
      display: none;
      position: absolute;
      cursor: pointer;
      border: var(--bs-border-width) var(--bs-border-style) var(--bs-border-color);
      top: 100%;
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
   }
   </pre></code>
   </div>
<script>

class AutocompleteTextInput {
   constructor(container, data, { datamap={}, activeClass="active", liClass="" }={}) {
      const suggestions = [], idmap = [], index = new Map()
      const htmlInput = container.querySelector("input[type='text']")
      const htmlList = container.querySelector("ul")
      if (!htmlInput) throw Error(`Missing tag <input type="text">.`)
      if (!htmlList) throw Error(`Missing tag <ul>.`)
      if (!Array.isArray(data)) throw Error(`Expect data of type string[].`)
      if (typeof datamap !== "object") throw Error(`Expect datamap of type object.`)
      for (let di=0; di<data.length; ++di) {
         const suggestion=data[di]
         if (typeof suggestion !== "string") throw Error(`Expect data[${di}] of type string.`)
         if (!index.has(suggestion)) {
            index.set(suggestion, suggestions.length)
            suggestions.push(suggestion)
         }
      }
      for (const [ searchTerm, mapTo ] of Object.entries(datamap)) {
         if (typeof mapTo !== "string") throw Error(`Expect datamap['${searchTerm}'] of type string.`)
         const idfrom = index.get(searchTerm)
         const idto = index.get(mapTo)
         if (idfrom === undefined) throw Error(`Expect data to contain '${searchTerm}'.`)
         if (idto === undefined) throw Error(`Expect data to contain '${mapTo}'.`)
         idmap[idfrom] = idto
      }
      htmlInput.addEventListener("click", this.onClickInput.bind(this))
      htmlInput.addEventListener("input", this.onInput.bind(this))
      htmlInput.addEventListener("focus", this.onFocus.bind(this))
      htmlInput.addEventListener("blur", this.onBlur.bind(this))
      htmlInput.addEventListener("keydown", this.onKeydown.bind(this))
      htmlList.addEventListener("scroll", this.onScroll.bind(this))
      htmlList.addEventListener("mousedown", this.onTouchList.bind(this))
      htmlList.addEventListener("touchstart", this.onTouchList.bind(this))
      this.htmlInput = htmlInput
      this.htmlList = htmlList
      this.suggestions = suggestions
      this.idmap = idmap
      this.activeClass = activeClass
      this.liClass = liClass
      this.selected = undefined
   }
   // VIEW
   showList(show) { this.htmlList.style.display = show ? "block" : "none" }
   getActive() { return this.htmlList.querySelector("li."+this.activeClass) ?? this.htmlList.firstElementChild }
   setActive(active) { this.getActive()?.classList.remove(this.activeClass); active.classList.add(this.activeClass) }
   setActiveScroll(active) { this.setActive(active); active.scrollIntoView({block:"nearest"}) }
   makeListVisible() { this.showList(Boolean(this.htmlList.firstElementChild)) }
   // MODEL
   updateList(searchTerm) {
      const activeID = Number(this.getActive()?.dataset?.["id"] ?? 0)
      searchTerm = searchTerm.toLowerCase()
      this.htmlList.innerHTML = ''
      let active = null
      this.suggestions.forEach( (suggestion, id) => {
         if (suggestion.toLowerCase().includes(searchTerm) || this.suggestions[this.idmap[id]??-1]?.toLowerCase().includes(searchTerm)) {
            const li = document.createElement('li')
            li.textContent = suggestion
            li.dataset["id"] = id
            li.className = this.liClass
            this.htmlList.appendChild(li)
            activeID === id && (active = li)
         }
      })
      if (this.htmlList.firstElementChild)
         this.setActiveScroll(active ?? this.htmlList.firstElementChild)
      this.makeListVisible()
   }
   listEntry(target) {
      if (!target || !this.htmlList.contains(target)) return
      while (target.parentElement !== this.htmlList)
         target = target.parentElement
      return target
   }
   autoComplete(li) {
      if (li) {
         this.htmlInput.value = this.suggestions[this.idmap[li.dataset["id"]] ?? li.dataset["id"]]
         this.setActive(li)
      }
      this.showList(false)
   }
   ensureActiveVisible() {
      const lr = this.htmlList.getBoundingClientRect()
      const ar = this.getActive().getBoundingClientRect()
      const visible = this.listEntry(
                  lr.top + 10 > ar.bottom ? document.elementFromPoint(lr.left+lr.width/2,lr.top+10) :
                  lr.bottom - 10 < ar.top ? document.elementFromPoint(lr.left+lr.width/2,lr.bottom-10) :
                  this.getActive())
      if (visible) this.setActive(visible.getBoundingClientRect().top < lr.top-10 ? visible.nextElementSibling : visible.getBoundingClientRect().bottom > lr.bottom+10 ? visible.previousElementSibling : visible)
      this.selected = undefined
   }
   // CONTROLLER
   onClickInput() { this.makeListVisible() }
   onTouchList(e) { this.selected = this.listEntry(e.target) }
   onInput() { this.updateList(this.htmlInput.value) }
   onFocus() { this.updateList(this.htmlInput.value) }
   onBlur() { this.autoComplete(this.selected) }
   onScroll() { this.ensureActiveVisible() }
   onKeydown(e) {
      switch(this.htmlList.childElementCount && e.key) {
      case "Escape": this.htmlInput.blur(); return this.showList(false)
      case "Home": return this.setActiveScroll(this.htmlList.firstElementChild)
      case "End": return this.setActiveScroll(this.htmlList.lastElementChild)
      case "Enter": return this.autoComplete(this.getActive())
      case "PageDown": case "ArrowDown": case "ArrowRight": case "PageUp": case "ArrowUp": case "ArrowLeft":
         let height = this.htmlList.getBoundingClientRect().height, active = this.getActive(), isUp = e.key.endsWith("Up") || e.key.endsWith("Left")
         this.makeListVisible()
         for (var repeat=e.key.startsWith("Page") ? 50 : 1; height>0 && repeat>0; --repeat) {
            const next = isUp ? active.previousElementSibling : active.nextElementSibling
            if ((height -= next?.getBoundingClientRect().height??height+1) >= 0) active = next
         }
         return this.setActiveScroll(active)
      }
   }
}

document.addEventListener('DOMContentLoaded', function() {
   const data = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry', 'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon', 'Apple2', 'Banana2', 'Cherry2', 'Date2', 'Elderberry2', 'Fig2', 'Grape2', 'Honeydew2', 'Kiwi2', 'Lemon2', 'Apple3', 'Banana3', 'Cherry3', 'Date3', 'Elderberry3', 'Fig3', 'Grape3', 'Honeydew3', 'Kiwi3', 'Lemon3', 'Mapped-Appl_e', 'Mapped-Banan_a', 'Mapped-Cherr_y', 'Mapped-Dat_e', 'Mapped-Elderberr_y', 'Mapped-Fi_g', 'Mapped-Grap_e', 'Mapped-Honeyde_w', 'Mapped-Kiw_i', 'Mapped-Lemo_n' ]
   const autoComplete = new AutocompleteTextInput(document.querySelector(".autocomplete-container"), data,
   { liClass: "list-group-item list-group-item-action", datamap: {  'Mapped-Appl_e':'Apple', 'Mapped-Banan_a':'Banana', 'Mapped-Cherr_y':'Cherry',
      'Mapped-Dat_e':'Date', 'Mapped-Elderberr_y':'Elderberry', 'Mapped-Fi_g':'Fig',
      'Mapped-Grap_e':'Grape', 'Mapped-Honeyde_w':'Honeydew', 'Mapped-Kiw_i':'Kiwi',
      'Mapped-Lemo_n':'Lemon' } })
})

</script>

</body>
</html>