/* title: Core-Interrupt

   Gibt Zugriff auf auf Cortex-M4 (STM32F303xC spezifisch) Prozessor Peripherie:

      o Nested Vectored Interrupt Controller (NVIC) – Exceptions und Interrupts
      o Extended interrupts and events controller (EXTI) - Anbindung Peripherie, etwa GPIO, an NVIC

   Copyright:
   This program is free software. See accompanying LICENSE file.

   Author:
   (C) 2016 Jörg Seebohn

   file: µC/interrupt.h
    Header file <Core-Interrupt>.

   file: TODO: µC/interrupt.c
    Implementation file <Core-Interrupt impl>.
*/
#ifndef STM32F303xC_MC_INTERRUPT_HEADER
#define STM32F303xC_MC_INTERRUPT_HEADER

// == exported types

// TODO: remove after gpio changed
typedef enum interrupt_edge_e {
   interrupt_edge_FALLING = 1,
   interrupt_edge_RISING = 2,
} interrupt_edge_e;

typedef enum interrupt_priority_e {
   interrupt_priority_HIGH = 0,
   interrupt_priority_LOW  = (1u << HW_KONFIG_NVIC_PRIORITY_NROFBITS) - 1,
} interrupt_priority_e;

#define interrupt_priority__NROF (1u << HW_KONFIG_NVIC_PRIORITY_NROFBITS)

typedef enum coreinterrupt_e {
   coreinterrupt_RESET = 1, // hard coded Priority: -3 (highest possible); Power-On-Reset or Software Reset
   coreinterrupt_NMI   = 2, // hard coded Priority: -2 ; Non maskable interrupt.
   coreinterrupt_FAULT = 3, // hard coded Priority: -1 ; All cases of faults, called if other fault handlers disabled
   coreinterrupt_MPUFAULT = 4, // Settable Priority: 0; default disabled; Memory Error.
   coreinterrupt_BUSFAULT = 5, // Settable Priority: 0; default disabled; Pre-fetch Fault, illegal address.
   coreinterrupt_USAGEFAULT = 6, // Settable Priority: 0; default disabled; Undefined Instruction or Illegal State.
   coreinterrupt_SVCALL  = 11, // Settable Priority: 0; Generated by Execution of Supervisor Call: SVC{cond} #imm
   coreinterrupt_DEBUGMONITOR = 12, // Fixed Priority: 0; Cortex-M4 Debug Monitor.
   coreinterrupt_PENDSV  = 14, // Settable Priority: 0; Pendable request for system service.
   coreinterrupt_SYSTICK = 15, // Settable Priority: 0; System tick timer.
} coreinterrupt_e;

typedef enum interrupt_e {
   interrupt_WWDG = 16, // Window Watchdog interrupt
   interrupt_PVD  = 17, // PVD through EXTI line 16 detection interrupt
   interrupt_GPIOPIN0 = 22, // EXTI Line0 interrupt (Pin 0 of PortA - PortH)
   interrupt_GPIOPIN1 = 23, // EXTI Line1 interrupt (Pin 1 of PortA - PortH)
   interrupt_GPIOPIN2_TSC = 24, // EXTI Line2 and Touch sensing interrupts

   interrupt_DMA1_CHANNEL1 = 27,
   interrupt_DMA1_CHANNEL2,
   interrupt_DMA1_CHANNEL3,
   interrupt_DMA1_CHANNEL4,
   interrupt_DMA1_CHANNEL5,
   interrupt_DMA1_CHANNEL6,
   interrupt_DMA1_CHANNEL7,

   interrupt_TIMER6_DAC = 70, // Timer6 and DAC underflow/underrun interrupt
   interrupt_TIMER7     = 71, // Timer7 interrupt

   interrupt_DMA2_CHANNEL1 = 72,
   interrupt_DMA2_CHANNEL2,
   interrupt_DMA2_CHANNEL3,
   interrupt_DMA2_CHANNEL4,
   interrupt_DMA2_CHANNEL5,
} interrupt_e;

// == exported functions

static inline void wait_for_interrupt(void);
static inline void enable_all_interrupt(void);
static inline void disable_all_interrupt(void);
static inline uint32_t getmask_interrupt(void);
static inline void enable_fault_interrupt(void);
static inline void disable_fault_interrupt(void);
static inline uint32_t getfaultmask_interrupt(void);
static inline void setbasepriority_interrupt(uint8_t priority/*0:no priority masking,<=interrupt_priority_LOW*/);
static inline uint32_t getbasepriority_interrupt(void);
static inline void clearbasepriority_interrupt(void);

static inline int setpriority_interrupt_nvic(interrupt_e intnr, interrupt_priority_e priority);
static inline uint8_t getpriority_interrupt_nvic(interrupt_e intnr);
static inline int isenabled_interrupt_nvic(interrupt_e intnr);
static inline int enable_interrupt_nvic(interrupt_e intnr);
static inline int disable_interrupt_nvic(interrupt_e intnr);
static inline int generate_interrupt_nvic(interrupt_e intnr);
static inline int clear_interrupt_nvic(interrupt_e intnr);
static inline int is_interrupt_nvic(interrupt_e intnr);

static inline int setpriority_coreinterrupt(coreinterrupt_e intnr, interrupt_priority_e priority);
static inline uint8_t getpriority_coreinterrupt(coreinterrupt_e intnr);
static inline int generate_coreinterrupt(coreinterrupt_e intnr);
static inline int clear_coreinterrupt(coreinterrupt_e intnr);
static inline int is_coreinterrupt(coreinterrupt_e intnr);
static inline int enable_coreinterrupt(coreinterrupt_e intnr);
static inline int disable_coreinterrupt(coreinterrupt_e intnr);


// == definitions

// TODO: remove EXTI
/* Register Offset (EXTI_IMR1) Interrupt mask register; Reset value: 0x1F800000
 * Bits 31:0 MRx: Event mask on external/internal line x; 0 == Masked, 1 == Interrupt Enabled */
#define HW_REGISTER_OFFSET_EXTI_IMR1 0x00
/* Register Offset (EXTI_IMR2) Interrupt mask register; Reset value: 0xFFFFFFFC
 * Bits 3:0 MRx: Interrupt mask on external/internal line x, x = 32..35; 0 == Masked, 1 == Interrupt Enabled */
#define HW_REGISTER_OFFSET_EXTI_IMR2 0x20
/* Register Offset (EXTI_RTSR1) Rising trigger selection register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Rising trigger event configuration bit of line x; 1 == Rising Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_RTSR1 0x08
/* Register Offset (EXTI_RTSR2) Rising trigger selection register; Reset value: 0x00000000
 * Bits 1:0 TRx: Rising trigger event configuration bit of line x, x=32..33; 1 == Rising Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_RTSR2 0x28
/* Register Offset (EXTI_FTSR1) Falling trigger selection register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Falling trigger event configuration bit of line x; 1 == Falling Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_FTSR1 0x0C
/* Register Offset (EXTI_FTSR2) Falling trigger selection register; Reset value: 0x00000000
 * Bits 1:0 TRx: Falling trigger event configuration bit of line x, x=32..33; 1 == Falling Trigger enabled */
#define HW_REGISTER_OFFSET_EXTI_FTSR2 0x2C
/* Register Offset (EXTI_SWIER1) Software interrupt event register; Reset value: 0x00000000
 * Bits 31:29 + Bits 22:0 TRx: Software interrupt on line x; 1 == Sets Pending Bit if IMR Bit also == 1 */
#define HW_REGISTER_OFFSET_EXTI_SWIER1 0x10
/* Register Offset (EXTI_SWIER2) Software interrupt event register; Reset value: 0x00000000
 * Bits 1:0 TRx: Software interrupt on line x, x=32..33; 1 == Sets Pending Bit if IMR Bit also == 1 */
#define HW_REGISTER_OFFSET_EXTI_SWIER2 0x30
/* Register Offset (EXTI_PR1) Pending register ; Reset value: undefined
 * Bits 31:29 + Bits 22:0 TRx: Pending bit on line x; 1 == Selected trigger request occurred
 * The bits are cleared by writing a ‘1’ to the bit (interrupt acknowledge) */
#define HW_REGISTER_OFFSET_EXTI_PR1 0x14
/* Register Offset (EXTI_PR2) Pending register ; Reset value: undefined
 * Bits 1:0 TRx: Pending bit on line x, x=32..33; 1 == Selected trigger request occurred
 * The bits are cleared by writing a ‘1’ to the bit (interrupt acknowledge) */
#define HW_REGISTER_OFFSET_EXTI_PR2 0x34

/* Register Offset (NVIC_ISERx) Interrupt set-enable registers; Reset value: 0x00000000
 * Bits 31:0 SETENA: Interrupt set-enable bits, Write 1: Enable interrupt, 0: has no effect
 * Reading 1 ==> Interrupt enabled Reading 0 ==> disabled */
#define HW_REGISTER_OFFSET_NVIC_ISER 0x000
/* Register Offset (NVIC_ICERx) Interrupt clear-enable registers; Reset value: 0x00000000
 * Bits 31:0 CLRENA: Interrupt clear-enable bits, Write 1: Disable interrupt, 0: has no effect
 * Reading 1 ==> Interrupt enabled Reading 0 ==> disabled */
#define HW_REGISTER_OFFSET_NVIC_ICER 0x080
/* Register Offset (NVIC_ISPRx) Interrupt set-pending registers; Reset value: 0x00000000
 * Bits 31:0 SETPEND: Interrupt set-pending bits, Write 1: Interrupt state changed to pending, 0: has no effect
 * Reading 1 ==> Interrupt is pending, Reading 0 ==> not pending */
#define HW_REGISTER_OFFSET_NVIC_ISPR 0x100
/* Register Offset (NVIC_ICPRx) Interrupt clear-pending registers; Reset value: 0x00000000
 * Bits 31:0 CLRPEND: Interrupt clear-pending bits, Write 1: Interrupt pending state cleared, :0 has no effect
 * Reading 1 ==> Interrupt is pending, Reading 0 ==> not pending */
#define HW_REGISTER_OFFSET_NVIC_ICPR 0x180
/* Register Offset (NVIC_IABRx) Interrupt active bit registers; Reset value: 0x00000000
 * Bits 31:0 ACTIVE: Interrupt active flags, Read 1: Interrupt active, 0: Interrupt not active */
#define HW_REGISTER_OFFSET_NVIC_IABR 0x200
/* Register Offset (NVIC_IPRx) Interrupt priority registers; Reset value: 0x00000000
 * Byte accessible. Only upper HW_KONFIG_NVIC_PRIORITY_NROFBITS bits of every byte are changeable
 * Bits [31:24]: Priority byte offset 3, Bits [23:16]: Priority byte offset 2,
 * Bits [15:8]:  Priority byte offset 1, Bits [7:0]:   Priority byte offset 1 */
#define HW_REGISTER_OFFSET_NVIC_IPR  0x300

/* Register Offset (SCB_ICSR) Interrupt control and state register; Reset value: 0x00000000
 * Definiert pending, active, clear pending bits für <coreinterrupts_e>. */
#define HW_REGISTER_OFFSET_SCB_ICSR  0x004
#define HW_REGISTER_BIT_SCB_ICSR_NMIPENDSET  (1u << 31) // NMI set-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_PENDSVSET   (1u << 28) // PendSV set-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_PENDSVCLR   (1u << 27) // PendSV clear-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_PENDSTSET   (1u << 26) // SysTick exception set-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_PENDSTCLR   (1u << 25) // SysTick exception clear-pending bit
#define HW_REGISTER_BIT_SCB_ICSR_ISRPENDING  (1u << 22) // Interrupt pending flag, excluding NMI and Faults.
#define HW_REGISTER_BIT_SCB_ICSR_VECTPENDING (0x7f << 12) // Pending vector. Indicates the exception number of
                                                          // the highest priority pending enabled exception.
#define HW_REGISTER_BIT_SCB_ICSR_RETTOBASE   (1u << 1!) // Return to base level. Indicates whether there are
                                                        // preempted active exceptions:
                                                        // 0: There are preempted active exceptions to execute
                                                        // 1: There are no active exceptions, or the currently-executing
                                                        //    exception is the only active exception
#define HW_REGISTER_BIT_SCB_ICSR_VECTACTIVE  (0x1ff)    // Active exception number. 0: Thread mode.
                                                        // (== Cortex-M IPS Spezial Register)
/* Register Offset (SCB_SHPR) System handler priority registers; Reset value: 0x00000000
 * Byte accessible. */
#define HW_REGISTER_OFFSET_SCB_SHPR  0x018
/* Register Offset (SCB_SHCSR) System handler control and state register; Reset value: 0x00000000 */
#define HW_REGISTER_OFFSET_SCB_SHCSR 0x024
#define HW_REGISTER_BIT_SCB_SHCSR_USGFAULTENA (1u << 18) // Usage fault enable bit. 1: enabled
#define HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTENA (1u << 17) // Bus fault enable bit. 1: enabled
#define HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTENA (1u << 16) // Memory management fault enable bit. 1: enabled
#define HW_REGISTER_BIT_SCB_SHCSR_SVCALLPENDED (1u << 15) // SVC call pending bit. Read 1: exception is pending
#define HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTPENDED (1u << 14) // Bus fault exception pending bit. Read 1: exception is pending
#define HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTPENDED (1u << 13) // Memory management fault exception pending bit. Read 1: exception is pending
#define HW_REGISTER_BIT_SCB_SHCSR_USGFAULTPENDED (1u << 12) // Usage fault exception pending bit. Read 1: exception is pending
#define HW_REGISTER_BIT_SCB_SHCSR_SYSTICKACT     (1u << 11) // SysTick exception active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_PENDSVACT      (1u << 10) // PendSV exception active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_MONITORACT     (1u << 8) // Debug monitor active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_SVCALLACT      (1u << 7) // SVC call active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_USGFAULTACT    (1u << 3) // Usage fault exception active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTACT    (1u << 1) // Bus fault exception active bit. Reads 1: exception is active
#define HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTACT    (1u << 0) // Memory management fault exception active bit. Reads 1: exception is active

// TODO: put DEBUG into own module !
/* Register Offset (SCB_DEMCR) Debug Exception and Monitor Control Registr; Reset value: 0x00000000 */
#define HW_REGISTER_OFFSET_SCB_DEMCR  0x0FC
#define HW_REGISTER_BIT_SCB_DEMCR_MONREQ     (1u << 19) // Indicates Debug Monitor Exception was requested by Software
#define HW_REGISTER_BIT_SCB_DEMCR_MONPEND    (1u << 17) // Change Pending State of Debug Monitor Exception
#define HW_REGISTER_BIT_SCB_DEMCR_MONEN      (1u << 16) // Indicates Debug Monitor Exception Enabled


// section: inline implementation

/* function: wait_for_interrupt
 * Versetzt den Prozessor in den Schlafmodus.
 * Daraust erwacht er mit dem nächsten Interrupt. */
static inline void wait_for_interrupt(void)
{
   __asm( "WFI" );
}

/* function: enable_all_interrupt
 * Schaltet alle Interrupts wieder ein, die mit disable_all_interrupt ausgeschaltet wurden.
 *
 * Ergebnis:
 * <getmask_interrupt> liefert 0 zurück (Default nach Reset). */
static inline void enable_all_interrupt(void)
{
   __asm( "cpsie I" );
}

/* function: disable_all_interrupt
 * Maskiert alle Interrupts (Pending Bits bleiben erhalten), bis auf NMI, Reset und Fault.
 *
 * Ergebnis:
 * <getmask_interrupt> liefert 1 zurück. */
static inline void disable_all_interrupt(void)
{
   __asm( "cpsid I" );
}

/* function: getmask_interrupt
 * Liefert 1 zurück, falls die Interrupts (ausser NMI,Reset,Fault) maskiert sind, sonst 0.
 * disable_all_interrupts schaltet die "normalen" Interrupts aus mit maximal Priorität 0. */
static inline uint32_t getmask_interrupt(void)
{
   uint32_t mask;
   __asm( "mrs %[result], PRIMASK" : [result] "=r" (mask) ::);
   return mask;
}

/* function: enable_fault_interrupt
 * Schaltet alle Interrupts wieder ein.
 *
 * Ergebnis:
 * <getfaultmask_interrupt> liefert 0 zurück (Default nach Reset). */
static inline void enable_fault_interrupt(void)
{
   __asm( "cpsie F" );
}

/* function: enable_fault_interrupt
 * Maskiert alle Interrupts (Pending Bits bleiben erhalten), bis auf NMI und Reset.
 * Diese Maske ist zusätzlich und unabhängig von <disable_all_interrupt> zu verstehen.
 *
 * Ergebnis:
 * <getfaultmask_interrupt> liefert 1 zurück. */
static inline void disable_fault_interrupt(void)
{
   __asm( "cpsid F" );
}

static inline uint32_t getfaultmask_interrupt(void)
{
   uint32_t mask;
   __asm( "mrs %[result], FAULTMASK" : [result] "=r" (mask) ::);
   return mask;
}

/* function: setbasepriority_interrupt
 * Erlaubt nur Interrupts mit höherer Priorität als priority.
 * Parameterwert 0 schaltet die Basispriortät aus.
 * Mit <disable_all_interrupt> können alle Interrupts einschliesslich der höchsten Priorität 0
 * temporär maskiert werden. */
static inline void setbasepriority_interrupt(uint8_t priority/*0:no priority masking,<=interrupt_priority_LOW*/)
{
   priority <<= (8-HW_KONFIG_NVIC_PRIORITY_NROFBITS);
   __asm( "msr BASEPRI, %[bp]" :: [bp] "r" (priority) :);
}

static inline uint32_t getbasepriority_interrupt(void)
{
   uint32_t priority;
   __asm( "mrs %[result], BASEPRI" : [result] "=r" (priority) ::);
   return priority >> (8-HW_KONFIG_NVIC_PRIORITY_NROFBITS);
}

static inline void clearbasepriority_interrupt(void)
{
   __asm( "msr BASEPRI, %[bp]" :: [bp] "r" (0) :);
}

#define VALIDATE_ADAPT_INTNR_NVIC(intnr, return_code) \
         intnr -= 16;                                                \
         if ((uint32_t)intnr > (HW_KONFIG_NVIC_EXCEPTION_MAXNR-16)){ \
            return return_code;                                      \
         }

static inline int setpriority_interrupt_nvic(interrupt_e intnr, interrupt_priority_e priority)
{
   static_assert(interrupt_priority_HIGH == 0 && interrupt_priority_HIGH < interrupt_priority_LOW);
   if (priority > interrupt_priority_LOW) {
      return EINVAL;
   }

   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   volatile uint8_t *ipr = (volatile uint8_t*)& HW_REGISTER(NVIC, IPR);
   ipr[intnr] = (uint8_t) (priority << (8-HW_KONFIG_NVIC_PRIORITY_NROFBITS));

   return 0;
}

static inline uint8_t getpriority_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 255)

   volatile uint8_t *ipr = (volatile uint8_t*)& HW_REGISTER(NVIC, IPR);
   return ipr[intnr] >> (8-HW_KONFIG_NVIC_PRIORITY_NROFBITS);
}

static inline int enable_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   volatile uint32_t *iser = & HW_REGISTER(NVIC, ISER);
   iser[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int disable_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   volatile uint32_t *icer = & HW_REGISTER(NVIC, ICER);
   icer[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int isenabled_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   volatile const uint32_t *iser = & HW_REGISTER(NVIC, ISER);
   return (iser[intnr/32] >> (intnr & 31)) & 1;
}

static inline int generate_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   volatile uint32_t *ispr = & HW_REGISTER(NVIC, ISPR);
   ispr[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int clear_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, EINVAL)

   volatile uint32_t *icpr = & HW_REGISTER(NVIC, ICPR);
   icpr[intnr/32] = 1u << (intnr & 31);

   return 0;
}

static inline int is_interrupt_nvic(interrupt_e intnr)
{
   VALIDATE_ADAPT_INTNR_NVIC(intnr, 0)

   volatile uint32_t *ispr = & HW_REGISTER(NVIC, ISPR);
   return (ispr[intnr/32] >> (intnr & 31)) & 0x1;
}

#undef VALIDATE_ADAPT_INTNR_NVIC

static inline int setpriority_coreinterrupt(coreinterrupt_e intnr, interrupt_priority_e priority)
{
   static_assert(interrupt_priority_HIGH < interrupt_priority_LOW);
   intnr -= coreinterrupt_MPUFAULT; // intnr < coreinterrupt_MPUFAULT ==> hart kodierte Priorität
   if (! (intnr <= (15-coreinterrupt_MPUFAULT) && priority <= interrupt_priority_LOW) ) {
      return EINVAL;
   }

   volatile uint8_t *shpr = (volatile uint8_t*)& HW_REGISTER(SCB, SHPR);
   shpr[intnr] = (uint8_t) (priority << (8-HW_KONFIG_NVIC_PRIORITY_NROFBITS));

   return 0;
}

static inline uint8_t getpriority_coreinterrupt(coreinterrupt_e intnr)
{
   intnr -= coreinterrupt_MPUFAULT; // intnr < coreinterrupt_MPUFAULT ==> hart kodierte Priorität
   if (! (intnr <= (15-coreinterrupt_MPUFAULT))) {
      return 255;
   }

   volatile uint8_t *shpr = (volatile uint8_t*)& HW_REGISTER(SCB, SHPR);
   return shpr[intnr] >> (8-HW_KONFIG_NVIC_PRIORITY_NROFBITS);
}

static inline int generate_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_NMI:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_NMIPENDSET;
      break;
   case coreinterrupt_MPUFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTPENDED;
      break;
   case coreinterrupt_BUSFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTPENDED;
      break;
   case coreinterrupt_USAGEFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_USGFAULTPENDED;
      break;
   case coreinterrupt_SVCALL:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_SVCALLPENDED;
      break;
   case coreinterrupt_DEBUGMONITOR:
      HW_REGISTER(SCB, DEMCR) |= HW_REGISTER_BIT_SCB_DEMCR_MONPEND;
      break;
   case coreinterrupt_PENDSV:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_PENDSVSET;
      break;
   case coreinterrupt_SYSTICK:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_PENDSTSET;
      break;
   }

   return 0;
}

static inline int clear_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTPENDED;
      break;
   case coreinterrupt_BUSFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTPENDED;
      break;
   case coreinterrupt_USAGEFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_USGFAULTPENDED;
      break;
   case coreinterrupt_SVCALL:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_SVCALLPENDED;
      break;
   case coreinterrupt_DEBUGMONITOR:
      HW_REGISTER(SCB, DEMCR) &= ~HW_REGISTER_BIT_SCB_DEMCR_MONPEND;
      break;
   case coreinterrupt_PENDSV:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_PENDSVCLR;
      break;
   case coreinterrupt_SYSTICK:
      HW_REGISTER(SCB, ICSR) = HW_REGISTER_BIT_SCB_ICSR_PENDSTCLR;
      break;
   }

   return 0;
}

static inline int is_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      break;
   case coreinterrupt_MPUFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTPENDED) & 1;
   case coreinterrupt_BUSFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTPENDED) & 1;
   case coreinterrupt_USAGEFAULT:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_USGFAULTPENDED) & 1;
   case coreinterrupt_SVCALL:
      return (HW_REGISTER(SCB, SHCSR) / HW_REGISTER_BIT_SCB_SHCSR_SVCALLPENDED) & 1;
   case coreinterrupt_DEBUGMONITOR:
      return (HW_REGISTER(SCB, DEMCR) / HW_REGISTER_BIT_SCB_DEMCR_MONPEND) & 1;
   case coreinterrupt_PENDSV:
      return (HW_REGISTER(SCB, ICSR) / HW_REGISTER_BIT_SCB_ICSR_PENDSVSET) & 1;
   case coreinterrupt_SYSTICK:
      return (HW_REGISTER(SCB, ICSR) / HW_REGISTER_BIT_SCB_ICSR_PENDSTSET) & 1;
   }

   return 0;
}

static inline int enable_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTENA;
      break;
   case coreinterrupt_BUSFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTENA;
      break;
   case coreinterrupt_USAGEFAULT:
      HW_REGISTER(SCB, SHCSR) |= HW_REGISTER_BIT_SCB_SHCSR_USGFAULTENA;
      break;
#if 0 // does not work
   case coreinterrupt_DEBUGMONITOR:
      HW_REGISTER(SCB, DEMCR) |= HW_REGISTER_BIT_SCB_DEMCR_MONEN;
      break;
#endif
   }
   return 0;
}

static inline int disable_coreinterrupt(coreinterrupt_e intnr)
{
   switch (intnr) {
   default:
      return EINVAL;
   case coreinterrupt_MPUFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_MEMFAULTENA;
      break;
   case coreinterrupt_BUSFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_BUSFAULTENA;
      break;
   case coreinterrupt_USAGEFAULT:
      HW_REGISTER(SCB, SHCSR) &= ~HW_REGISTER_BIT_SCB_SHCSR_USGFAULTENA;
      break;
#if 0 // does not work
   case coreinterrupt_DEBUGMONITOR:
      HW_REGISTER(SCB, DEMCR) &= ~HW_REGISTER_BIT_SCB_DEMCR_MONEN;
      break;
#endif
   }

   return 0;
}

#endif
